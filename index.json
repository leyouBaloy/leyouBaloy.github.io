[{"categories":["书影记录"],"content":"作者 《无人生还》是英国作家女侦探小说家阿加莎·克里斯蒂，其一生写过80部推理小说，可谓著作等身，被誉为举世公认的侦探小说女王。《无人生还》写于1939年。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"情节 小说是以上帝视角叙述的，开头首先介绍了十位被“欧文”邀请到岛上的客人，他们的背景都截然不同，有法官、医生、警督等等，但他们有个共同的特点，就是这十位都是曾经有过命案但是逃脱法律制裁。他们彼此互不相识，无冤无仇，但是到达岛上的第二天就开始离奇的死人，大家既谨慎地保全自己，又想找到最终的凶手。 小说的标题以及故事开头出现的“童谣”都暗示了最后无人生还的结局。凶手究竟是谁呢？最后的花絮揭示了答案。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"阅读感受 五一假期，难得有一下午的时间坐在图书馆的沙发上一口气三个半小时看完这本悬疑推理小说。朋友对它评价很高，我看完之后感觉确实很有意思。对于这种小说，真正吸引人的地方不是严谨的推理，而是它所描绘的那种复杂的人物心理，和充满未知的剧情。现在有很多的影视作品都是类似“孤岛生存”的主题，比如饥饿游戏，鱿鱼游戏，这些可能或多或少都有借鉴这部将近100年前的作品。 最后一部分犯人的陈述中有一句耐人寻味： 我要写完了。我要把它密封进一个瓶子里,然后将这个瓶子抛人大海。 为什么要这么做呢？ 是呀，为什么呢？ 我的目的就是要发明一桩谁也解不开的谋杀谜。 但是，我现在意识到，面对艺术，没有一个艺术家愿意孤芳自赏的。不可否认，这里面有一种渴望得到别人认可和赏识的正常心理。 这种心理可能跟我写博客一样，我不想自己把文章拿给别人去炫耀，而是写好了放在博客上，等待有心人去欣赏。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:3:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/permutations/ 全排列问题也是比较经典的问题，其所用的交换法也很巧妙。 ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"纯dfs 首先想到的办法，不用回溯，每次递归传参都是数组的复制，空间复杂度很大，但是时间复杂度和回溯法是相同的（应该）。 class Solution: def permute(self, nums: List[int]) -\u003e List[List[int]]: path = [] res = [] size = len(nums) def recursion(leftnums,path): if len(path)==size: res.append(path) else: for num in leftnums: new_path = path.copy() new_path.append(num) new_leftnums = leftnums.copy() new_leftnums.remove(num) recursion(new_leftnums, new_path) recursion(nums, path) return res ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"交换、回溯 在前面做过的回溯题中，比如Leetcode17:电话号码的字母组合、Leetcode113:路径总和，我们都是用栈来维护储存路径的数组，但是在这题当中我们用交换的方法来维护，很巧妙啊！ 有两个变量first和i。在每一次递归当中，0～first是已确定的路径，i是与first交换的数的位置。看下图： 代码（c++的stl里有swap函数，写出的代码更简洁） class Solution { public: void backtrack(vector\u003cvector\u003cint\u003e\u003e\u0026 res, vector\u003cint\u003e\u0026 output, int first, int len){ if(first==len){ res.emplace_back(output); return; } for(int i=first;i\u003clen;i++){ // 动态维护数组 swap(output[i], output[first]); // 继续递归填下一个数 backtrack(res, output, first+1, len); // 撤销操作 swap(output[i], output[first]); } } vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e res; backtrack(res, nums, 0, (int)nums.size()); return res; } }; ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:2","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ 终于能自己做出一道题了😭，之前的回溯题没白刷 ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"回溯 思路：先用哈希表储存数字对应的字母，然后用回溯法记录搜索路径。 画个图帮助理解： 代码： class Solution: def letterCombinations(self, digits: str) -\u003e List[str]: if digits==\"\": return [] tel = {\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"} size = len(digits) path = [] res = [] def backtracking(i, path, res): for letter in tel[digits[i]]: path.append(letter) if i==size-1: res.append(\"\".join(path)) path.pop() else: backtracking(i+1, path, res) path.pop() backtracking(0, path, res) return res 时间复杂度：O(3^m * 4^n)，m是电话键盘上有三个字母对应的数的个数，n是电话键盘上有四个字母对应的数的个数。需要遍历一遍所有的组合。 空间复杂度：O(m+n)，主要为记录路径的开销，路径最长也只有len(digits) ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/3sum-closest/ ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"排序+双指针 这道题的官方题解写的太好了：https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/ 我总结一下： 思路是在暴力搜索枚举i，j，k 三个指针的基础上发展来的。首先要对数组进行排序，因为： 不排序的话，数组没有规律，只能暴力搜索，没有可操作空间。 排序完就可以在搜索过程中优化，相当于剪枝。 以升序为例，排完序后先枚举i，对于剩下的j和k，令j=i+1，k=nums.size()-1： 如果三数之和 \u003e target，则左移k。 如果三数之和 \u003c target，则右移j 如果三数之和 = target，直接返回target。 代码： class Solution { public: int threeSumClosest(vector\u003cint\u003e\u0026 nums, int target) { sort(nums.begin(), nums.end()); int res=nums[0]+nums[1]+nums[2]; for(int i=0;i\u003cnums.size()-2;i++){ int j=i+1, k=nums.size()-1; while(j\u003ck){ int cur_sum = nums[i]+nums[j]+nums[k]; if(abs(cur_sum-target)\u003cabs(res-target)){ res = cur_sum; } if(cur_sum\u003ctarget){ j++; } else if(cur_sum\u003etarget){ k--; } else{ return cur_sum; } } } return res; } }; 时间复杂度O(N^2)，空间复杂度O(logN)，主要为排序的空间。 ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/container-with-most-water/ 每次看题解：“我又会了！” 下一题：“我是废物。” ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"双指针 定义两个指针left和right分别在最左边和最右边，指向两个柱子，那么面积肯定等于两柱子中最小的柱子乘上宽度。 求出面积后要移动指针，那么移动哪一个指针呢？当然是指向柱子中较矮的那个指针。因为如果移动高的珠子，宽度减小，而由于短板效应，高度仍取决于矮柱子，所以移动后的面积只减不增。 那如果两指针指向柱子的高度相同呢？那就两个指针一起向中间移动，原理同上。 代码： class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int max_area = 0; int left=0,right=height.size()-1; while(left\u003cright){ if(height[left]\u003cheight[right]){ max_area = max(max_area, height[left]*(right-left)); left++; } else if(height[left]\u003eheight[right]){ max_area = max(max_area, height[right]*(right-left)); right--; } else{ max_area = max(max_area, height[left]*(right-left)); left++; right--; } } return max_area; } }; 相比于暴力搜索，这种方法相当于是剪枝，把不可能的情况都嘎掉了。 时间复杂度O(n)，空间复杂度O(1)。 ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/network-delay-time/ 关于最短路径dijkstra算法，学了很多遍，每次学的都不深，所以学完就忘，代码肯定更是写不出来。今天再学一次。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 关于dijkstra算法具体内容就不在这里细说了，网上一大堆，这里主要关注代码。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"代码 class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: g = [[float('inf')]*n for _ in range(n)] for x, y, time in times: g[x-1][y-1] = time dist = [float('inf')] * n dist[k-1] = 0 used = [False] * n for _ in range(n): x = -1 for y, u in enumerate(used): if not u and (x == -1 or dist[y] \u003c dist[x]): x = y used[x] = True for y,time in enumerate(g[x]): dist[y] = min(dist[y], dist[x]+time) ans = max(dist) return ans if ans \u003c float('inf') else -1 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"代码详解 g[][]：用邻接矩阵来储存这个图。g[x][y]表示从节点x到节点y的距离。如果不能到达，储存距离为无穷大。注意这段代码中把所有的节点都-1，这只是表示方式的问题，不重要。 这段代码就是在构建g： g = [[float('inf')]*n for _ in range(n)] for x, y, time in times: g[x-1][y-1] = time dist[]：dist[i]表示从起点k到节点i的最短距离（当前已知）。赋初值为无穷大。 used[]：记录算法运行时使用过的节点。初值是把起始节点赋值为True，其余False。 for y, u in enumerate(used): if not u and (x == -1 or dist[y] \u003c dist[x]): x = y used[x] = True 上面这段代码，每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。x就是要找的那个已确定节点，第一次x=k。 for y,time in enumerate(g[x]): dist[y] = min(dist[y], dist[x]+time) 用节点 A「更新」节点 B 的意思是，用起点到节点 A 的最短路长度加上从节点 A 到节点 B 的边的长度，去比较起点到节点 B 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。这里节点A就是x，节点B就是y。 最后根据这题的要求，找dist[]里最大的返回就行了。 时间复杂度：O(n^2+m)，其中 m 是数组times 的长度。 空间复杂度：O(n^2)。邻接矩阵需占用 O(n^2)的空间。 dijkstra算法的时间复杂度为O(n^2) ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"用小根堆优化 可以使用一个小根堆来寻找「未确定节点」中与起点距离最近的点。 这个具体就不研究了，能把基本算法搞明白就不错了😂。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题","笔记"],"content":"题目 题目：在二维坐标系中，给你两条线段的四个端点坐标，问如何判断两条线段是否相交？ 初步分析：我们知道，对于直线来说不平行就相交，非常好判断。但是对于线段来说，有共线相交，共线不相交，不共线相交，不共线不相交等情况。我们要找到一个优雅的办法，把所有的情况都能考虑到。下面介绍两步就能判断的方法： ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:1:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"第一步：快速排斥实验 **如果两线段在x，y的投影都不重合，是不可能会相交的。**换一种说法，就是以两条线段为对角线画矩形，两矩形如果没有重合的地方，那么两线段也一定不相交。 假设给出的四个点为Ax1, Ay1,Ax2,Ay2,Bx1,By1,Bx2,By2，代码如下： max(Ax1,Ax2)\u003e=min(Bx1,Bx2)\u0026\u0026min(Ax1,Ax2)\u003c=max(Bx1,Bx2)//判断x max(Ay1,Ay2)\u003e=min(By1,By2)\u0026\u0026min(Ay1,Ay2)\u003c=max(By1,By2)//判断y 除此之外，这一步还能排除一个特殊情况：共线不相交 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:1:1","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"第二步：跨立实验 先了解一个线性代数知识：叉积 向量A和向量B叉积，如果AxB\u003e0，那么B在A的逆时针方向，如果AxB\u003c0，那么B在A的顺时针方向。如果AxB=0，那么B与A共线。 图我就不画了，很好理解，AxB = a*b*sin(theta) 把端点移到原点，向量(x1,y1)与向量 （x2，y2）的叉积为 x1*y2-x2*y1 然后对于两直线相交的情况，我们发现它有一个性质，就是向量A1B1叉乘向量A1A2的符号一定与向量A1B2叉乘向量A1A2的符号相反。为了方便写代码，我们把其中一个端点移到零点。 代码： if( ( (Bx1-Ax1)*(Ay2-Ay1)-(By1-Ay1)*(Ax2-Ax1) ) * //判断B是否跨过A ( (Bx2-Ax1)*(Ay2-Ay1)-(By2-Ay1)*(Ax2-Ax1) ) \u003c=0 \u0026\u0026 ( (Ax1-Bx1)*(By2-By1)-(Ay1-By1)*(Bx2-Bx1) ) * //判断A是否跨过B ( (Ax2-Bx1)*(By2-By1)-(Ay2-By1)*(Bx2-Bx1) ) \u003c=0 ) 还有一种特殊的情况，一条线段的端点在另一条线段上，这样的话A1B1与A1A2的叉积为0，我们只要把判断条件加一个等于号就行了。 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:2:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"完整代码 bool judge(int Ax1,int Ay1,int Ax2,int Ay2,int Bx1,int By1,int Bx2,int By2) { if( ( max(Ax1,Ax2)\u003e=min(Bx1,Bx2)\u0026\u0026min(Ax1,Ax2)\u003c=max(Bx1,Bx2) )\u0026\u0026 //判断x轴投影 ( max(Ay1,Ay2)\u003e=min(By1,By2)\u0026\u0026min(Ay1,Ay2)\u003c=max(By1,By2) ) //判断y轴投影 ) { if( ( (Bx1-Ax1)*(Ay2-Ay1)-(By1-Ay1)*(Ax2-Ax1) ) * //判断B是否跨过A ( (Bx2-Ax1)*(Ay2-Ay1)-(By2-Ay1)*(Ax2-Ax1) ) \u003c=0 \u0026\u0026 ( (Ax1-Bx1)*(By2-By1)-(Ay1-By1)*(Bx2-Bx1) ) * //判断A是否跨过B ( (Ax2-Bx1)*(By2-By1)-(Ay2-By1)*(Bx2-Bx1) ) \u003c=0 ) { return 1; } else return 0; } else return 0; } 参考资料：https://blog.csdn.net/NEFU_kadia/article/details/104462906 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:3:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"遍历k次，取最小 思路：创建结果数组v，赋一个很大的初始值（s.size()+1就够了）。首先遍历一遍s，记录下每个c的位置ci。然后对于每个ci遍历一次s，如果abs(ci-当前位置) \u003c v[i]，那么就令v[i] = ci。最后得到的答案就是距离最近的。 代码： class Solution { public: vector\u003cint\u003e shortestToChar(string s, char c) { int size = s.size(); vector\u003cint\u003e v(size, size+1); vector\u003cint\u003e cv; for(int i=0;i\u003csize;i++){ if(s[i]==c){ cv.push_back(i); } } // cout \u003c\u003c \"cv:\"; // for(int i=0;i\u003ccv.size();i++){ // cout \u003c\u003c cv[i] \u003c\u003c \",\"; // } for(const int\u0026 ccv:cv){ for(int j=0;j\u003csize;j++){ if(abs(ccv-j)\u003cv[j]){ v[j]=abs(ccv-j); } } } return v; } }; 如果有k个c，那么就要遍历k+1遍。时间复杂度O((k+1)*n)。空间复杂度O(1)，返回数组不计入。 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:1","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"两次遍历 事实上，只需要两次遍历，一次从左到右遍历s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=i-idx。 从右往左遍历 s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=min(answer[i],idx−i)。 代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 −n 或 2n 表示，这里 n 是 s 的长度。 代码： class Solution { public: vector\u003cint\u003e shortestToChar(string s, char c) { int n = s.length(); vector\u003cint\u003e ans(n); for (int i = 0, idx = -n; i \u003c n; ++i) { if (s[i] == c) { idx = i; } ans[i] = i - idx; } for (int i = n - 1, idx = 2 * n; i \u003e= 0; --i) { if (s[i] == c) { idx = i; } ans[i] = min(ans[i], idx - i); } return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode-sol-2t49/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 虽然是道简单题，但我还是被秀了一脸。 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:2","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/lexicographical-numbers/ 日常做不出来😭 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:1:0","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"题解 什么是字典序？（原谅我到了大二才搞明白什么是字典序😂） 对于字符串，先按首字符排序，如果首字符相同，再按第二个字符排序，以此类推。 如aa,ab,ba,bb,bc就是一个字典序。 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:0","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"dfs 我们可以画一棵树。 第一层设置为0。 第二层是1,2,3…,9 第三层是0,1,2,3,…,9 第四层及往后层都同第三层 深度优先遍历这棵树，记录路径就是答案啦。 当然了，把树具体化为代码其实是一件很难得事情： class Solution: def lexicalOrder(self, n: int) -\u003e List[int]: res = [] for i in range(1,10): if i \u003e n: break res.append(i) self.dfs(i, n, res) # 以i为开头枚举 return res def dfs(self, i, n, res): for k in range(0,10): val = i*10+k if val \u003e n: return else: res.append(val) self.dfs(val, n, res) 细节： 先枚举1,2,3…,9，因为第一个数不能为0。 在后面枚举时要把0加上。 时间复杂度O(n)，空间复杂度O(logn)，主要为栈的开销 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:1","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"迭代法 很有思维的一种方法！ 代码： class Solution: def lexicalOrder(self, n: int) -\u003e List[int]: ans = [0] * n num = 1 for i in range(n): ans[i] = num if num * 10 \u003c= n: num *= 10 else: while num % 10 == 9 or num + 1 \u003e n: num //= 10 num += 1 return ans 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/lexicographical-numbers/solution/zi-dian-xu-pai-shu-by-leetcode-solution-98mz/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:2","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/longest-palindromic-substring/ ","date":"2022-04-17","objectID":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/:1:0","tags":null,"title":"Leetcode5:最长回文子串——中心扩展法","uri":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"},{"categories":["刷题"],"content":"题解 中心扩展法，看到这个名字我就知道该怎么做了，然后做了二十分钟….debug总是出问题… 这道题需要注意的细节： 回文子串长度既可以是奇数也可以是偶数，如果是奇数，那么它有一个中心，如果是偶数，则是两个中心。 那么代码思路就是先枚举中心，然后由中心向外扩展，直到不能扩展为止，记录下最大的扩展长度。 优雅的官方题解代码如下： class Solution: def expand(self, s, left, right): while left \u003e=0 and right \u003c len(s) and s[left] == s[right]: left -= 1 right += 1 return left+1, right-1 def longestPalindrome(self, s: str) -\u003e str: start, end = 0, 0 for i in range(len(s)): left1, right1 = self.expand(s, i ,i) left2, right2 = self.expand(s, i, i+1) if right1-left1 \u003e end - start: start, end = left1, right1 if right2-left2 \u003e end - start: start, end = left2, right2 return s[start: end+1] 太优雅了，我感觉这代码水平领先我至少刷一年题。 ","date":"2022-04-17","objectID":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/:2:0","tags":null,"title":"Leetcode5:最长回文子串——中心扩展法","uri":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"},{"categories":["技能分享","笔记"],"content":"Git如何撤回远程仓库已经提交的版本？ 不能直接在像gitee, github这样的远程仓库上直接操作。所以先把项目clone下来。 执行 git log查看日志，获取需要回退的版本号 ，如5f6935bcc46d480113f0c49d4b54052d10c5aec0。 执行git reset --hard \u003c版本号\u003e，重置到这个版本。(此时相当于撤回了commit) –soft 表示只是改变了HEAD的指向，本地代码不会变化 –hard 表示本地代码也重置到此版本 执行 git push origin 分支名 –-force 强制提交。 如git push origin master –f 然后看远程仓库，你会惊喜的发现5f6935bcc46d480113f0c49d4b54052d10c5aec0之后的版本都消失啦！ ","date":"2022-04-16","objectID":"/posts/git%E6%92%A4%E9%94%80%E7%89%88%E6%9C%AC/:1:0","tags":null,"title":"Git撤销版本","uri":"/posts/git%E6%92%A4%E9%94%80%E7%89%88%E6%9C%AC/"},{"categories":["笔记"],"content":"read_csv()参数 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:1:0","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["笔记"],"content":"header header=None 读取时不设置表头 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:1:1","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["笔记"],"content":"drop() df.drop(0) 删除第一行 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:0","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/sort-characters-by-frequency/ ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:0","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"思路 用一个哈希map先统计每个字符出现的次数，然后再排序，最后拼接字符串。排序的方法多种多样，因为字符是有限的（26个小写，26个大写，0-9数字），所以使用桶排序是最好的选择。 ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:1","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"桶排序 假设你对2，5，3三个数字排序，最大的数字是5，所以你拿来五个桶，从头到尾遍历这三个数字。然后把数字放在相同标号的桶里，比如第一个数字是2，就把它放在标号为2的桶里，5就放在标号为5的桶，3就放在标号为3的桶里。最后再把1号到5号桶遍历，空的跳过，就完成了排序。典型的空间换时间，当已知不会消耗很大的空间时，桶排序无非是效率最高的。 具体做法如下： 遍历字符串，统计每个字符出现的频率，同时记录最高频率maxFreq； 创建桶，存储从 11 到 maxFreq 的每个出现频率的字符； 按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。 代码： class Solution { public: string frequencySort(string s) { unordered_map\u003cchar, int\u003e mp; int maxFreq = 0; int length = s.size(); for (auto \u0026ch : s) { maxFreq = max(maxFreq, ++mp[ch]); } vector\u003cstring\u003e buckets(maxFreq + 1); for (auto \u0026[ch, num] : mp) { buckets[num].push_back(ch); } string ret; for (int i = maxFreq; i \u003e 0; i--) { string \u0026bucket = buckets[i]; for (auto \u0026ch : bucket) { for (int k = 0; k \u003c i; k++) { ret.push_back(ch); } } } return ret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-by-l-zmvy/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：O*(n+*k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。 空间复杂度：O*(n+*k) ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:2","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["书影记录"],"content":"故事简叙 《失乐园》 久木是一家出版社的编辑，人到中年，事业不会有进一步发展了，对家人的感情也是平平淡淡的，生活只是一日复一日，清闲无聊得很。 一次偶然的工作聚会上，久木认识了凛子，对她产生了兴趣。凛子30岁，正是端庄美丽之时，但她的婚姻生活并不美好，丈夫忙于工作，无论是在感情上还是在性上都不能满足凛子。但凛子并不是淫荡的女人，在认识久木之前，她也秉持着传统东方女人的内敛，羞涩与神秘，还有坚韧和倔强，直到认识久木之后，是久木带着她闯入了性爱的乐园唤醒了她对性与爱的渴望，坠入深渊之后，便一去不复返了。 两人最初是在镰仓旅馆里做云雨之事，这个时候久木是进攻者，凛子是防守者。看着凛子破防是久木的享受： “和女性同时达到高潮固然不错，但眼看着女性一步步走向顶点也另有其美妙的感觉。前者沉浸在自己的快乐中，后者则享有把所爱的女人送入极乐的境地，令她充分满足的握有主动权的喜悦。” 凛子的父亲去世了，呆在娘家守丧。久木按耐不住自己的欲望，死乞白赖地请求凛子抽空跟他见一面，凛子穿着丧服赴约后，久木命令她撩开裙摆插入…如此背德的事情，让性爱的快感更强烈了。二人就像同谋罪犯一样，命运更紧密地联合在一起了。 “男人和女人都清楚，眼前这无与伦比的美，发源于稀世罕见的粗俗和淫靡，而他们却甘愿堕人到那淫荡的世界中去。” 本来二人都以为这次偷情只是昙花一现，很快就能恢复原本的生活，结果却越陷越深，难以割舍。频繁的幽会，自然引起了家人的怀疑，久木的妻子提出离婚，而久木犹豫不决。凛子的丈夫则不同意离婚，他想把凛子限制在婚姻的枷锁内惩罚她，悲剧的发生似乎是不可阻挡了。同时久木的同事水口去世，还有两人反复聊到阿部定情杀的故事，在性爱时掐住脖子体验濒死的感觉，暗示着最终走向死亡的结局。 “刚才凛子说“我好难受”时掐住了他脖子，久木以为她是闹着玩儿，没想到凛子会来真格的。被她扼住喉咙时，久木真切地感受到了被带往遥远的世界去的不安，也品味到了某种甘美的感觉。” 凛子打算彻底与丈夫断绝关系，更多的时间是跟久木厮混在一起。她的身体更加丰满，更有韵味，在性爱中变得更加主动，或者说更加淫荡。 “这回没忍住吧?” 望着笑眯眯的凛子，久木再次品尝了失败的滋味。” 二人在欲乐园里贪恋不可自拔，为了追求更高的刺激，她们变换不同的姿势，用不同的体位，还购买了工具。而来自家庭，工作的恶意让他们难以在现实生活中立足，只能彼此依靠。所以活着有什么意思呢？还不如就在欢娱达到顶点之时死去算了。 “女人是在晕眩般极度快乐中梦见死，相比之下，男人则是在坠落下去的虚脱感中被死的阴影所缚，两者真是天壤之别啊！” “在人生态度上，久木渐渐开始倾向于要全力以赴地把握现在的刹那主义，这也是凛子的影响。” 最终的结局，是二人在别墅中自杀。被发现时身体还紧紧的结合在一起。 ","date":"2022-04-15","objectID":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"《失乐园》读后有感","uri":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"日本人对死的看法 日本文学中出现了很多关于死的想法，很多日本知名作家都选择自杀，比如有岛武郎（小说中有提到），芥川龙之介，太宰治，三岛由纪夫，川端康成（小说中也提到了），樱花精神和武士精神也都是一种崇尚“高贵的死”的精神，这一点和中国古代的文人把精神看作比生命更重要是类似的，可能也是因为日本的文化来源于中国文化，但是日本人把这种精神发展到极致了。 很明显我们现在的价值观是不认同这种的，中国有句话叫“好死不如赖活着”，中国的自杀率也远低于日本。 ","date":"2022-04-15","objectID":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"《失乐园》读后有感","uri":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":" 腾讯会议截图 最好的会议软件 参会人数150 每一次在公开场合的讲话对我都是一次极大的锻炼提高！担任活动策划、组织者非常不容易，要考虑每一个细节，尽力满足每一个参与者。事前进行了很多准备，真是台上十分钟台下十年功啊！经过几次锻炼，我现在可以越来越从容稳重地做这种工作了。 ","date":"2022-04-10","objectID":"/posts/%E6%88%90%E5%8A%9F%E4%B8%BB%E6%8C%81150%E4%BA%BA%E5%8F%82%E4%BC%9A%E7%9A%84%E8%AE%B2%E5%BA%A7/:0:0","tags":null,"title":"成功主持150人参会的讲座！","uri":"/posts/%E6%88%90%E5%8A%9F%E4%B8%BB%E6%8C%81150%E4%BA%BA%E5%8F%82%E4%BC%9A%E7%9A%84%E8%AE%B2%E5%BA%A7/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/subarray-sum-equals-k/ 不能用滑动窗口，因为右指针不一定递增。不能用dp，会超时溢出。 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"枚举法 枚举法会超时，但可以为我们提供思路。 考虑以j结尾和为 k 的连续子数组个数，我们需要统计符合条件的下标 i的个数。在确定了i和j之后，如果我们再遍历求和，时间复杂度就达到了O(n的3次方)。实际上我们发现sum([i:j]) = sum([i-1:j])-nums[i-1]，这样递推地可以直接求和。时间复杂度降到了O(n的2次方)。 代码： class Solution { public: int subarraySum(vector\u003cint\u003e\u0026 nums, int k) { int size = nums.size(); int cnt = 0; int sum = 0; for(int i=0;i\u003csize;i++){ sum = 0; for(int j=i;j\u003csize;j++){ sum += nums[j]; if(sum==k){ cnt+=1; } } } return cnt; } }; ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:1","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"前缀和+哈希表 我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。 我们定义 pre[i] 为 0..i 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即： pre[i]=pre[i−1]+nums[i] 那么 j..i 这个子数组和为 k 这个条件我们可以转化为 pre[i]−pre[j−1]==k 简单移项可得符合条件的下标 j 需要满足 pre[j−1]==pre[i]−k 所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。 需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于 pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。 AC代码： class Solution { public: int subarraySum(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; mp[0] = 1; int cnt=0, pre=0; for(auto\u0026 x:nums){ pre += x; if(mp.find(pre-k)!=mp.end()){ cnt += mp[pre-k]; } mp[pre]++; } return cnt; } }; 实际上这道题的细节我花了很多时间去想，但到现在也没弄懂，先放在这里留个问号吧。 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:2","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题","笔记"],"content":"c++常用函数 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"sort(v.begin(),v.end()) // 向量v vector\u003cint\u003e v; sort(v.begin(),v.end()) // 数组a sort(a,a+n); // 可以加参数cmp // 比如对intervals = [[1,2],[2,3],[3,4],[1,3]] 中每个向量第一个元素按从小到大排序 sort(intervals.begin(), intervals.end(), [](const auto\u0026 u, const auto\u0026 v) { return u[0] \u003c v[0]; }); 默认升序 如果要逆序就麻烦了 template \u003ctypename T\u003e struct cmp { bool operator()(const T \u0026x, const T \u0026y) { return x\u003ey; } }; sort(nums.begin(),nums.end(),cmp\u003cint\u003e()); ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:1","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"max_element(v.begin(),v.end()) 返回指针，指向最大元素 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:2","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"pair\u003cint,int\u003e pair\u003cint, int\u003e p1(1, 2); 定义和初始化 可以用已有对象初始化pair\u003cint, int\u003e p2(p1); 没有初始化，默认为(0,0) 赋值：p2 = pair\u003cint, int\u003e (1, 4); 强制类型转换 访问：p2.first,p2.second make_pair(1,2) ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:3","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"queue() queue\u003cpair\u003cint,int\u003e\u003e que 构造 que.emplace(1,2) emplace自带调用构造函数，而push需要先自己搞出对象再传入 que.front()返回队首元素的引用 que.back()返回队尾元素的引用 que.pop()删除第一个元素 queue.size()元素数量 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:4","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"find() find(v.begin(), v.end(), 3) 查找v中==3的元素的位置，返回指针 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:5","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"priority_queue 头文件： #include\u003cqueue\u003e 定义：priority_queue\u003cint\u003e p; 默认为大顶堆 或priority_queue\u003cType, Container, Functional\u003e Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。 如priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); 其中比较函数为： static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } 这里定义的是一个储存pair\u003cint,int\u003e的小顶堆。 操作（和队列基本操作相同： top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 参考：https://blog.csdn.net/weixin_36888577/article/details/79937886 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:6","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"unordered_set() 创建：unordered_set\u003cchar\u003e occ; 删除：occ.erase('a') 插入：occ.insert('a') 判断是否在set中：occ.count('a') ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:7","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"vector\u003c\u003e 创建一个n*n的二维数组：vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(n)); 创建变量并赋初始值：vector\u003cint\u003e v(10,1) 长度为10，初值1 dp.push_back()，添加一个元素 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:8","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"python常用函数 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"sorted() sorted(iterable, key=None, reverse=False) 参数说明： iterable – 可迭代对象。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 返回重新排序的列表。 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:1","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"set() 创建：occ = set() occ = set(iterable比如列表、字符串) 删除：occ.remove('a') 插入：occ.add('a') 判断是否在set中：'a' in occ ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:2","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 乍一看好像做过，再一看好像不会😂 题解 ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"暴力法 设字符串为s，假如我们要找的这段没有重复字符的序列是从i起始，到rk结束（即s[i:rk]）。 那么用两个循环暴力枚举i和rk，看s[i:rk]是不是无重复元素的序列，记录下最大的序列。 贴个超时代码： class Solution: def lengthOfLongestSubstring(self, s: str) -\u003e int: s = s.replace(\" \",\"1\") size = len(s) max = 0 for i in range(size): for j in range(size+1): n = len(s[i:j]) if n==len(set(s[i:j])) and n\u003emax: max = n return max 暴力法是无脑的，不懂得使用先前循环的经验。那么如何优化呢？ ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:1:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"滑动窗口 首先就是建议看官方题解….我这里再稍微总结一下： 这道题目有这样的性质：当i递增时，rk也一定是递增的，因此我们不用像暴力法那样一次又一次把rk回溯。 为什么呢？因为如果s[i:rk]没有重复元素，那么s[i+1:rk]也一定没有重复元素。因此rk只需要向后移动，不需要回到前面。 所以滑动窗口的思路就是这样： 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk。 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度； 在枚举结束后，我们找到的最长的子串的长度即为答案。 判断一个序列是否有重复的字符用到的数据结构是哈希集合。c++和python都有这种数据结构。 看代码： class Solution { public: int lengthOfLongestSubstring(string s) { // 哈希set unordered_set\u003cchar\u003e occ; int rk=0; int n = s.size(); int max_len = 0; // 左指针初始为-1，此时不需要删除 for(int i=-1;i\u003cn-1;i++){ if(i!=-1){ occ.erase(s[i]); } // 右指针先加入set，再右移1格 while(rk\u003cn \u0026\u0026 !occ.count(s[rk])){ occ.insert(s[rk]); rk++; } max_len = max(max_len, rk-i-1); } return max_len; } }; 细节： 左指针移动，从哈希set中删除一个元素 右指针移动，从哈希set中添加一个元素 左指针从-1开始，如果从0开始，会导致第一个元素不能被删除 …这段代码细节蛮多的，涉及到双指针的问题，一定要在草稿纸上演算好，不然写代码一时爽，debug火葬场。 ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:2:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/top-k-frequent-elements/ 从这题开始学会使用堆 题解 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:0:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"堆（heap） 大顶堆：父节点的值大于子节点的值。 小顶堆：父节点的值小于子节点的值。 性质：根节点一定是最大（最小）值 这是一个小顶堆的例子： 小顶堆例子 参考：https://www.cnblogs.com/wmyskxz/p/9301021.html ps：会有人把上学期刚学的东西忘得一干二净吗？会，是谁我不说😂。 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:1:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"优先队列（priority_queue） 优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 直接看c++ STL 头文件： #include\u003cqueue\u003e 定义：priority_queue\u003cint\u003e p; 默认为大顶堆 或priority_queue\u003cType, Container, Functional\u003e Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。 如priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); 其中比较函数为： static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } 这里定义的是一个储存pair\u003cint,int\u003e的小顶堆。 操作（和队列基本操作相同： top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 参考：https://blog.csdn.net/weixin_36888577/article/details/79937886 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:2:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"排序大法和大顶堆法 先搞清楚这些咱们才开始做题： 首先最容易想到的，就是统计次数，时间复杂度O(n)。再排序，时间复杂度O(nlogn)。总时间复杂度O(nlogn) 下面是自己写的代码： class Solution: def topKFrequent(self, nums: List[int], k: int) -\u003e List[int]: s = {} for i in nums: if i not in s.keys(): s[i] = 1 else: s[i] += 1 s1 = [(a,b) for a,b in s.items()] s2 = sorted(s1, key=lambda x:x[1], reverse=True) print(s2) return [s2[i][0] for i in range(k)] 同样的，如果用大顶堆把所有[数字,出现次数]加入进去，然后k次返回堆顶元素，时间复杂度也是O(nlogn)。涉及到数据结构的话，最好还是用c艹来写： class Solution { public: static bool cmp(pair\u003cint,int\u003e\u0026m, pair\u003cint,int\u003e\u0026n){ return m.second \u003c n.second; } vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint,int\u003e occur; for( auto\u0026 v:nums){ occur[v]++; } priority_queue\u003cpair\u003cint,int\u003e,vector\u003cpair\u003cint,int\u003e\u003e,decltype(\u0026cmp)\u003e q(cmp); for(auto\u0026 [num,count]:occur){ q.emplace(num,count); } vector\u003cint\u003e res; while(k\u003e0){ res.push_back(q.top().first); q.pop(); k--; } return res; } }; 以上两种方法时间复杂度为O(nlogn)，都不符合题目要求。那么要做到“优于O(nlogn)”用什么方法呢？ ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:3:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"小顶堆法 取自官方题解： 在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」： 如果堆的元素个数小于 k，就可以直接插入堆中。 如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。 遍历完成后，堆中的元素就代表了「出现次数数组」中前 k 大的值。 代码： class Solution { public: static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e occurrences; for (auto\u0026 v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); for (auto\u0026 [num, count] : occurrences) { if (q.size() == k) { if (q.top().second \u003c count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector\u003cint\u003e ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 由于只需要维护大小为k的堆，所以空间复杂度会小。而且不用对于所有的元素都执行插入堆的操作，所以时间复杂度也优于上面的方法。 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:4:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/minimum-height-trees/ 这是一道理论性很强，代码也很有技巧性的“中等”难度题目。 题解 ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:0:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"暴力法 献上我的超时代码： class Solution: def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u003e List[int]: find = {} for edge in edges: if edge[0] in find.keys(): find[edge[0]].append(edge[1]) else: find[edge[0]] = [edge[1]] if edge[1] in find.keys(): find[edge[1]].append(edge[0]) else: find[edge[1]] = [edge[0]] if not len(find): return [0] def findlevel(edges, root): que = [root] used = [] cnt = 0 while(len(que)): # print(que) for i in range(len(que)): root = que.pop(0) used.append(root) for f in find[root]: if f not in used: que.append(f) cnt+=1 return cnt-1 res_num = [findlevel(edges, root) for root in range(n)] min_num = min(res_num) return [i for i in range(len(res_num)) if res_num[i]==min_num] ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:1:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"广度优先搜索 有如下结论： 用反证法证明，证明过程挺复杂的。 所以我们就把这题从寻找最短距离变成了寻找最长距离。然后把路径记录下来，路径的中点就是我们要找的根节点。 你不觉得这个结论很奇妙吗？我想到了一团乱的绳子，如果你从中间把这堆绳子拎起来，四周绳子的末梢就会垂下去… 这题代码我分段详解： 首先是第一段代码： g = [[] for _ in range(n)] for x, y in edges: g[x].append(y) g[y].append(x) parents = [0] * n 因为后面要在edges里面查找某个节点连接的另一个节点，所以这里第一步先是做了一个初始化，便于后面的查询。最后得到的结果是g[x]=[a,b,c...]，表示标号为x的节点，连接了a,b,c等节点。（在我的代码中也有类似处理，但我用的是字典） 第二段： def bfs(start: int): vis = [False] * n vis[start] = True q = deque([start]) while q: x = q.popleft() for y in g[x]: if not vis[y]: vis[y] = True parents[y] = x q.append(y) return x x = bfs(0) # 找到与节点 0 最远的节点 x y = bfs(x) # 找到与节点 x 最远的节点 y 这是一个用队列实现的广度优先搜索。vis是记录已搜索过的节点。deque是双向队列（震惊！原来python也是有数据结构的，我才知道😂）。parents记录每个节点的父节点，用于下面找路径。 然后从0开始，找到最远节点x，再从x找最远节点y。那么x，y之间的距离就是最远的（这很奇妙）。 第三段： path = [] parents[x] = -1 while y != -1: path.append(y) y = parents[y] m = len(path) return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]] 在这里要找路径了，这时候parents就派上用场了。如果找到路径长度为奇数，那么正中间那个数就是我们要找的根节点。如果路径长度为偶数，中间的数有两个，那么两个都是我们要找的根节点。 ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:2:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"其他解法 这题还有深度优先搜索（跟广度优先搜索差不多），拓扑序列，不断剔除度为1的节点等方法，我太懒了，不想研究了… ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:3:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/add-two-numbers/ 这道题主要是debug 题解 我自己写的代码： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* res = nullptr; int carry = 0; while(l1!=nullptr || l2!=nullptr){ int sum = 0; if(l1==nullptr){ sum = l2-\u003eval; } else if(l2==nullptr){ sum = l1-\u003eval; } else{ sum = l1-\u003eval + l2-\u003eval; } if(carry){ sum += carry; carry = 0; } if(sum\u003e=10){ carry = 1; sum = sum%10; } res = new ListNode(sum, res); if(l1!=nullptr) l1=l1-\u003enext; if(l2!=nullptr) l2=l2-\u003enext; } if(carry){ res = new ListNode(1, res); } return reverseList(res); } }; 还用了一个反转链表的函数，属于绕弯形选手😂 评论里给出的代码，我认为是最简洁优雅易懂的（虽然是java，不过其实和c艹差不多： class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode root = new ListNode(0); // 工具性的头节点 ListNode cursor = root; int carry = 0; while(l1 != null || l2 != null || carry != 0) { int l1Val = l1 != null ? l1.val : 0; int l2Val = l2 != null ? l2.val : 0; int sumVal = l1Val + l2Val + carry; carry = sumVal / 10; ListNode sumNode = new ListNode(sumVal % 10); cursor.next = sumNode; cursor = sumNode; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } return root.next; } } 时间复杂度O(max(m,n))；空间复杂度O(1)； 感想：这道题看起来很简单，但如果在csp考试中遇到我就完蛋了。因为细节太多，debug比较难。 ","date":"2022-04-05","objectID":"/posts/leetcode2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"Leetcode2:两数相加——链表","uri":"/posts/leetcode2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ 这是一道可拓展性很高的题目 题解 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:0","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"中序遍历递归法 最朴素的想法就是先中序遍历得到递增序列，然后返回序列的第k-1个元素。 可是我们只需要第k个元素，不用把所有元素都遍历完再返回结果，那么如何优化呢？ 那就让它遍历到第k个元素时就终止递归，返回结果呗。但是递归不是想终止就终止的，它会有“惯性”～ 比如下面的代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def kthSmallest(self, root: Optional[TreeNode], k: int) -\u003e int: nums = [] def inorder(root): if (not root) or (len(nums)\u003ek): return if root.left: inorder(root.left) nums.append(root.val) if root.right: inorder(root.right) inorder(root) print(nums) return nums[k-1] 对于k=1，我们想让len(nums)\u003e1时就终止，实际上它一直运行到了nums=3。所以这种解法不够优雅。 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:1","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"中序遍历迭代法 中序遍历还有一个用栈实现的迭代法，其代码如下： stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() root = root.right 迭代法相比递归法的优势就是随时可以终止，只需加上两句就可以啦。下面是完整代码： class Solution: def kthSmallest(self, root: TreeNode, k: int) -\u003e int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right 时间复杂度：O(H+k)；空间复杂度：O(H) ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:2","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"记录子树的节点 这个方法适用于频繁地查找第k个最小的值。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-8o07/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:3","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/delete-node-in-a-bst/ 这道题完全可以当作一个知识点来对待。 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:1:0","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:0","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"思路 众所周知，一颗二叉搜索树的中序遍历是一个递增序列，这是二叉搜索树最基本的性质之一。 某个节点node的后继节点successor，就是中序遍历中仅次于node的后一个节点，是比node大的节点当中最小的节点。node的右子树中最左边那个节点就是successor。 某个节点node的前继节点predecessor，就是中序遍历中稍大于node的前一个节点，是比node小的节点当中最大的节点。node的左子树中最右边那个节点就是successor。 我们要维护这个性质，所以，当删除一个节点时，我们要拿这个节点的后继节点successor或者前继节点predecessor来替换它，然后递归的删除它的后继节点或者前继节点。比如删除[1,2,3,4,5]中的3，我们就拿4来替换它（或者拿2替换）。然后为了删除4，拿5来替换。5后面没有节点了，就直接删除5。 删除的时候可能有三种情况： 要删除节点是叶节点。直接删除就好了。 要删除的节点只有左子树，或者只有右子树。如果是左子树，就找前继节点替换；如果是右子树，就找后继节点替换。 要删除的节点既有左子树又有右子树。前继，后继都可以。一般我们选择后继。 上面的描述比较易于理解，但为了写代码方便，我们稍作改变： 要删除节点是叶节点。直接删除。 要删除的节点有右子树，就拿后继替换。 否则，拿左继替换。 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:1","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"代码 先看下ac的代码吧： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def get_successor(self, node): node = node.right while node.left: node = node.left return node.val def get_predecessor(self, node): node = node.left while node.right: node = node.right return node.val def deleteNode(self, root: Optional[TreeNode], key: int) -\u003e Optional[TreeNode]: if not root: return None if key \u003e root.val: root.right = self.deleteNode(root.right, key) elif key \u003c root.val: root.left = self.deleteNode(root.left, key) else: if (not root.left) and (not root.right): root = None elif root.right: root.val = self.get_successor(root) root.right = self.deleteNode(root.right, root.val) # 从root.right开始删除， # 如果从当前root删除，会死循环 else: root.val = self.get_predecessor(root) root.left = self.deleteNode(root.left, root.val) return root 为什么非要优先找后继节点呢？其实你优先找前继节点也可以，把这段代码改成这样： elif root.left: root.val = self.get_predecessor(root) root.left = self.deleteNode(root.left, root.val) else: root.val = self.get_successor(root) root.right = self.deleteNode(root.right, root.val) 为什么非要写成root.left = xxx，root.right = xxx呢？ 我把root.right = self.deleteNode(root.right, key)改成self.deleteNode(root.right, key)； 以及后面三处的赋值语句都改成了直接递归，结果只和正确答案差了一点，就是在递归的末端的叶子节点当中root=None没有生效。也就是说叶子节点没有成功删除。 我猜想可能是因为python的引用传递有关，这条赋值语句修改的只是形参而不是实参，所以无效！ 总之递归的代码好难写qwq，孩子根本想不到… ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:2","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/jump-game/ ","date":"2022-04-01","objectID":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode55:跳跃游戏——贪心","uri":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 所谓贪心算法，我个人浅薄的理解就是每一步找局部最优解，最终找到整体最优解。 那么这道题可以有这样的思路：从前往后遍历nums的元素，实时维护最远可以到达的位置 far。 对于当前遍历的位置i，先判断i\u003c=far，再有far = max(far, i+nums[i]) 直到far\u003e=len(nums)，则返回True，否则返回False。 代码： class Solution: def canJump(self, nums: List[int]) -\u003e bool: far = nums[0] size = len(nums) for i in range(size): if i \u003e far: return False far = max(far, nums[i]+i) if far \u003e= size-1: return True return False ps:因为前面做了几题递归，所以本来想用递归做，尝试一下代码不太会写，但我觉得思路上应该是行得通的。看来我的技术还有很大的提升空间呀！ ","date":"2022-04-01","objectID":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode55:跳跃游戏——贪心","uri":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/house-robber/ ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 看官方题解吧，官方题解写的真好。 ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"感想 我是从去年CSP考试中知道动态规划这个概念的，当时考前自以为弄懂了（其实根本没弄懂），现在做了两三道题了，反而觉得又不懂了。动态规划是很灵活的算法，很多题目想不到可以用动态规划来解决。要多练习才能融会贯通。 ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/path-sum-ii/ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"dfs无回溯 我们用深度优先搜索，在搜索时把当前路径记录下来为nums。如果满足 sum(nums)==targetSum； 该节点是叶节点； 就记录下这个路径。搜索完成后，我们就能把所有满足条件的路径找出来了。 代码的总体框架就是一个深度优先搜索，在这个框架的基础上修改使其符合题意。这是写代码的思路。下面是自己写的代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e List[List[int]]: if not root: return [] res = [] nums = [] def backtracking(nums, node): nums.append(node.val) # print(nums) if sum(nums)==targetSum and not node.left and not node.right: res.append(nums.copy()) if node.left: backtracking(nums.copy(), node.left) if node.right: backtracking(nums.copy(), node.right) backtracking(nums, root) return res 细节： 在往下递归是我传的参数不是nums的引用，而是复制了一个nums传给下一个函数。因此在做每一步递归时都有专属于它的一个nums，所以这段代码没有用到回溯。占用空间也比较大。 上面一点很重要！ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"dfs、回溯 如果把nums.copy()改成nums，然后在backtracking()的末尾加上nums.pop()，就是回溯了。 这样的话，传递的就是nums的引用，所有的递归过程用的都是同一个nums。在每次递归结束，往上回溯的时候通过pop()删去nums中最后一个元素。 class Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e List[List[int]]: if not root: return [] res = [] nums = [] def backtracking(nums, node): nums.append(node.val) # print(nums) if sum(nums)==targetSum and not node.left and not node.right: res.append(nums.copy()) if node.left: backtracking(nums, node.left) if node.right: backtracking(nums, node.right) nums.pop() backtracking(nums, root) return res 把这段代码跟Leetcode78题放在一起看，发现都是在合适的位置加一个pop()，这其实是回溯的重要特点。 时间和空间复杂度：不会算… ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:2","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"记录父节点、bfs 还有个很聪明的做法，就是用一个哈希表来每一个节点的父节点。这样，不用记录路径，只记录累加和。每找到一个满足条件的叶节点，就从该节点出发向父节点迭代，还原路径。 代码在官方题解～ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:3","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/subsets/ 一道初中数学题，但是是很难的编程题。 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:1:0","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:0","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"二进制枚举 ​ 集合a={5,2,9}中任何一个数有两种状态，在子集中或者不在子集中，分别用1和0来表示。所以我们可以进行如下编码： 二进制序列 子集 十进制数 000 {} 0 001 {9} 1 010 {2} 2 011 {2,9} 3 100 {5} 4 101 {5,9} 5 110 {5,2} 6 111 {5,2,9} 7 众所周知，如果一个集合的基数为n，那么它有2**n个子集。照上述列举就可以啦。 ps:这个方法真的很巧妙 代码也很值得学习： class Solution { public: vector\u003cint\u003e t; vector\u003cvector\u003cint\u003e\u003e ans; vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int mask = 0; mask \u003c (1 \u003c\u003c n); ++mask) { t.clear(); for (int i = 0; i \u003c n; ++i) { if (mask \u0026 (1 \u003c\u003c i)) { t.push_back(nums[i]); } } ans.push_back(t); } return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码讲解： 1«n表示将二进制数0000 0001 左移n位，如果n=2，则结果为 0000 0100，转化成十进制就是2的n次方，在这题中2的n次方是子集的总数，也是需要枚举的次数。 mask表示的就是咱的编码，是从0，1，2，…，到2的n次方，用的时候当然是用它的二进制形式。 里面的小循环是依次判断集合中的每个数是否为当前编码所需要的数。比如mask=110，i=1，那么(1\u003c\u003ci)=010，mask\u0026(1\u003c\u003ci) = 110\u0026010 = 1 = true所以第i个数是符合这个编码的数。这里用到了位运算。 时间复杂度：O(n x 2的n次方)，外循环2的n次方，内循环O(n)。 空间复杂度：O(n)，临时数组t ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:1","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"dfs、回溯 从这道题开始理解回溯！ 画一颗树，数根为[]，对于子集中的某个元素，左子树是添加这个元素，右子树是不加这个元素。构造这棵树如图（自己画的图有点丑）： 子集递归树 最后叶节点就是所需答案。 代码： class Solution { public: vector\u003cint\u003e t; vector\u003cvector\u003cint\u003e\u003e ans; void dfs(int cur, vector\u003cint\u003e\u0026 nums) { if (cur == nums.size()) { // 叶节点添加到ans ans.push_back(t); return; } t.push_back(nums[cur]); // 取这个元素 dfs(cur + 1, nums); t.pop_back(); // 不取这个元素 dfs(cur + 1, nums); } vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) { dfs(0, nums); return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 结合上面到图，深度优先搜索，先搜索最左侧的分支，最后到最右边。这个代码其实也是要看一会才能看懂…可能我就是菜。 时间复杂度和空间复杂度和二进制枚举一样。 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:2","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"回溯剪枝 上述递归过程可以看到很多节点是不必要的，剪枝就是通过增加一些条件，略过不必要的节点。有点难，不想研究了… ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:3","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["随笔杂记"],"content":"疫情期间的生活属实腐烂。老师不能来教室监督我们上课，食堂不能堂食，所以我天天呆在寝室，时间长了整个人都变得很低迷，学习的效率很低，每天干的最多的就是刷视频打游戏和睡觉。 今天早上没定闹钟，8:00上课，7:45我才起床。迷迷糊糊的还把时间看错了，以为是8:45，索性直接摆烂不去了。其实这个时候仍然有补救的机会，但是我上课的心已经死了。后来就有3个同学跟我说老师点我回答问题发现我不在，我心想你tm跟我说有什么用？看我笑话是不是？你就不能说我去做核酸了吗？一群靠不住的家伙，一大早就让我生气。 我的生活确实需要好好整理了：衣服堆了很多不洗，数据库实验还没做，竞赛的代码和文档也没写…疫情期间我拥有比往常更多的时间，但也浪费了这些时间。 今天算是给我敲响了警钟。我打开课表算一算，距离数据库原理、人工智能导论、民法概论结课只有三周时间了。复习工作（不如说是预习工作）现在开始刚好，我也该支棱起来了。 昨晚看了四叔的视频拥有的时间越多，人越苦恼，人如果能从低级的趣味中获得源源不断的快乐那是一种很潇洒的活法，但是我做不到，每次欢娱之后都会让我感到堕落、迷惘，那不是我真正的快乐。我只有鞭策自己然后看到自己胜利，才能获得短暂的属于我的真正的快乐，然后一次又一次重复这个过程。我在痛苦与快乐两边无限徘徊。 ","date":"2022-03-29","objectID":"/posts/%E4%BB%8A%E5%A4%A9%E9%80%83%E8%AF%BE%E8%BF%98%E8%A2%AB%E7%82%B9%E5%90%8D%E4%BA%86qwq/:0:0","tags":null,"title":"今天逃课还被点名了qwq","uri":"/posts/%E4%BB%8A%E5%A4%A9%E9%80%83%E8%AF%BE%E8%BF%98%E8%A2%AB%E7%82%B9%E5%90%8D%E4%BA%86qwq/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/ 做过102题后这题可以轻松做出来 ","date":"2022-03-27","objectID":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"Leetcode103:二叉树的锯齿形层序遍历","uri":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 复习一下[102. 二叉树的层序遍历]： 首先根节点入队 当队列不为空： 求队列长度s 依次从队列中取s个元素拓展，然后进入下一次迭代 得到层序遍历结果后，把奇数层reverse一下，就能ac了 代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def zigzagLevelOrder(self, root: TreeNode) -\u003e List[List[int]]: res = [] if not root: return res queue = [root] while len(queue): inner = [] for i in range(len(queue)): node = queue.pop() inner.append(node.val) if node.left: queue.insert(0,node.left) if node.right: queue.insert(0,node.right) res.append(inner.copy()) for i in range(len(res)): if i%2: res[i].reverse() return res 其实这题想让我们用一种数据结构deque双端队列。对于偶数层的节点，从后端插入元素；对于奇数层的节点，从前端插入元素。 我个人觉得并不比朴素的方法优秀很多，所以就不深入研究了哈哈。（其实是懒 ","date":"2022-03-27","objectID":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"Leetcode103:二叉树的锯齿形层序遍历","uri":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 上数据结构这门课时研究过这个问题，思路很快就有，难在debug ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:0","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"递归法 众所周知，只有前序遍历或中序遍历的结果是推演不出原树的。但是前序遍历+中序遍历可以推演出来。因为它们包含的信息特征不同，可以互补。 前序遍历得到的结果形式可以表示为这样：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ] 中序遍历得到的结果形式可以表示为这样：[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ] 所以说，由前序遍历数组的第一个元素可以确定根节点，然后在中序遍历中找到根节点的位置，这个位置左边是左子树，右边是右子树。递归的这么推演下去，就能把整颗树构造出来啦。 举个例子吧：比如preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]。那么首先确定的根节点是preorder[0]，即为3。然后把inorder劈成两半，一半是3左边的left_inorder=[9]，另一半是3右边的right_inorder=[15,20,7]。再把preorder劈成两半，left_preorder=[9]和right_preorder=[20,15,7]。 分别把left_preorder和left_inorder作为参数向左构造子树，把right_preorder和right_inorder作为参数向右构造子树。递归下去。 因为python的数组切片比较好用，所以这题就用了python： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def bt(preorder, inorder, node): node.val = preorder[0] left_inorder = inorder[0:inorder.index(preorder[0])] left_preorder = preorder[1:len(left_inorder)+1] right_inorder = inorder[inorder.index(preorder[0])+1:] right_preorder = preorder[len(left_inorder)+1:] if len(left_preorder)==1: node.left = TreeNode(left_preorder[0],None,None) elif len(left_preorder)==0: node.left = None else: node.left = TreeNode() bt(left_preorder,left_inorder,node.left) if len(right_preorder)==1: node.right = TreeNode(right_preorder[0],None,None) elif len(right_preorder)==0: node.right = None else: node.right = TreeNode() bt(right_preorder,right_inorder,node.right) root = TreeNode() bt(preorder,inorder,root) return root 细节 先确定left_inorder，因为left_inorder和left_preorder的长度应该相同，所以由它的长度可以确定left_preorder。right_inorder和right_preorder同理。 如果order数组为的长度为1，说明下一个节点是叶节点，后面就不用继续构造下去了。 如果order数组为的长度为0，即为[]，说明当前节点是叶节点，直接令下一个节点为None。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:1","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"改进 left_inorder = inorder[0:inorder.index(preorder[0])] right_inorder = inorder[inorder.index(preorder[0])+1:] 这两段代码在preorder中搜索根节点要花费很多时间，我们在一开始就创建一个哈希表储存每个数的索引，这样搜索时间就是O(1)了。 另外官方题解并没有把数组切片，而是传了指针的位置。 官方题解做法python： class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int): if preorder_left \u003e preorder_right: return None # 前序遍历中的第一个节点就是根节点 preorder_root = preorder_left # 在中序遍历中定位根节点 inorder_root = index[preorder[preorder_root]] # 先把根节点建立出来 root = TreeNode(preorder[preorder_root]) # 得到左子树中的节点数目 size_left_subtree = inorder_root - inorder_left # 递归地构造左子树，并连接到根节点 # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1) # 递归地构造右子树，并连接到根节点 # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right) return root n = len(preorder) # 构造哈希映射，帮助我们快速定位根节点 index = {element: i for i, element in enumerate(inorder)} return myBuildTree(0, n - 1, 0, n - 1) 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 官方题解的c++代码，学习一下： class Solution { private: unordered_map\u003cint, int\u003e index; public: TreeNode* myBuildTree(const vector\u003cint\u003e\u0026 preorder, const vector\u003cint\u003e\u0026 inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) { if (preorder_left \u003e preorder_right) { return nullptr; } // 前序遍历中的第一个节点就是根节点 int preorder_root = preorder_left; // 在中序遍历中定位根节点 int inorder_root = index[preorder[preorder_root]]; // 先把根节点建立出来 TreeNode* root = new TreeNode(preorder[preorder_root]); // 得到左子树中的节点数目 int size_left_subtree = inorder_root - inorder_left; // 递归地构造左子树，并连接到根节点 // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root-\u003eleft = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1); // 递归地构造右子树，并连接到根节点 // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root-\u003eright = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right); return root; } TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { int n = preorder.size(); // 构造哈希映射，帮助我们快速定位根节点 for (int i = 0; i \u003c n; ++i) { index[inorder[i]] = i; } return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1); } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:2","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"感想 解决树的问题，代码复杂度明显要高一点。以后我会更多使用较为熟悉方便的python而不是c++。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:3","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"题目 从今天开始多做一点关于数据结构“树”的题目。 https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:0","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"知识点：二叉搜索树 定义很简单： 若其左子树存在，则其左子树中每个节点的值都不大于该节点值； 若其右子树存在，则其右子树中每个节点的值都不小于该节点值。 性质： 二叉搜索树中序遍历的结果是一个递增序列 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:1","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"递归法构造二叉搜索树 本题要求构造一棵平衡的二叉搜索树，所以我们要尽可能把数值大小处于中间的元素放在根节点。假设有一段从i到j的序列，如果序列的长度是奇数，根节点就是中间那个数，也就是第(i+j)/2个数；如果数组的长度是偶数，那也无妨，我们把中间偏左的元素作为根节点，仍然是第(i+j)/2个数（整除） 。然后把中间数左边的序列按照同样的方法构造成左子树，右边的序列构造成右子树，递归的这么构造下去即可。 比如nums = [-10,-3,0,5,9]，先选择0作为根节点，然后0左边的序列[-10,-3]构成左子树，0右边的序列[5,9]构成右子树。 递归这种东西，不会的时候觉得很难，会了之后就不觉得难了。请看代码： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) { return helper(nums, 0, nums.size()-1); } TreeNode* helper(vector\u003cint\u003e\u0026 nums, int left, int right){ // 递归的终止条件 if(left \u003e right){ return nullptr; } // 选择中间或中间左边的数为根节点 int mid = (left+right)/2; TreeNode* root = new TreeNode(nums[mid]); root-\u003eleft = helper(nums, left, mid-1); root-\u003eright = helper(nums, mid+1, right); return root; } }; 细节： 递归终止的条件是left \u003e right，此时已经没有序列可以构成子树了，所以子节点为nullptr。 另外，不一定非要把中间偏左的元素作为根节点，选择中间偏右的元素也是可以的。 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:2","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/max-area-of-island/ leetcode的中等难度题对于我这种弱鸡来说确实花一点时间才能做出来。（即使是看了答案）和简单难度题相比，它的难点在于代码要注意很多细节。 ","date":"2022-03-24","objectID":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode695:岛屿的最大面积——中等难度的搜索算法","uri":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 这道题相较于Leetcode994:腐烂的橘子，有哪些不一样呢？ 994题给了你几个源点，而这题你需要从每个连通图里自己选择一个源点，才能进行搜索。 994题要统计的是轮数，而这题在搜索时你需要统计节点总共的数量。 解决方案： 初始时遍历整个图，一旦遇到岛屿就开始做搜索。为了避免重复搜索，可以把已搜索节点标为0。 带有返回值的递归。把整个递归过程看成一颗树，那么叶节点返回应该为1，其他节点返回应该是1+所有子节点。 上面这个图是我随手画的，只是便于理解，跟这个测试案例没啥关系😂。 上代码： class Solution { public: int get_area(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int i,int j){ if(i\u003c0 || i\u003egrid.size()-1 || j\u003c0 || j\u003egrid[0].size()-1 || grid[i][j]==0){ return 0; } grid[i][j] = 0; int ans = 1; vector\u003cint\u003e di = {0,0,1,-1}; vector\u003cint\u003e dj = {1,-1,0,0}; for(int x=0;x\u003c4;x++){ int next_i = i+di[x]; int next_j = j+dj[x]; ans += get_area(grid, next_i, next_j); } return ans; } int maxAreaOfIsland(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int maxarea = 0; for(int i=0;i\u003cgrid.size();i++){ for(int j=0;j\u003cgrid[0].size();j++){ if(grid[i][j] == 1){ int area = get_area(grid,i,j); if(maxarea \u003c area){ maxarea = area; } } } } return maxarea; } }; 细节： 搜索一个节点的时候先判断传入的坐标是否越界，如果越界了，或者所搜索的节点是0，直接return 0;因为只有1才有必要进行下一步操作。 ans这个变量就很关键了，先赋初值为0，再累加。结合上面的图思考。 di和dj这两个数组的定义就是节省了代码，上一道搜索算法的题目我也是这样写的。 ","date":"2022-03-24","objectID":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode695:岛屿的最大面积——中等难度的搜索算法","uri":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/squares-of-a-sorted-array/ ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"先平方再排序 class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { for(int i=0;i\u003cnums.size();i++){ nums[i] = nums[i]*nums[i]; } sort(nums.begin(),nums.end()); return nums; } }; 没啥好说的，打败40%的用户😂 ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"双指针 不难发现，一个一般的nums数组前面是负数后面是正数，nums数组平方后的最大值一是第一个元素或最后一个元素。所以在第一位和最后一位分别放两个指针i和j。 判断if nums[i]*nums[i] \u003e nums[j]*nums[j]，则把nums[i]*nums[i]放到res数组最后一位，否则把nums[j]*nums[j]放到最后一位。然后往前移动i，或者往后移动j。 这里有个动画：977.有序数组的平方.gif 代码： class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { int i = 0; int j = nums.size()-1; int k = j; vector\u003cint\u003e res(nums.size()); while(i\u003c=j){ if(nums[i]*nums[i] \u003c= nums[j]*nums[j]){ res[k--] = nums[j]*nums[j]; j--; }else{ res[k--] = nums[i]*nums[i]; i++; } } return res; } }; 细节： 因为可能i和j所指的元素相等，所以判断里要加个等于 while循环停止的条件，可以是i\u003c=j，或许也可以是k\u003e=0 ? ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:2","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/rotting-oranges/ 这道题就接着733题做刚刚好。正好介于有点思路但又写不出来中间，属于够一够脚尖才能实现的目标。 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:1:0","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:0","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"解题思路 这道题很明显要使用广度优先搜索，搜索的目标是每个腐烂橘子周围的新鲜橘子。相较于733题图像渲染来说，这道题由一个搜索源点变成了可能有多个源点。而且你得一轮一轮去搜索，并统计出搜索的轮数。 如果只用一个队列的话，难以区分队列中的烂橘子是在哪一轮烂掉的。所以本菜鸡突发奇想，用两个队列交替push。例如：第一轮把烂橘子push给que队列，第二轮push给newque队列，清空que队列，第三轮再push给que队列…以此类推。 官方题解只用了一个队列，它并不是在搜索时区分第几轮的。而是使用了一个dis[][]数组，记录了每一个橘子相较于上一个橘子腐烂时间+1。也非常巧妙。 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:1","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"代码 class Solution { public: int orangesRotting(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { vector\u003cint\u003e dx = {-1, 1, 0, 0}; vector\u003cint\u003e dy = {0, 0, -1, 1}; queue\u003cpair\u003cint,int\u003e\u003e que; queue\u003cpair\u003cint,int\u003e\u003e newque; // 定义了两个队列 int maxrow = grid.size(); int maxcol = grid[0].size(); int fresh = 0; // 新鲜橘子 // 先把坏橘子入队 for(int i=0; i\u003cmaxrow; i++){ for(int j=0;j\u003cmaxcol; j++){ if(grid[i][j] == 2){ que.emplace(i,j); }else if(grid[i][j] == 1){ fresh += 1; } } } newque = que; int minute = 0; // 一轮一轮地搜索腐烂橘子四周的新鲜橘子 while(!newque.empty()){ minute += 1; que = newque; newque = queue\u003cpair\u003cint,int\u003e\u003e(); // 清空 while(!que.empty()){ pair\u003cint,int\u003e rot = que.front();que.pop(); for(int i=0;i\u003c4;i++){ int x = rot.first+dx[i]; int y = rot.second+dy[i]; if(x\u003e=0 \u0026\u0026 x\u003cmaxrow \u0026\u0026 y\u003e=0 \u0026\u0026 y\u003cmaxcol \u0026\u0026 grid[x][y]==1){ grid[x][y] = 2; fresh -= 1; newque.emplace(x,y); } } } } if(fresh){return -1;} // 检查一下还有没有腐烂橘子 return max(0,minute-1); } }; 细节： 最开始把坏橘子找出来的同时顺便可以把新鲜橘子的总数找出来。在搜索时顺便统计一下坏掉橘子的数量，相减后就能知道几轮下来还有没有新鲜的橘子了。 我这样写代码把最初坏的橘子也算上消耗了一分钟时间，等于多算了一分钟，最后要把minute-1。但由于minute初值设置为0，所以可能会有-1的情况，此时取0就可。（我现在写题解的时候突然发现这个-1貌似没影响qwq） 看了下其他人的题解没有用我这种双队列方法的，哈哈，还特意发了个题解显摆一下，作者竟我自己😂 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:2","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/flood-fill/ 美好的一天从一道简单题开始～ ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 理解题意后，发现这不就是windows自带画图工具里的油漆桶吗？ ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"深度优先搜索 众所周知，深度优先搜索可以用栈实现，而递归本质上就是栈。所以直接上递归代码： class Solution { public: void fill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int currcolor, int newColor, int sr, int sc){ image[sr][sc] = newColor; if(sr\u003e0 \u0026\u0026 image[sr-1][sc]==currcolor){ fill(image, currcolor, newColor, sr-1, sc); } if(sr\u003cimage.size()-1 \u0026\u0026 image[sr+1][sc]==currcolor){ fill(image, currcolor, newColor, sr+1, sc); } if(sc\u003e0 \u0026\u0026 image[sr][sc-1]==currcolor){ fill(image, currcolor, newColor, sr, sc-1); } if(sc\u003cimage[0].size()-1 \u0026\u0026 image[sr][sc+1]==currcolor){ fill(image, currcolor, newColor, sr, sc+1); } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currcolor = image[sr][sc]; fill(image, currcolor, newColor, sr, sc); return image; } }; 五分钟敲完，提交，嘿嘿，有趣的题目～ 等等，咋提示栈溢出了呢？ 看了下测试用例。嗷嗷，原来有一个情况没考虑到： 当所要修改的颜色和它本身的颜色一样时，这个代码会无穷无尽的拓展下去。好家伙，原来栈溢出就是这么回事呀！ 所以我加了一个判断： class Solution { public: void fill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int currcolor, int newColor, int sr, int sc){ if(image[sr][sc]==newColor){ // 在这里加了一个判断，如果newcolor等于现有颜色，直接退出。 return; }else{ image[sr][sc] = newColor; } if(sr\u003e0 \u0026\u0026 image[sr-1][sc]==currcolor){ fill(image, currcolor, newColor, sr-1, sc); } if(sr\u003cimage.size()-1 \u0026\u0026 image[sr+1][sc]==currcolor){ fill(image, currcolor, newColor, sr+1, sc); } if(sc\u003e0 \u0026\u0026 image[sr][sc-1]==currcolor){ fill(image, currcolor, newColor, sr, sc-1); } if(sc\u003cimage[0].size()-1 \u0026\u0026 image[sr][sc+1]==currcolor){ fill(image, currcolor, newColor, sr, sc+1); } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currcolor = image[sr][sc]; fill(image, currcolor, newColor, sr, sc); return image; } }; 官方题解的代码跟我的代码思路一样，但它的要更简洁一点。值得学习！： class Solution { public: const int dx[4] = {1, 0, 0, -1}; const int dy[4] = {0, 1, -1, 0}; void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int x, int y, int color, int newColor) { if (image[x][y] == color) { image[x][y] = newColor; for (int i = 0; i \u003c 4; i++) { int mx = x + dx[i], my = y + dy[i]; if (mx \u003e= 0 \u0026\u0026 mx \u003c image.size() \u0026\u0026 my \u003e= 0 \u0026\u0026 my \u003c image[0].size()) { dfs(image, mx, my, color, newColor); } } } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currColor = image[sr][sc]; if (currColor != newColor) { dfs(image, sr, sc, currColor, newColor); } return image; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度O(m*n)，最坏需要遍历所有方格。 空间复杂度O(m*n)，栈的空间开销蛮大。 ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"广度优先搜索 众所周知，实现广度优先搜索需要用到队列。 懒得写了，看一看官方题解： class Solution { public: const int dx[4] = {1, 0, 0, -1}; const int dy[4] = {0, 1, -1, 0}; vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currColor = image[sr][sc]; if (currColor == newColor) return image; int n = image.size(), m = image[0].size(); queue\u003cpair\u003cint, int\u003e\u003e que; que.emplace(sr, sc); image[sr][sc] = newColor; while (!que.empty()) { int x = que.front().first, y = que.front().second; que.pop(); for (int i = 0; i \u003c 4; i++) { int mx = x + dx[i], my = y + dy[i]; if (mx \u003e= 0 \u0026\u0026 mx \u003c n \u0026\u0026 my \u003e= 0 \u0026\u0026 my \u003c m \u0026\u0026 image[mx][my] == currColor) { que.emplace(mx, my); image[mx][my] = newColor; } } } return image; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度分析同深度优先搜索。 别搞混了： 广度优先搜索 深度优先搜索 队列 栈 ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/non-overlapping-intervals/ 这题我竟然一年前做过，第二遍再做的时候一点印象都没有。 看了下提交记录，发现一年前做的时候代码还是自己敲上去的，一年之后咋就什么都不会了呢？难道我的算法水平还不如一年前？？？ ","date":"2022-03-20","objectID":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode435:重叠区间——动态规划、贪心","uri":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 做的时候思路跑偏了，总想着把有重叠的区间找出来剔除掉。换一个思路，可以去寻找不重叠的最大区间数n，然后拿all-n就是最小重叠区间的数量。 贪心的解法其实不难理解，只是不太容易想到（因为我是菜鸡qwq）： 思路：可以把这题的情境想象成一个预定会议问题，区间的左右两端就是会议的开始时间和结束时间，要求会议时间不能重叠，寻找一个能安排最多会议次数的序列。那么我们先找到最先结束的那个会议，放在最开头。然后从剩下的会议里找到最先结束的，同时开始时间不早于第一个会议结束时间的那个会议，放在第二个。以此类推…就完成啦。 实际做题的时候有个技巧，就是可以先按照会议结束的时间（即区间右端点）进行排序。这样代码会好写很多。 上不是自己写的代码： class Solution { public: int eraseOverlapIntervals(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) { if (intervals.empty()) { return 0; } sort(intervals.begin(), intervals.end(), [](const auto\u0026 u, const auto\u0026 v) { return u[1] \u003c v[1]; }); int n = intervals.size(); int right = intervals[0][1]; int ans = 1; for (int i = 1; i \u003c n; ++i) { if (intervals[i][0] \u003e= right) { ++ans; right = intervals[i][1]; } } return n - ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度分析：排序nlogn+遍历n，因为nlogn的幂次高，所以O(nlogn+n)=O(nlogn)，故时间复杂度O(nlogn) 空间复杂度：O(logn)，排序所需要的栈空间 还有一种动态规划的方法，是按照左端点进行排序，然后用f[i]表示「以区间 i 为最后一个区间，可以选出的区间数量的最大值」来进行状态转移。 代码比贪心复杂，时间复杂度也大一点，懒得去研究了。 ","date":"2022-03-20","objectID":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode435:重叠区间——动态规划、贪心","uri":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/search-a-2d-matrix-ii/ ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:1:0","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:0","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"法一：逐行二分 没啥好说的，代码可以参考一下 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { for (const auto\u0026 row: matrix) { auto it = lower_bound(row.begin(), row.end(), target); if (it != row.end() \u0026\u0026 *it == target) { return true; } } return false; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-so-9hcx/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 对一行使用二分查找时间复杂度O(logm)，对n行使用二分查找时间复杂度O(nlogm)。 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:1","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"法二：巧妙的利用性质 观察矩阵最右上角的元素： 它是所在行最大的元素 它是所在列最小的元素 这就有点像二分法了。对于一个目标数target，如果target\u003cmatrix[row][col]，则target一定不在第col列。如果target\u003ematrix[row][col]，则它一定不在第row行。 所以我们只要判断target和matrix[row][col]的大小，就能排除某一行或某一列的所有元素。 上代码： class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int row = 0; int col = matrix[0].size()-1; while(row\u003cmatrix.size() \u0026\u0026 col\u003e=0){ if(target \u003c matrix[row][col]){ col--; }else if(target \u003e matrix[row][col]){ row++; }else{ return true; } } return false; } }; 最多把所有的行和列都排除一遍，时间复杂度只有O(m+n)。这个方法很巧妙！ 其实关注左下角的元素也是一样的： 它是所在行最小的元素 它是所在列最大的元素 明白了就不觉得难了。 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:2","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["技能分享"],"content":"roboflow roboflow是一个支持数据集在线打标，在线导出的网站。除此之外它还支持可多人合作、数据增强，版本控制等功能。是我用过最好用的数据集处理平台。 网址：https://roboflow.com/ 提示： 可以免费使用 需要挂代理 套餐一定要选public，选择private后导出数据集会很麻烦 ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:1:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"colab 谷歌提供的计算平台 优点： 提供免费的tesla k80算力 可以很方便的上传下载文件，还可挂载谷歌云盘 用的人多，环境配置起来方便 网速不错，git clone,pip install都麻利的 ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:2:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"训练yolov5模型 完全在云端操作，你只需要一个浏览器就行了。 在roboflow上标好数据，点export导出，不用下载，只要复制这段代码就可以了 打开https://colab.research.google.com/github/roboflow-ai/yolov5-custom-training-tutorial/blob/main/yolov5-custom-training.ipynb 替换你的下载代码，点运行全部单元格 然后你就什么都不用管了，这个脚本会帮你训练、评估效果，最后把权重下载下来。 是不是非常优雅～ ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:3:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["书影记录"],"content":"邓小平时代 所有中国人都知道，1949年建国时中国是一个落后封闭的社会主义国家（和现在的朝鲜差不多）。但是在80年代，社会主义市场经济取代了计划经济，对外封闭变成了改革开放。90年代，中国经济一路起飞，国际地位迅速提高。直到现在，中国已经成为世界最强的国家之一。 中国是如何崛起的？在大一时，孙运雷老师向我们提出过这个问题，让我们阅读一些书籍去寻找答案。当时我阅读了陈经的《中国的官办经济》，对这个问题已经有初步认识。现在再读傅高义的《邓小平时代》，算是进一步找到了答案。正如傅高义在序中所说： 我认为，要想了解今日之中国，很重要的一点是了解历史，特别是自 1978 年邓小平开始领导造就了当下中国的一系列进程之后的历史。 除此之外，作为一个中国人，作为一个充满好奇心年轻人，我们对自己的党，自己的国家都有许多疑问：毛泽东时代怎样进入到邓小平时代？我们国家曾经有哪些最高领导人？为什么有的领导人被称为领导核心，有的却不是？他们执政时发生了哪些事情？中国共产党执政时出现过哪些危机？为什么历史教材上很少提到？大陆和台湾关系有哪些细节？国家与国家的交往是怎么样的？…如果你在境外网站检索这些问题，你会得到充满偏见的、有诬蔑性的答案。不妨读一读这本书，从一个外国人的视角，真实客观的解读现代中国。 《邓小平时代》 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:1:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"傅高义 傅高义是土生土长的美国人，30岁时在哈佛大学开始研究中国，同时精通中文和日文，是著名的中国和日本问题专家，被称为“中国先生”。1979年出版《日本第一》，正值日本经济崛起，使他名声大噪。但很快日本经济泡沫破灭，开始衰败。2000年他又出版了《日本仍是第一吗？》，颇具争议。 2011年在美国出版《邓小平时代》，引起广泛关注。2013年此书在中国出版，首印50万册发行一空。 傅高义老先生德高望重，是倡导美国应以更理性和平衡方式思考中国的主要支持者。是中国的知己而不是中国的敌人。他于2020年在美国去世，享年90岁。 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:2:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"版本 《邓小平时代》是一本面向大众的通俗读物。书很厚，大陆版全书700多页，定价88元，有点小贵。 即使大陆版相比港版略有删节，但大陆版的内容还是让人直呼大胆，能够在中国大陆出版我觉得也是一种奇迹。 大陆版可以在图书馆借到，港版可以下载到手机上看。我粗略的比较了一下大陆版和港版，只有第20章：北京删节较多，其它基本无异。 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:3:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"邓小平——改革开放的总设计师 邓小平有一句经典的话：“摸着石头过河。“ 最初实行改革开放时，他也没有想好伟大宏图。他是实干家，不搞花架子，讲话通俗易懂，集中注意力解决实际问题。与其说他是改革开放的总设计师，不如说是改革开放的总经理，带着北京的领导班子，带领全国人民，披荆斩棘，野蛮生长，开拓出自己的一条道路。 邓小平上台时，中国是一个“烂摊子”，国家仍因“文革”的混乱而步履蹒跚。工业、农业、教育、社会制度、科技、经济、外交…中国全方位落后。但是邓小平是一位出色的改革家，他和其它领导人找到了一条富国强民的道路，提出了改革开放，引领了中国的根本转型。书中称之为自两千多年前汉帝国形成以来，中国最根本的变化。 借鉴书中观点，我把邓小平的伟大贡献概括如下： 改革开放使中国开放拥抱世界，使中国富起来了，国际地位大大提高，从“亚洲文明的中心”走向“世界大国”。同时国内的开放程度也大大提高，中国更像一个整体了。 邓小平维护了党的集体领导，化解了像东欧剧变、苏联解体等对中国的冲击，拯救国家于危难之中。 促使教育、科技业的发展，如恢复高考，善待科技工作者，向国外派遣大量留学生，这是他刚上台就在做的事情。为未来培养了人才。 促进外交，与日、美等多国建立友好关系，结束了毛时代的外交僵局。帮助中国实现现代化。赢得和平发展的环境。 但也留下了许多问题： 全民社会保障和公共医疗欠佳。 腐败问题，这是高速发展的社会不可避免的。 法治建设。 环境问题等。 这些问题都受到了继任的领导人的重视，正在一点一点解决。生长在这个时代我感到非常幸运，看到自己的国家由飞速发展，变为精细提高人民的生活水平。现在在习近平总书记领导下，中国已经成长的非常健壮了，希望在未来能创造出更多奇迹！ ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:4:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"梳理中国现代史 在《如何阅读一本书》中提到了一种阅读方法：主题阅读。简单来说，就是如果你对一类问题很感兴趣，那就针对这类问题去找几本书阅读。这种阅读的效率被认为是最高的。中国的现代史（1949年新中国成立至今这一段历史）我们好像都了解的不多，也比较感兴趣。读了几本书后，对中国现代史作一个简单梳理： 1949年：毛主席在全国人民的热烈欢呼下在北京天安门宣布新中国成立。 未完待续 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:5:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/assign-cookies/ ","date":"2022-03-18","objectID":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode455:分发饼干——排序、贪心","uri":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 为了满足更多的孩子，应该把孩子的胃口从小到大排序，尽量先满足胃口小的孩子。（因为如果胃口小的孩子都满足不了，肯定也满足不了胃口大的孩子） 然后对于每个胃口小的孩子，找到一个能刚好满足他的饼干。 思路很简单，我是个菜鸡，看了题解才想出来qwq 这是我第一次写的代码： class Solution { public: int findContentChildren(vector\u003cint\u003e\u0026 g, vector\u003cint\u003e\u0026 s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int cnt = 0; for(int i=0;i\u003cg.size();i++){ for(int j=0;j\u003cs.size();j++){ if(s[j]\u003e=g[i]){ cnt+=1; s[j]=0; break; } } } return cnt; } }; i和j分别是孩子和饼干的指针，由于j指针有回溯，所以效率很低。776ms 改进一下： class Solution { public: int findContentChildren(vector\u003cint\u003e\u0026 g, vector\u003cint\u003e\u0026 s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int cnt = 0; int j = 0; for(int i=0;i\u003cg.size();i++){ while(j\u003cs.size()){ if(s[j]\u003e=g[i]){ cnt++; s[j]=0; break; }else{ j++; } } } return cnt; } }; 如果饼干不能满足小胃口的孩子，那么大胃口的孩子肯定也满足不了。不让j指针回溯，效率一下子提上来了，20ms 时间复杂度：O(mlogm+nlogn)主要是排序的时间复杂度。 空间复杂度：O(logm+logn)主要是排序的空间复杂度。 ","date":"2022-03-18","objectID":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode455:分发饼干——排序、贪心","uri":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ ","date":"2022-03-16","objectID":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode160:相交链表——哈希、双指针","uri":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 法一：哈希表 先把一个链表放到哈希表里，再遍历另一个链表。 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { unordered_set\u003cListNode *\u003e visited; ListNode *temp = headA; while (temp != nullptr) { visited.insert(temp); temp = temp-\u003enext; } temp = headB; while (temp != nullptr) { if (visited.count(temp)) { return temp; } temp = temp-\u003enext; } return nullptr; } }; 时间复杂度O(m+n) 空间复杂度O(m) 法二：双指针 这个方法还是很巧妙的！ 两个指针分别指向headA和headB，然后同时同速向后移动，A指针到结尾了就转移到headB，B指针到结尾了就转移到headA。 如果两个链表相交，那一定可以在第二次遍历时指向同一个节点。如果不相交，一定会同时指向nullptr。 详情请看官方题解的证明，不难理解。 自己写的垃圾代码： class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA; ListNode *B = headB; while(headA!=nullptr || headB!=nullptr){ if(A==B){ return A; } if(A==nullptr){ A = headB; }else{ A = A-\u003enext; } if(B==nullptr){ B = headA; }else{ B = B-\u003enext; } } return nullptr; } }; 时间复杂度O(m+n) 空间复杂度O(1) 看到一条评论： 错的人就算走过了对方的路也还是会错过😔 这题我希望大家都返回true 蚌埠住了兄弟们，刷个算法题都能emo。 ","date":"2022-03-16","objectID":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode160:相交链表——哈希、双指针","uri":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["技能分享"],"content":"为什么安装sqlserver 上数据库系统概论需要用到数据库，按道理来说应该使用开源的mysql，但老师说因为学校用的是sqlserver，我们考试也用这个，所以我也就得用。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:1:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法一：云数据库（❌ 在mac上直接安装微软的产品，想都别想～所以我首先把注意力放在了云上。众所周知，像阿里云、腾讯云等服务商经常有云数据库优惠活动，购买一个1核1G的mysql数据库一年的时间也用不到10元，性价比拉满。 但是sqlserver数据库贵的要死啊，可能是因为比较小众而且微软要从中赚授权费吧。 于是我又想到了微软自家不是有个云平台Azure吗，以前白嫖过他家的服务器，体验蛮不错。满怀期待登上去看，需要外币信用卡才能注册，对国内用户极不友好。 正当我灰心丧气打算关闭页面时，突然发现Azure有学生套餐！看了下介绍，好像福利挺多的，优惠时间也蛮长，在我的印象中国外这种大厂还是很大气的。然后我就兴高采烈的用学校邮箱注册了学生账户（不需要外币信用卡）。进去一看，哟吼～，产品还挺多，有一堆不认识的。我赶紧搞了一个sqlserver，过程也并不复杂，唯一的缺点是服务器只能选择在美国东部，裸连速度很慢。不过我有代理，供学习使用应该够了。 气人的是，过了两天微软给我发邮件，说我的学生账户可以使用的免费额度没了…白嫖失败。对于穷学生来说，这个法子行不通。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:2:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法二：在本地安装（❌ 我发现sqlserver可以使用docker安装。我对docker印象蛮好的，认为它可以解决大多环境问题。 我的本来想法是这个方案应该非常easy，两步就能搞定，第一步安装docker，第二步run个镜像就能用了。但是，在m1的mac上，docker已经不是原来的那个docker了。 安装docker desktop确实非常方便，只要在官网下载，然后点下一步就能装好，比windows方便多了（在win上你得先跑一个linux虚拟机）。 第二步拉取镜像，跑容器发现跑不起来，会报错，怀疑是m1芯片问题。 为了确认我不是个例，我还去dockerhub看了下，果然评论里都是说这个问题的。它就是不支持m1芯片。 从此之后，我再也不吹docker了，看来它并不能解决所有环境问题。 有人倒是成功了，先跑一个pd虚拟机，再在虚拟机里跑docker，搁这套娃呢？看来在本地安装是指望不上了。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:3:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法三：云服务器上使用docker（勉强✅ 不能在m1的mac上的docker里安装，在传统的linux上总可以安装吧？ 这个方案确实可行，但也遇到了小坑。 众所周知，便宜点云服务器有很多，10多块钱就能搞一个1核2G的linux云服务器。执行和法二相同的操作： sudo docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=密码\" -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2019-latest 没报错，看来要成功了？真是踏破铁鞋无觅处，得来全不费功夫呀，哈哈～ 然后再打docker ps -a，看下容器跑起来没有。结果发现没有，看来高兴早了qwq。 为什么呢，打docker logs 容器ID看下原因，他娘的，说内存至少要2000mb才能运行。 我的云服务器内存就是2G，实际使用时系统和其他服务会占用一些内存，所以留给sqlserver的内存肯定不足2G了。但我还是抱着侥幸心理，在docker启动容器的命令里分配了2000mb的内存，仍然不行，我试了阿里云，腾讯云的1核2G轻量化应用服务器，都是不行的。 组里面有个2核4G的腾讯云轻量化应用服务器，可以运行！但这服务器是组里的…算了，直接拿来用吧。 麻烦就是端口开不了，自己电脑的navicat连不上，只能ssh到服务器上用命令行工具。 哭了，折腾两节课也没能很好解决这个问题。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:4:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"总结 如果说windows能做100%的事情，那么M1 Mac 只能做80%。但是我还是会选择m1 mac，因为在它能做的事情范围之内，你能体验到极致的丝滑。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:5:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["刷题"],"content":"一件事情只有做了一段时间之后才能找到方向。前段时间随便找了一些题刷，开始逐渐了解数据结构和算法。最近在知乎上看到一篇文章，列举了400道数据结构入门题目，感觉找到了方向。 所以从今天开始进入新的刷题阶段。 题单在此：https://www.zhihu.com/question/399753856/answer/2311845630 不一定非要按照这个顺序把所有题目刷完，但是有了这个题单作指导，思路会清晰很多。 别的不多说了，总之坚持把这件事情做下去吧✊。 ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/reverse-linked-list/ ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 假设链表为 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e null 要把它改为 null \u003c- 1 \u003c- 2 \u003c- 3 \u003c- 4 伪代码： ListNode reverseList(ListNode head){ 前一个节点 = null; 当前节点 = head; while(当前节点不为空){ 当前节点.next = 上一个节点; 前一个节点 = 当前节点; 当前节点 = 下一个节点; } } 代码： class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:2:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 [15. 三数之和] 难度中等4464收藏分享切换为英文接收动态反馈 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示： 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 ","date":"2022-03-13","objectID":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/:1:0","tags":null,"title":"三数之和——双指针——好难","uri":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/"},{"categories":["刷题"],"content":"题解 参考官方题解 思路可以很快确定，难点在于精确调控指针。所以我调了三个小时的代码才通过…可能我单纯就是菜qwq 首先我们想到用三个循环暴力把这些三元组找出来，然后再对结果去重。（话说c++对二维向量去重我也不会呀qwq）那么有没有不需去重的办法呢？ 当然有了，且看如下伪代码： nums.sort() // 对nums排序,使得三元组(a,b,c)满足a\u003c=b\u003c=c for first = 0 .. n-1 // 只有和上一次枚举的元素不相同，我们才会进行枚举 if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then for third = second+1 .. n-1 if third == second+1 or nums[third] != nums[third-1] then // 判断是否有 a+b+c==0 check(first, second, third) 这样保证了两点： 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素，且不与上一个枚举到的元素重复。 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素，且不与上一个枚举到的元素重复。 不懂的话可以看看官方题解，再找一个数组，比如[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]在纸上画一画。 双指针 假设三元组为(a,b,c)。当a确定时，这里的双指针就是b和c，双指针用到了如下性质： 在三重枚举的过程中，当a确定时，b增大，c减小。c不用回溯。 我写不下去了…其实我理解的很烂 那直接上我的代码吧： class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(),nums.end()); // 排序 int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e res; int first,second,third; // 定义三个“指针” for(first=0;first\u003cn;first++){ if(first==0 || nums[first]!=nums[first-1]){ // 这里有个巧妙的地方， // 先判断first==0，如果成立，不用继续判断，数组不会越界 third = n-1; // 当first+1时，才回溯third for(second=first+1;second\u003cn;second++){ if(second==first+1 || nums[second]!=nums[second-1]){ while(second\u003cthird \u0026\u0026 nums[first]+nums[second]+nums[third]\u003e0){ third = third-1; } if (second == third) {// 指针不能重合 break; } if(nums[first]+nums[second]+nums[third]==0){ res.push_back({nums[first],nums[second],nums[third]}); } } } } } return res; } }; 感觉这个过程还蛮复杂的，可能过一段时间再看会清晰一点。 ","date":"2022-03-13","objectID":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/:2:0","tags":null,"title":"三数之和——双指针——好难","uri":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ [102. 二叉树的层序遍历] 难度中等1216收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:1:0","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"题解 这道题的技术点有两个，一是把树状结构转化成数组结构，这个在数据结构里学过，用队列就可以轻松实现。二是要把这个二叉树分层，对于我来说这是一个难点。 我自己的思路是先实现第一步，在一维数组vector\u003cint\u003e v里储存一棵完全二叉树，然后用函数get_n(int index)确定下标为index的节点所在的层数。最后组织成提交所用的格式。 然鹅，我调了两个小时代码只过了11/34 qwq。 代码不能白写，先贴上： // 错误代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int get_n(int index){ int n = 1; while(pow(2,n)-2 \u003c index){ n++; } return n; } vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { if(root==nullptr){ return {}; } vector\u003cint\u003e v; queue\u003cTreeNode*\u003e q; q.push(root); v.push_back(root-\u003eval); while(!q.empty()){ TreeNode* node = q.front(); q.pop(); if(node-\u003eleft){ q.push(node-\u003eleft); v.push_back((node-\u003eleft)-\u003eval); }else{ v.push_back(-1111); } if(node-\u003eright){ q.push(node-\u003eright); v.push_back((node-\u003eright)-\u003eval); }else{ v.push_back(-1111); } } int n=get_n(v.size()-1); //层数 for(int i=0;i\u003cv.size();i++){ cout \u003c\u003c v[i] \u003c\u003c \" \"; } vector\u003cvector\u003cint\u003e\u003e res(n-1); for(int i=0;i\u003cv.size()\u0026\u0026get_n(i)\u003cn;i++){ if(v[i]!=-1111){ res[get_n(i)-1].push_back(v[i]); } } return res; } }; ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:2:0","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"官方题解的骚操作 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 先看一种朴素的方法（虽然是“朴素”的方法，但也比我的方法要巧妙，它在进行广度优先搜索时就解决了层数的问题）： 然后针对这题，可以进行如下优化，概括来说就是每次拓展一层的节点（“拓展”这个词用的真好）： 数学证明，其实这个也很容易想通： 代码： class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector \u003cvector \u003cint\u003e\u003e ret; if (!root) { return ret; } queue \u003cTreeNode*\u003e q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector \u003cint\u003e ()); // 先往ret里压一个空vector for (int i = 1; i \u003c= currentLevelSize; ++i) { auto node = q.front(); q.pop(); // q.fron()取第一个元素，q.pop()删除第一个元素 ret.back().push_back(node-\u003eval); // ret.back()取到最后一个vector，再往里push_back if (node-\u003eleft) q.push(node-\u003eleft); if (node-\u003eright) q.push(node-\u003eright); } } return ret; } }; 复杂度分析 记树上所有节点的个数为 n。 时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。 空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。 这代码写的也很beautiful啊，真是太tm妙啦！ ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:2:1","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/pascals-triangle/ [118. 杨辉三角] 难度简单708收藏分享切换为英文接收动态反馈 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 提示: 1 \u003c= numRows \u003c= 30 ","date":"2022-03-10","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"杨辉三角——数组、动态规划","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 找规律，第i行第j个数等于第i-1行第j-1个数加第i-1行第j个数，即res[i][j]=res[i-1][j-1]+res[i][j]。 一开始我弄错一个变量，导致数组越界，找了半天都没找出来，我还以为是c++的问题，就换了python写，python的报错比较友好，终于让我发现了错误的地方。 所以python代码： class Solution: def generate(self, numRows: int) -\u003e List[List[int]]: res = [[] for i in range(0,numRows)] res[0].append(1) if numRows==1: return res; for i in range(1,numRows): for j in range(0,i+1): if j==0 or j==i: res[i].append(1) else: # print(i,res) res[i].append(res[i-1][j-1]+res[i-1][j]) return res c艹代码： class Solution { public: vector\u003cvector\u003cint\u003e\u003e generate(int numRows) { vector\u003cvector\u003cint\u003e\u003e res(numRows); res[0].push_back(1); if(numRows==1){ return res; } for(int i=1;i\u003cnumRows;i++){ for(int j=0;j\u003ci+1;j++){ if(j==0 || j==i){ res[i].push_back(1); } else{ res[i].push_back(res[i-1][j-1]+res[i-1][j]); } } } return res; } }; ","date":"2022-03-10","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"杨辉三角——数组、动态规划","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 本题目来自：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 121. 买卖股票的最佳时机 难度简单2177收藏分享切换为英文接收动态反馈 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 \u003c= prices.length \u003c= 105 0 \u003c= prices[i] \u003c= 104 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"暴力法 超时，不必多说。 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { int max = 0; for( int i=0;i\u003cprices.size()-2;i++){ for(int j=i+1;j\u003cprices.size()-1;j++){ if(prices[j]-prices[i]\u003emax){ max = prices[j]-prices[i]; } } } return max; } }; 时间复杂度O(n^2)，空间复杂度O(1) ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"动态规划 假设我们有穿越时空的能力，再假设我们决定在第i天卖出，那么只要知道在0~i天的最低价，再穿越回去购买股票，就能获得最大收益了。 创建一个dp[i]数组，表示在第i天卖出时的最低价。 然后再根据dp[i]数组，找到收益最大的那一天，即确定prices[i]-dp[i]的最大值。 //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i \u003c prices.length; i++) { dp[i] = (dp[i - 1] \u003c prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) \u003e max ? prices[i] - dp[i] : max; } return max; // 参考https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/930057 这个代码还可以进一步优化，因为我们只关注最大值，所以可以不用把所有数据都存到数组里。维护一个minprice和maxprofit变量即可。 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for(int price:prices){ minprice = min(price, minprice); maxprofit = max(maxprofit, price-minprice); } return maxprofit; } }; 这样只要遍历一遍数组，时间复杂度O(n)，空间复杂度O(1)。 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:2","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"其他小问题 1e9表示1*10^9。在算法题中常用来赋一个非常大的值。为什么不用1e10呢？因为int类型中1e10会溢出。 详情可以参考：http://t.csdn.cn/rItZr ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题","技能分享"],"content":"2022年我才搞懂这个！ ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:1:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"比较 传递方式 函数定义 函数调用 函数内对a修改的影响 值传递 fun(int a) fun(x) 外部x不变 指针传递 fun(int *a) fun(\u0026x) 外部x同步更改 引用传递 fun(int \u0026a) fun(x) 外部x同步更改 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:2:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"值传递 值传递是最常用的一种方式。它就是从函数外拷贝到函数内。 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:3:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"指针传递 指针传递跟值传递其实差不多，只是传递的内容从一个值换成了指针。定义函数的时候要写成fun(int *a)，函数内的a就是一个int类型指针要使用a对象的话就得写成*a。 在函数外如果定义一个int b=1，想把它传到函数里的话需要用到取地址符\u0026，像这样写fun(\u0026b)。 示例： #include \u003cstdio.h\u003e void swap(int *a, int *b){ printf(\"swap enter\\n\"); printf(\"a = %d, ptr = %p\\n\", *a, a); printf(\"b = %d, ptr = %p\\n\", *a, b); int tmp = *b; *b = *a; *a = tmp; printf(\"a = %d, ptr = %p\\n\", *a, a); printf(\"b = %d, ptr = %p\\n\", *b, b); printf(\"swap leave\\n\"); } int main() { int x = 1; int y = 2; printf(\"x = %d, ptr = %p\\n\", x, \u0026x); printf(\"y = %d, ptr = %p\\n\", y, \u0026y); swap(\u0026x, \u0026y); printf(\"x = %d, ptr = %p\\n\", x, \u0026x); printf(\"y = %d, ptr = %p\\n\", y, \u0026y); return 0; } 结果： x = 1, ptr = 000000000022FE4C y = 2, ptr = 000000000022FE48 swap enter a = 1, ptr = 000000000022FE4C b = 1, ptr = 000000000022FE48 a = 2, ptr = 000000000022FE4C b = 1, ptr = 000000000022FE48 swap leave x = 2, ptr = 000000000022FE4C y = 1, ptr = 000000000022FE48 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:4:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"引用传递 在定义的时候形参前要加一个\u0026，这个不是取地址符，而是一个记号。（这就是c语言贼tm绕人的地方qwq）比如int fun(int \u0026a)。 调用函数时参数前不需要加任何记号，比如int a=10，fun(a)。 在函数内使用的时候不用加任何东西，直接用即可，比如a=20。 函数内和函数外a的值会同步改变。 示例： class Solution { public: void preorder(TreeNode *root, vector\u003cint\u003e \u0026res){ //这里res前要加一个\u0026 if (root == nullptr){ return; } res.push_back(root-\u003eval); preorder(root-\u003eleft, res); // res可以直接访问到对象内容，且函数内外指向同一个对象 preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; //创建res对象 preorder(root, res); return res; } }; ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:5:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"参考资料 以上我自己的总结是非常简单的，仅能保证我在做题时看懂题解，但其实这里面还有很多细节没提到。学到现在终于能体会到当年为什么老师说c语言的指针很难了。 参考csdn文章：http://t.csdn.cn/suCK6 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:6:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题"],"content":"题目 前序遍历：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 中序遍历：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 后序遍历：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 树的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"前序遍历 前序遍历的顺序是：根 -\u003e 左 -\u003e 右。（这个顺序一开始还被我记错了qwq） 用递归的方式很简单： class Solution { public: void preorder(TreeNode *root, vector\u003cint\u003e \u0026res){ if (root == nullptr){ return; } res.push_back(root-\u003eval); preorder(root-\u003eleft, res); preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; preorder(root, res); return res; } }; 递归的本质是使用了栈。如果不想用递归，也可以显式地使用栈来做。但是看懂了递归后再看这种方法会觉得脑子疼。 ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:1","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"中序遍历 改一下输出顺序就可以啦。 inorder(node-\u003eleft, res); res.push_back(node-\u003eval); inorder(node-\u003eright, res); ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:2","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"后序遍历 postorder(node-\u003eleft, res); postorder(node-\u003eright, res); res.push_back(node-\u003eval); 话说今天是思美节诶，图书馆的女生打扮的都好漂亮呀～祝节日快乐！ ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:3","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ [350. 两个数组的交集 II] 难度简单670收藏分享切换为英文接收动态反馈 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 *进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ ","date":"2022-03-06","objectID":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"两个数组的交集——数组、哈希、双指针","uri":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 用hashmap解决。今天忙着训练模型，懒得写题解了。 class Solution { public: vector\u003cint\u003e intersect(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { if (nums1.size() \u003e nums2.size()) { return intersect(nums2, nums1); } unordered_map \u003cint, int\u003e m; for (int num : nums1) { ++m[num]; } vector\u003cint\u003e intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 回答一下进阶的那几个问题吧： 已经排好序的话，用双指针做比较好。 用小的数组产生hashmap比较好。 存在磁盘上，每次只能读一部分数据，就不能排序了，得用方法1. ","date":"2022-03-06","objectID":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"两个数组的交集——数组、哈希、双指针","uri":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 题目来自：https://leetcode-cn.com/problems/linked-list-cycle/ 141. 环形链表 难度简单1376收藏分享切换为英文接收动态反馈 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 \u003c= Node.val \u003c= 105 pos 为 -1 或者链表中的一个 有效索引 。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 虽然上学期学完了数据结构，还拿到了90+的成绩，但我一行代码都没有写过，只会纸上谈兵是不行的。 参考作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"方法一：哈希表 最容易想到的方法，就是遍历这个链表，如果发现某个节点曾经被遍历过了，那么这就是环形链表。判断某个节点是否被遍历过可以用hashset。 代码： class Solution { public: bool hasCycle(ListNode *head) { unordered_set\u003cListNode*\u003e seen; while (head != nullptr) { if (seen.count(head)) { return true; } seen.insert(head); head = head-\u003enext; } return false; } }; 这个代码我是写不出来的，只能先抄题解。有一点不明白的是，unordered_set\u003cListNode*\u003e seen;这一行为什么\u003cListNode\u003e后要加个* ？*加在前面表示定义指针，加在后面表示什么呢？知道的可以在评论区给我留言。 因为只遍历一次，时间复杂度：O(N) 。要开辟哈希表，空间复杂度O(N)。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"方法二：快慢指针 这个方法很巧妙，leetcode给的解释非常易懂，还有演示视频。 本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 细节:为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？ 观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。 当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码： class Solution { public: bool hasCycle(ListNode* head) { if (head == nullptr || head-\u003enext == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-\u003enext; while (slow != fast) { if (fast == nullptr || fast-\u003enext == nullptr) { return false; } slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } return true; } }; 其实这个代码有点啰嗦。 时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。 当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。 空间复杂度：O(1)。因为只使用了两个指针的额外空间。 [lostBookBoy]问了一个问题：“为什么慢指针每次只移动一步，而快指针每次移动两步而不是其他步？” [洛阳令]的回答：“这里的慢1快2还是有些讲究的，要是慢一快三未必可以解。快减慢等于1是一定有解的。可以将环理解为一个整数加法群，只有差为一才一定有解。” ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:2","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"其它方法： 看了评论区，各路大神各显神通。有的在遍历的时候把链表节点的值改成'bjfuvth'，再遇到就说明有环，这样就不用哈希了。还有跑了很多遍代码发现这题的链表最多有8029个节点，跑完8029个后如果还没结束就说明有环。哈哈哈，为了能过一道题真是无所不用其极。 这是一道很简单的题，做出来可能只需要5分钟，但是在整理这道题时我花了1个小时，学习就是这个样子，不怕折腾。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:3","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 该题来自：https://leetcode-cn.com/problems/merge-sorted-array/ 88. 合并两个有序数组 难度简单1308收藏分享切换为英文接收动态反馈 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 **注意：**最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 \u003c= m, n \u003c= 200 1 \u003c= m + n \u003c= 200 -109 \u003c= nums1[i], nums2[j] \u003c= 109 ","date":"2022-03-04","objectID":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/:1:0","tags":null,"title":"合并两个有序数组——数组、双指针、排序——这题的题解绝了","uri":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/"},{"categories":["刷题"],"content":"题解 法一：直接合并后用sort()排序 本来以为会禁用STL，但是竟然没有，这种方法能过也是出乎我的意料。代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { for(int i=m;i\u003cm+n;i++){ nums1[i] = nums2[i-m]; } sort(nums1.begin(),nums1.end()); } }; 而且还超过了百分之百的用户，笑死，赶紧截图纪念。 sort()函数可以套用快速排序的时间复杂度和空间复杂度，都为O((m+n)log(m+n))。 法二：双指针 利用一个重要性质：nums1和nums2都是有序数组。 用两个指针p1和p2分别指向nums1和num2的头部，然后比较nums[p1]和nums[p2]，将较小的那个数的指针（比如p1）往后移（p1++）。有点像归并排序。 这个图非常生动形象： 代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 \u003c m || p2 \u003c n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] \u003c nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 两指针最多移动m+n次，因此时间复杂度O(m+n)。为防止覆盖，需要新建m+n长度的数组，因此空间复杂度为O(m+n)。 法三：逆向双指针 怎么样不建立新的数组，直接利用nums1后面空余的部分呢？我们想到了让p1和p2两指针从后向前遍历，每次取最大的那个数放在nums1的最后面。 但是有一个前提，在从后向前填的过程中会不会覆盖nums1前面的数字呢？答案是不会，下面证明： 在遍历的任一时刻，nums1数组中有m-p1-1个元素被放入nums1的最后面，nums2数组中有n-p2-1个元素被放入nums1的最后面。而在指针p1的后面，nums1数组有m+n-p1-1个位置。 由于 $$ m+n-p1-1 \u003e= m-p1-1+n-p2-1 $$ 等价于 $$ p2\u003e-1 $$ 永远成立。所以不会被覆盖。 代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 \u003e= 0 || p2 \u003e= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] \u003e nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 看完这个题解我真是觉得太牛逼了。 时间复杂度O(m+n)，因为不需要额外数组，所以空间复杂度O(1)。 ","date":"2022-03-04","objectID":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/:2:0","tags":null,"title":"合并两个有序数组——数组、双指针、排序——这题的题解绝了","uri":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/"},{"categories":["刷题"],"content":" 该题目来自：https://leetcode-cn.com/problems/valid-sudoku/ ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:0:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题目 36. 有效的数独 难度中等786收藏分享切换为英文接收动态反馈 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：true 示例 2： 输入：board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字（1-9）或者 '.' ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:1:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题解 呜呜呜，像我这种臭鱼烂虾也配做出leetcode中等难度的题了吗？ 我的方法，分别扫描行、扫描列、扫描九宫格，三次遍历得出结果： class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { unordered_set\u003cint\u003e hashset; // 扫描行 for(int i=0;i\u003c9;i++){ for(int j=0;j\u003c9;j++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } hashset.clear(); } // 扫描列 for(int j=0;j\u003c9;j++){ for(int i=0;i\u003c9;i++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } hashset.clear(); } // 扫描九宫格 for(int m=0;m\u003c3;m++){ for(int n=0;n\u003c3;n++){ //拆成3*3的九宫格 for(int i=m*3;i\u003c(m+1)*3;i++){ for(int j=n*3;j\u003c(n+1)*3;j++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } } hashset.clear(); } } return true; } }; 大佬的方法，一次遍历就行了： class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { int rows[9][9]; int columns[9][9]; int subboxes[3][3][9]; memset(rows,0,sizeof(rows)); memset(columns,0,sizeof(columns)); memset(subboxes,0,sizeof(subboxes)); for (int i = 0; i \u003c 9; i++) { for (int j = 0; j \u003c 9; j++) { char c = board[i][j]; if (c != '.') { int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; subboxes[i / 3][j / 3][index]++; if (rows[i][index] \u003e 1 || columns[j][index] \u003e 1 || subboxes[i / 3][j / 3][index] \u003e 1) { return false; } } } } return true; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode-solution-50m6/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 节省遍历次数的关键是创建了三个数组， rows[i][index]记录当前数字index在第i行出现的次数。 columns[j][index]记录当前数字index在第j列出现的次数。 subboxes[i/3][j/3][index]记录当前数字index在第[i/3][j/3]个九宫格中出现的次数。 因为有确定的遍历次数和确定的数组大小，所以时间和空间复杂度都是O(1) ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:2:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题目 该题目来自：https://leetcode-cn.com/problems/two-sum/ 1. 两数之和 难度简单13591收藏分享切换为英文接收动态反馈 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ ","date":"2022-03-02","objectID":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":null,"title":"由和找到两数——数组、哈希表","uri":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 最简单的暴力： class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { for(int i=0;i\u003cnums.size()-1;i++){ for(int j=i+1;j\u003cnums.size();j++){ if(nums[i] + nums[j] == target){ return {i, j}; } } } return {}; } }; 时间复杂度：O(N^2) 空间复杂度：O(1) 哈希表： 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以优化的地方就是对于每个元素x，寻找target-x可以改用哈希表寻找，速度可以从O(N)降到O(1)。 只遍历一遍nums数组，对于每个x，寻找target-x是否在哈希表中，如果不在就把x插入到哈希表中。 class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { unordered_map\u003cint, int\u003e hashtable; for (int i = 0; i \u003c nums.size(); ++i) { auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) { return {it-\u003esecond, i}; } hashtable[nums[i]] = i; } return {}; } }; 时间复杂度：O(N) 空间复杂度：O(N) 代码解释： hashtable: 由键-值组成（都是int类型）在这道题里键是nums[i]，值是索引i。 it-\u003esecond: it是迭代器，it-\u003esecond表示访问值，同理it-\u003efirst访问键，也可以写成(*it).second，(*it).first。 ","date":"2022-03-02","objectID":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":null,"title":"由和找到两数——数组、哈希表","uri":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["技能分享"],"content":"yolov5训练自己的目标检测模型 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:0:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"yolov5 yolo是当前最火的目标检测模型之一，效果很好速度很快，也很适合小白上手。yolov5是yolo的第五代模型。 项目地址：https://github.com/ultralytics/yolov5 克隆下来之后，用pycharm打开，选择3.8版本的python解释器，自动安装依赖。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:1:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"制作数据集 数据集在线打标网站：https://www.makesense.ai/ 打标完成后可以下载符合yolo格式的txt文件。 然后需要对数据集进行组织。 我的数据集目录如下： screwdata ├── images │ ├── test │ │ ├── 若干测试图片.jpg │ └── train │ ├── 若干训练图片.jpg └── labels ├── test │ ├── 若干测试图片的标签.txt ├── train │ ├── 若干训练图片的标签.txt 注意：images目录下的图片文件名需和labels目录下的文件名保持一致（后缀名不同） 其中测试/训练图片的标签文件为文本文件，其格式如下： 0 0.991121 0.932710 0.017757 0.059813 0表示类别，这里我只用到一个类别，后面四个数字表示矩形选框四个顶点的位置。 还需准备一个yaml配置文件： # screwdata.yamltrain:/Users/sunbaile/yolov5/screw/images/train# 训练集pathval:/Users/sunbaile/yolov5/screw/images/test# 验证集path# Classesnc:1names:['screw_missing']# class names","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:2:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"训练 在yolov5根目录下有train.py文件，修改其data字段： parser.add_argument('--data', type=str, default=ROOT / 'data/screwdata.yaml', help='dataset.yaml path') # screwdata.yaml就是前面配置的数据集配置文件 右键运行即可开始训练，训练结果会保存到runs/train目录下。 可以使用colab提供的免费gpu算力进行训练，亲测很好用： https://colab.research.google.com/ 训练完把权重下载下来即可。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:3:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"推理 负责推理的文件是detect.py。 使用命令行工具进行推理，在终端键入： python detect.py --source 图片路径 --weights 权重路径 举个例子： python detect.py --source /Users/sunbaile/yolov5/screw/images/test/CPU风扇-缺2颗螺丝2.jpg --weights /Users/sunbaile/yolov5/runs/train/exp/weights/best.pt --conf-thres 0.5 # 这里我加了一个conf-thres 0.5 表示置信度高于0.5才标记 推理结果保存在runs/detect/exp 效果不错！ ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:4:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"参考资料 目标检测 YOLOv5 开源代码项目调试与讲解实战【土堆 x 布尔艺数】: https://www.bilibili.com/video/BV1tf4y1t7ru?p=8\u0026spm_id_from=333.1007.top_right_bar_window_history.content.click 感谢土老师的教学视频。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:5:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["刷题"],"content":"题目 来自：https://leetcode-cn.com/problems/maximum-subarray/ 53. 最大子数组和 难度简单4424收藏分享切换为英文接收动态反馈 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 ","date":"2022-02-28","objectID":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/:1:0","tags":null,"title":"最大子数组和——动态规划、分治","uri":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/"},{"categories":["刷题"],"content":"题解 法一：动态规划 用一个数组f[i]表示以第i个元素结尾的具有最大和的连续子数组，i从0开始。有如下式子： f[i] = max( f[i-1]+nums[i] , nums[i] ) 这样就可以递推求出所有的f[i]啦。代码如下： class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { int f[100001]; f[0] = nums[0]; int max_num = f[0]; for(int i=1;i\u003cnums.size();i++){ f[i] = max(f[i-1]+nums[i], nums[i]); max_num = max(max_num, f[i]); } return max_num; } }; 我这里写的很简陋，力扣官方给的题解说的很清楚：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/ 法二：分治 因为用法一把这题过了，懒得看法二了… ","date":"2022-02-28","objectID":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/:2:0","tags":null,"title":"最大子数组和——动态规划、分治","uri":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/"},{"categories":["刷题"],"content":"题目 该题来自：https://leetcode-cn.com/problems/contains-duplicate/ [217. 存在重复元素] 难度简单635收藏分享切换为英文接收动态反馈 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1] 输出：true 示例 2： 输入：nums = [1,2,3,4] 输出：false 示例 3： 输入：nums = [1,1,1,3,3,4,3,2,4,2] 输出：true 提示： 1 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 ","date":"2022-02-26","objectID":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/:1:0","tags":null,"title":"存在重复元素——排序、哈希","uri":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"categories":["刷题"],"content":"题解 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode-sol-iedd/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 法一：最慢的方法，把nums中的每个元素都拿出来，遍历nums数组找一下看有没有跟它相同的元素。时间复杂度O(n^2) 法二：用sort函数排个序，相同的元素会被排到一块儿，遍历一遍nums数组就找到了。思路很简单，但还是不够优雅。时间复杂度O(nlogn) 补充一下c++中的sort函数： sort(first_pointer,first_pointer+n,cmp) 该函数可以给数组，或者链表list、向量排序。 实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。 此函数有3个参数： 参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。 参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。 参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。 代码： class Solution { public: bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i \u003c n - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; } }; 法三（最优）：将nums数组中的每个元素插入哈希表，如果发现已存在，则说明有重复。时间复杂度O(N) 代码： class Solution { public: bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { unordered_set\u003cint\u003e s; for (int x: nums) { if (s.find(x) != s.end()) { return true; } s.insert(x); } return false; } }; ","date":"2022-02-26","objectID":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/:2:0","tags":null,"title":"存在重复元素——排序、哈希","uri":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"categories":["刷题"],"content":"题目 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-the-town-judge 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么： 小镇法官不会信任任何人。 每个人（除了小镇法官）都信任这位小镇法官。 只有一个人同时满足属性 1 和属性 2 。 给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。 如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。 示例 1： 输入：n = 2, trust = [[1,2]] 输出：2 示例 2： 输入：n = 3, trust = [[1,3],[2,3]] 输出：3 示例 3： 输入：n = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 ","date":"2022-02-25","objectID":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/:1:0","tags":null,"title":"找到小镇的法官——图论入门","uri":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/"},{"categories":["刷题"],"content":"题解 先吐槽一下：今天是开学第五天，是我第五次来图书馆。没办法，像我这种生活极不充实的人就只能在图书馆消磨时光。 回到正题：这是一道图论入门题目。把小镇上的每个人作为一个节点，信任关系作为边，那么所谓的“法官”其实就是出度为0，入度为n-1的节点。所以解体思路就是通过遍历trust数组把每个节点的出度和入度统计出来就可以啦。 代码： class Solution { public: int findJudge(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 trust) { vector\u003cint\u003e inDegrees(n + 1); vector\u003cint\u003e outDegrees(n + 1); for (auto\u0026 edge : trust) { int x = edge[0], y = edge[1]; ++inDegrees[y]; ++outDegrees[x]; } for (int i = 1; i \u003c= n; ++i) { if (inDegrees[i] == n - 1 \u0026\u0026 outDegrees[i] == 0) { return i; } } return -1; } }; 其中auto的意思是自动确定变量类型。关于“\u0026”的用法我还没搞明白。 ","date":"2022-02-25","objectID":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/:2:0","tags":null,"title":"找到小镇的法官——图论入门","uri":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/"},{"categories":["刷题"],"content":" 完全背包问题和01背包问题的区别就是完全背包问题不限制物体的数量。 题目链接：https://www.acwing.com/problem/content/3/ 有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。 第 ii 种物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 输入格式 第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0\u003cN,V≤10000\u003cN,V≤1000 0\u003cvi,wi≤10000\u003cvi,wi≤1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 10 ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 参考作者：Charles__ 链接：https://www.acwing.com/solution/content/5345/ 来源：AcWing 在01背包问题中，有一段判断装不装该物品的代码： for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { // 当前背包容量装不进第i个物品，则价值等于前i-1个物品 if(j \u003c v[i]) f[i][j] = f[i - 1][j]; // 能装，需进行决策是否选择第i个物品 else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } 我们可以用一个0到1的k循环改写，k的物理意义是物品的数量： for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++) { for(int k = 0 ; k*v[i]\u003c=j\u0026\u0026k\u003c=1 ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } } 当k=0时，f[i][j] = f[i-1][j]; 当k=1时（k*v[i]\u003c=j的约束条件保证背包可以装得下）， f[i][j] =max(f[i][j],f[i-1][j-v[i]]+w[i]) =max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 这样我们就可以推广01背包问题到完全背包问题啦，完全背包问题的答案如下： #include\u003ciostream\u003eusing namespace std; const int N = 1010; int f[N][N]; int v[N],w[N]; int main() { int n,m; cin\u003e\u003en\u003e\u003em; for(int i = 1 ; i \u003c= n ;i ++) { cin\u003e\u003ev[i]\u003e\u003ew[i]; } for(int i = 1 ; i\u003c=n ;i++) for(int j = 0 ; j\u003c=m ;j++) { for(int k = 0 ; k*v[i]\u003c=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } cout\u003c\u003cf[n][m]\u003c\u003cendl; } but，这样写性能貌似不太行啊，还得优化： 大佬通过数学推导，把循环都给破解了，核心代码优化成这样： for(int i = 1 ; i \u003c=n ;i++) for(int j = 0 ; j \u003c=m ;j++) { f[i][j] = f[i-1][j]; if(j-v[i]\u003e=0) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } 后面还能继续优化！但是到这里这道题已经能ac了，我这个懒逼就不继续思考了。 最终代码： #include \u003ciostream\u003e using namespace std; const int MAXN = 1005; int v[MAXN]; // 体积 int w[MAXN]; // 价值 int f[MAXN][MAXN]; // f[i][j], j体积下前i个物品的最大价值 int main(){ int n,m; cin \u003e\u003e n \u003e\u003e m; for(int i=1;i\u003c=n;i++){ cin \u003e\u003e v[i] \u003e\u003e w[i]; } for(int i = 1 ; i \u003c=n ;i++) for(int j = 0 ; j \u003c=m ;j++) { f[i][j] = f[i-1][j]; if(j-v[i]\u003e=0) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } cout \u003c\u003c f[n][m] \u003c\u003c endl; return 0; } ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":" 题目来自：https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=UwJf7O4w1mYDi1yfimoQC3A85cwxyluK0ixh0ZlBDLqKKVOlEWEHJVbdE4OlzzVr\u0026search_content=%E8%83%8C%E5%8C%85 有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 ii 件物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0\u003cN,V≤10000\u003cN,V≤1000 0\u003cvi,wi≤10000\u003cvi,wi≤1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 难度：简单 时/空限制：1s / 64MB 总通过数：95474 总尝试数：158804 来源：背包九讲 , 模板题 算法标签 题解 #include\u003cbits/stdc++.h\u003e using namespace std; const int MAXN = 1005; int v[MAXN]; // 体积 int w[MAXN]; // 价值 int f[MAXN][MAXN]; // f[i][j], j体积下前i个物品的最大价值 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { // 当前背包容量装不进第i个物品，则价值等于前i-1个物品 if(j \u003c v[i]) f[i][j] = f[i - 1][j]; // 能装，需进行决策是否选择第i个物品 else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } cout \u003c\u003c f[n][m] \u003c\u003c endl; return 0; } 作者：深蓝 链接：https://www.acwing.com/solution/content/1374/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 感想 01背包问题可以衍生出很多题目，是很重要的问题。 核心公式 // 状态转移方程 dp[i][k] = max(value[i] + dp[i-1][k-weight[i]], dp[i-1][k]) 理解： 看这个博客讲的特别好https://www.cnblogs.com/kkbill/p/12081172.html ","date":"2022-02-22","objectID":"/posts/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"01背包问题——动态规划","uri":"/posts/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":" 洛谷P1359 租用游艇 https://www.luogu.com.cn/problem/solution/P1359 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目描述 长江游艇俱乐部在长江上设置了 nn 个游艇出租站 1,2,\\cdots,n1,2,⋯,n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 ii 到游艇出租站 jj 之间的租金为 r(i,j)r(i,j)（1\\le i\\lt j\\le n1≤i\u003cj≤n）。试设计一个算法，计算出从游艇出租站 11 到游艇出租站 nn 所需的最少租金。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输入格式 第一行中有一个正整数 nn，表示有 nn 个游艇出租站。接下来的 n-1n−1 行是一个半矩阵 r(i,j)r(i,j)（1\\le i\u003cj\\le n1≤i\u003cj≤n）。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输出格式 输出计算出的从游艇出租站 11 到游艇出租站 nn 所需的最少租金。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输入输出样例 输入 #1复制 3 5 15 7 输出 #1复制 12 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:4:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"说明/提示 n\\le 200n≤200，保证计算过程中任何时刻数值都不超过 10^6106。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:5:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"解法 #include\u003ciostream\u003e#include\u003ccmath\u003eusing namespace std; int a[201][201],i,j,n,dp[201]; int main(){ cin\u003e\u003en; for(i=1;i\u003cn;i++){ for(j=i+1;j\u003c=n;j++) cin\u003e\u003ea[i][j]; dp[i]=1e9;//初始化数组dp，使它 } for(i=n-1;i\u003e=1;i--)//跑n上流的中转站 for(j=i+1;j\u003c=n;j++)//跑i下流的所有中转站 dp[i]=min(dp[i],a[i][j]+dp[j]);//记录 cout\u003c\u003cdp[1]; return 0; } ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:6:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"感受 第一次做动态规划，没啥思路，代码是复制别人的题解，代码很巧妙，当n=3时，dp[3]=0，从后往前找最短路径，使得代码很简洁。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"今天是大二下学期开学第一天。恭喜我，又是孤单一人了。既然是一个人，那就要自己对自己好好负责咯，一个人的话，立的flag其实更能坚持下去！ ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:0:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"把自己打扮的干净整洁 把自己打扮的干净整洁是我这学期立的第一个flag。每次我从学校回家时我妈都会说一句：“你怎么搞糟的这么脏！” 上学期我确实不注重卫生，一天只刷一次牙，洗脸不用毛巾也不用洗面奶，内衣攒够一盆才洗…不脏才怪，我才20岁，看起来却像28岁，走进店里营业员叫我 “先生您好”。造成这个的原因有两个，一方面是我缺少生活经验，另一方面是我太懒。 用白泥面膜，好好洗脸。 衣服挂在衣柜里，不要随便扔床上或者板凳上。 勤打热水，勤洗衣服。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:1:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"做算法题 每次一想到算法我都特别愧疚。大一没进入acm社团，大二csp认证没考过，数据结构学的也一般。算法可能是区分普通程序员和高级程序员的最重要指标，可我却一次又一次错过提升算法能力的机会。 定个小目标： 每次去图书馆自习的时候做一道算法题。 这个目标只要稍微踮一踮脚尖就能够得到，我不想把目标定的太高让自己很快就放弃。为什么是去图书馆呢？因为这学期课很少，不在上课的话，我基本都会去图书馆，在图书馆呆的时间应该会非常长。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:2:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"继续锻炼 我还记得我上大学第一堂体育课，那个教篮球的白发苍苍的老教练跟我们说：“大学四年，你呆的最多的地方应该是图书馆和体育场。” 如果图书馆能按去的次数评等级的话，那我一定是黄金vip。体育场也要坚持去呀。表哥是我非常崇拜的人，他也鼓励我让我多锻炼。我最喜欢的锻炼就是跑步，跑步的时候大脑放空，跑完3公里，大汗淋漓，感觉自己的身心都得到了净化，感觉自己更强了，更有力量了，就像被充了电一样。 这学期的目标是跑150公里。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:3:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"读书并写读书笔记 这一年要读25本书。 读书既是对自己长期的投资，也是消磨时间的好方法。光读书不做笔记就像光吃饭不消化一样没用，不能陷入只读书的死循环。一本书带给人的影响是暂时的，读完之后记忆会慢慢淡忘，但是一旦拿起笔记录下来，那书中的知识才会悄无声息的变成自己的知识。书读的好，不代表读书笔记写的好，但读书笔记写的好，书读的一定好。因此，我以后要花很多精力放在写读书笔记上面，力求写出高质量的读书笔记。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:4:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"背单词 这个就没啥好说的，以后读论文，写论文都是全英文，英文太重要了。况且英语也不是一天两天学成的，每天背单词就对了。另外，用百词斩太被动了，墨墨背单词比较主动，更有用。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:5:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"与臭宝和刘鑫宇的快乐假期 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:0","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"前言 作为一个热爱生活的人，记录生活是我的爱好。2021-2022年寒假很快就要结束了，翻看手机相册，拍了很多有趣的照片。2022假期陪我玩的最多的就是臭宝（大名高若宇）和刘鑫宇啦。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:1","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"网络冲浪 这个假期去的最多的地方就是树袋熊网咖，每周至少4次，无限乱斗打了100多把。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:2","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"美式盛宴 冲完浪的小青年饥肠辘辘，渴望来一份美式盛宴。来到那家1944年美国副总统冠名的店里，要不了多久，一对金童玉女摆在了我两的面前。摆开它那稚嫩的肌肤，简直就是玉体横陈，垂涎欲滴。别问为什么是华莱士，问就是想治便秘。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:3","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"狂野飙车 这是我最常骑的共享小电驴，大晚上在东海大道飙车真的好爽，好自由。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:4","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"双人成行 这个假期跟刘鑫宇和臭宝一起把蚌埠市三家电玩全玩了一遍，体验了ps4和switch。玩的最多的就是双人成行和马里奥3D世界。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:5","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"撸猫带娃 和臭宝去了两次猫咖，拍了一张比较有趣的照片。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:6","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"给臭宝过生日 跟臭宝出去玩了6次，第二次就是给臭宝过了生日，每次出去玩都很开心。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:7","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"吃串整活 假期在家自己学做饭，做的最成功的就是烤羊肉串，真的跟烧烤店里卖的味道一模一样。 还整了个小活。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:8","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"大玩家 跟臭宝去大玩家，玩到了男孩子无法拒绝的赛车游戏～ ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:9","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"抓娃娃 以前我从来没抓过娃娃，这个寒假跟臭宝带她妹妹玩了很多次，抓了3只。没用的技能又增加了… ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:10","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"做陶艺 跟臭宝去做陶艺。哇这个真的好难。 她真是个很温柔的人，连路边的狗狗都很喜欢她。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:11","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"小吃街 蚌埠市的小吃街，很多都是老店，好吃还便宜。但像我这种人很少自己去，今天沾了臭宝的光。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:12","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"冰雪世界 下雪的那天跟臭宝去张公山公园看了雪景，好漂亮！ ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:13","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"火锅勺子吃冰淇淋 自助餐的冰淇淋，小勺子太不过瘾了，直接拿火锅勺子干。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:14","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"牛排自助 188元一人的牛排自助，今天实现牛排自由了。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:15","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"还是网咖 寒假去的最多的地方还是网咖，哎～（替不想让我打游戏的我妈叹一口气） ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:16","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"海底捞 去超市买了7盒肉卷、一盒酸菜鱼带到海底捞吃。这是吃的最爽的一次海底捞！但也是我们的寒假一起吃的最后一顿饭了。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:17","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"让我再看你一眼，东海大道 上面所有玩的地方，都跟这条叫东海大道的路有关。这是蚌埠市最繁华的一条路，是承载了我无数记忆的一条路。离开家乡的前一天，刚好又下雪了，让我再看你一眼，东海大道。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:18","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["随笔杂记"],"content":"感谢 跟我关系好的人蛮多，但只有二位是知心知己，知根知底的。感谢你们在这个假期带给我如此多的快乐，期待下个假期咱们再聚。 ","date":"2022-02-17","objectID":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/:0:19","tags":null,"title":"与臭宝和刘鑫宇的快乐假期","uri":"/posts/%E4%B8%8E%E8%87%AD%E5%AE%9D%E5%92%8C%E5%88%98%E9%91%AB%E5%AE%87%E7%9A%84%E5%BF%AB%E4%B9%90%E5%81%87%E6%9C%9F/"},{"categories":["书影记录"],"content":"雪国 雪国是远离繁华都市，如世外桃源一般的地方。在小说的开头写道： 穿过县界长长的隧道，便是雪国。 夜空下一片白茫茫。 主人公岛村每年都会独自来雪国度假，在这里他结识了一个叫驹子的姑娘，岛村被驹子的活泼美丽打动，两人情投意合，开始交往。同时另一个叫叶子的姑娘，她纯粹空灵的气质，更让岛村着迷。故事的情节非常简单，就连故事的背景雪国都是白茫茫一片，十分纯净的，但是作者通过对故事片段细腻的描写表达出那种感伤的美让人印象深刻。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"川端康成 作者川端康成的一生命途多舛，2岁丧父，3岁丧母，10岁姐姐去世，15岁祖父去世，世上再无亲人。因此他的文学作品多带有淡泊的感伤色彩和物哀美。1968年，以《雪国》《古都》《千只鹤》三部代表作获得诺贝尔文学奖。初读《雪国》，想起这是一本诺奖作品，还有点儿生畏，但又一想，我阅读文学作品毕竟不是做高考阅读题，不需要一字一句斟酌，只要用心去感受就可以了，便放下心来开始阅读。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"驹子和叶子 驹子是一个活泼可爱，敢爱敢恨的女孩。文中不乏对她美貌的描写，比如： ​ 玲珑而悬直的鼻梁，虽嫌单薄些，但在下方搭配着的小巧的紧闭的柔唇，却苑如美极了的水蛭环节，光滑而伸缩自如，在默默无言中也有一种动的感觉。如果嘴唇起了皱纹，或者色泽不好，就会显得不洁净。她的嘴唇却不是这样，而是滋润光泽的。两只眼晴，眼梢不翘起也不垂下，简直像有意描直了似的，虽逗人发笑，却恰到好处地镶嵌在两道微微下弯的浓密的短眉毛下。颧骨稍耸的圆脸，轮廓一般，但肤色恰似在白瓷上抹了一层淡淡的胭脂。脖颈底下的肌肉尚未丰满。她虽算不上是个美人，但比谁都要显得洁净。 ​ 对一个当过舞伎的女子来说她的胸脯算是有点挺的。 她爱上了来自东京的岛村后，不顾一切的接近他，调皮又任性。比如常在醉酒后闯入岛村的屋子： 但是，没过十分钟，驹子就拖着碎乱的脚步走了进来。 “刚才那孩子送什么来没有？” “送来了。” “是吗？”她快活地眯缝着一只眼睛说，“唔，真痛快。我说去叫酒，就偷偷地溜了出来。被掌柜发现，挨了一顿骂。酒真好呢，即使挨骂，我也不在乎。啊，真讨厌，一来到这里就醉了。我还得去啊。” 大胆的表达自己的情感，敢爱敢恨： “才不呢。我才不干这种可怜巴巴的事。那种给你太太看见也无所谓的信，我才不写呢。那样做多可怜啊！我用不着顾忌谁而撒谎呀！” 驹子抢着反驳，语气非常激烈。岛村低下了头。 电影《雪国》\" 电影《雪国》 而叶子的形象是更加纯净的，空灵的，虚幻的。 ​ 黄昏的景色在镜后移动着。也就是说，镜面映现的虚像与镜后的实物在晃动，好像电影里的叠影一样。出场人物和背景没有任何联系。而且人物是一种透明的幻象，景物则是在夜霭中的朦胧暗流，两者消融在一起，描绘出一个超脱人世的象征世界。特别是当山野里的灯火映照在姑娘的脸上时，那种无法形容的美，使岛村的心都几乎为之颤动。 ​ 在遥远的山巅上空，还淡淡地残留着晚霞的余晖。透过车窗玻璃看见的景物轮廓，退到远方，却没有消逝，但已经黯然失色。尽管火车继续往前奔驰，在他看来，山野那平凡的姿态显得更加平凡。由于什么东西都不十分惹他注目，他内心反而好像隐隐地存在着一股巨大的感情激流。这自然是由于镜中浮现出姑娘的脸的缘故。只有身影映在窗玻璃上的部分，遮住了窗外的暮景，然而，景色却在姑娘的轮廓周围不断地移动，使人觉得姑娘的脸也像是透明的。是不是真的透明呢？这是一种错觉。因为从姑娘面影后面不停地掠过的暮景，仿佛是从她脸的前面流过。定睛细看，却又扑朔迷离。 ​ 车厢里也不太明亮。窗玻璃上的映像，不像真的镜子那样清晰。没有反光。这使岛村看得入了神，他渐渐地忘却了镜子的存在，只觉得姑娘好像漂浮在流逝的暮景之中。 ​ 这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯火。灯火也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜光虫，妖艳而美丽。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"岛村 岛村是一个来自东京的富二代，他在东京有家室，但还是每年来到雪国这样一个偏僻的地方寻花问柳。可以把他理解为渣男。 岛村第一次见到驹子时，对她的第一印象是洁净，文中说： 女子给人的印象洁净得出奇，甚至令人想到她的脚趾弯里大概也是干净的。 但是当岛村第二次见到驹子时，她已经沦为了艺妓。岛村的反应是： 看到衣服下摆，岛村不由得一惊：她到底还是当艺妓了么？！ 在得到驹子的肉体之后，渣男岛村并没有满足，他开始想念得不到的叶子： 然而，一想起叶子在这家客栈里，不知为什么，岛村对找驹子也就有点拘束了。尽管驹子是爱他的，但他自己有一种空虚感，总把她的爱情看作是一种美的徒劳。即使那样，驹子对生存的渴望反而像赤裸的肌肤，触到了他的身上。他可怜驹子，也可怜自己。他似乎觉得叶子的慧眼放射出一种像是看透这种情况的光芒。他也被这个女子吸引了。 川端康成揭露了男人怪癖的一面，男人想要自己的女人对自己一个人有百种风情，却对除了自己以外的人敬而远之。他既渴望热情奔放的肉体，又渴望纯洁无暇的灵魂。在小说中，驹子就是热情奔放的肉体，叶子是纯洁无暇的灵魂。 但是纯洁无暇的灵魂可能仅存在于想象之中吧，连故事中的叶子，最后也被大火烧死了。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"记录寒假学做饭 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:0","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"故事起因 放假前刷到b站一个热门视频，惊呼：“做饭竟然这么简单？” 再想到假期在家要天天忍受我妈做的“没有技巧，全是感情”的饭，嘴里的口水从眼睛里流了出来😭。反正我在家也很闲，那就立个学做饭的flag吧！💪 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:1","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"1.家庭烤肉 其实这个不是自己做的是我姐做的，我只是想把它放在第一位撑撑场子… 在青岛上学过的太穷酸了，回家后吃这一顿真是解了大馋😋 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:2","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"2.自制盖浇饭 一顿烤肉带来的美味可不止一顿烤肉。剩下的鸡翅跟浸着鲜肥汤汁的青菜一起铺在剩米饭上，放微波炉热一分钟又是绝佳美味。 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:3","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"3.溏心鸡蛋 别嘲讽我不会做饭，这不从头学着嘛。万事开头难，我可不想一开头就被打倒，就挑了个简单的溏心鸡蛋做。不过话说回来，溏心鸡蛋真的好简单，记住开水煮6分钟，我一次就成功啦，一下子做饭就有信心了。 （ps：记得吃溏心蛋要买无菌鸡蛋） ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:4","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"4.面包夹煎鸡蛋 把面包和鸡蛋放进锅里一起煎，面包焦了，鸡蛋还没熟透！不过咬下去外焦里嫩，别有一番风味，这算是成功了还是失败了呢？ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:5","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"5.煎牛排 真不是我煎得好，是必胜客的速食牛排牛逼。😂 早上花五分钟煎个西冷牛排，看它在锅里发生梅拉德反应，真是能唤醒一天的活力呢！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:6","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"6.鸡蛋酱 鸡蛋+豆瓣酱，第一次吃美艳！第二次吃腻死了qwq 你要是问我为啥总是跟鸡蛋过不去，我的回答是因为我在跟这个视频学…5天60颗鸡蛋，13个难度19种吃法，尽管收藏，我还能卷自己 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:7","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"谁还不是个小馋猫呢？ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:8","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"7.羊肉串 参考这个视频大厨分享烤串店火了20年的秘制调料配方，免费分享大家，太受用了 前一天晚上我就开始腌羊肉，加了不少调料。记得最清楚的是加鸡蛋和淀粉是为了让羊肉滑腻，烤的时候不容易变柴。 第二天跟基友去买菜，顺便整个活儿 中午烤串，没想到第一次做竟然这么成功！跟烧烤店味道一样，而且自己做的串更大更爽，吃起来嘎嘎香。 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:9","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"8.西红柿鸡蛋方便面 请我姐吃旋转小火锅，她答应给我做一顿早餐。做什么呢，就做西红柿鸡蛋方便面吧。 这碗面煮的绝了，汤汁不浓不淡，面条不硬不糊，鸡蛋圆滚滚的也很可爱。真是把方便面的价值都榨干啦。 再看看我做的，汤不是太多就是太少，厨艺有待加强！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:10","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"下雪啦！ 雪景好好看呀，就是太冷了… ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:11","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"9.火锅 那么冷的天，最幸福的事情当然是吃热腾腾的火锅呀。底料用牛骨汤+海底捞清油火锅底料，味道应该是鲜味不是辣味吧？ 艹，好辣啊。全家就我一个人吃到最后qwq ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:12","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"10.烤鸡翅 空气炸锅到货啦，第一件事当然是拿来烤鸡翅咯。 不得不说，空气炸锅烤鸡翅真的超级无敌方便。鸡翅直接买超市腌好的，放在锡纸上丢进空气炸锅200度烤18分钟就可以啦。吃完连锅都不用洗！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:13","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["书影记录"],"content":"半泽直树 半泽直树是日本电视剧《半泽直树》中的主人公。半泽的家族经营了一家小公司，在半泽年幼时，日本遇到了经济泡沫，公司急需贷款，但银行对此不但见死不救，还落井下石，逼死了半泽的父亲。大学毕业后，半泽竟选择进入银行工作，立志要找到害死父亲的人，并完成复仇。电视剧的主要讲述的，就是半泽如何传奇般的一步一步完成自己的复仇计划的故事。剧中有很多半泽直怼上司的剧情，让人看了大呼过瘾，半泽直树也被网友称为“最强打工人”。 ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人物塑造 半泽直树：在职场上，半泽是一个十分有魄力、有胆识的好员工。同时，他也是个顾家爱老婆的好男人。他有很多好品质，剧中突出表现的，是他敢于挑战权威，说白了就是敢于跟领导硬刚。半泽有一句经典台词： 以牙还牙，加倍奉还！ 眼看着自己的父亲被逼死，年幼的半泽心里埋下了仇恨的种子。电视剧把人物塑造的非常立体，之后半泽做的每一个决定，都有背景故事支持。 两个基友：其中一个基友渡真利长得好帅。另一个基友近藤是一个更贴近生活的形象，在工作上受尽了挫折，差点精神分裂。当受到诱惑时，心中的正义也没能战胜邪恶。 大和田常务：为人圆滑，城府很深，经典的上司形象。记住这个演员叫香川照之，演的非常好！ ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情思考 前方轻微剧透 这里主要讨论第一季最后的结局： 我想说的是：意料之外，情理之中。古人说，**木秀于林，风必摧之；堆出于岸，流必湍之，行高于人，众必非之。**半泽的表现太过于惹人眼球，对行长来说是一个威胁，必然要给他一个下马威。 另一方面，半泽并不完全是正义的化身，他为了实现自己的复仇，也用了很多见不得人的手段。半泽说：“以牙还牙，加倍奉还”。他这么说，最后也确实做到了。这样的剧情确实让人热血沸腾，看完之后我也想学半泽去狠狠地锤自己的上司。但我们毕竟不是半泽，只是普通人，现实中这么做肯定是会死得很惨的qwq。而且我们当今社会，提倡的也不是“以牙还牙，加倍奉还”，而是“毋忘前耻，振兴中华”。导演让半泽说出这样的台词，只是让观众爽一爽罢了，这样的价值观是不被提倡的。 但是我们作为打工人，就该替上司背锅吗？就该被踩在脚下不反击吗？当然不是，马克思告诉我们，当遇到不平等的待遇时，工人们要联合起来伸张正义。半泽的做法不可复制，但是半泽的精神值得我们奉为圭秀。加油吧，打工人！ ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"为什么抛弃wordpress选择hugo 不用买服务器了 wordpress经常奔溃，易受攻击 hugo编译速度真tm快 有一款钟爱的hugo主题 ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:1","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"文章迁移 文章迁移使用一个hexo插件（你没看错，就是hexo插件）。 首先新建一个hexo博客（用完就可以删了）。 $ hexo init \u003cfolder\u003e $ cd \u003cfolder\u003e $ npm install 再安装 hexo-migrator-wordpress 插件。 $ npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”) 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 $ hexo migrate wordpress \u003csource\u003e 文章很快就能出现在source/_posts目录下，转换效果特别棒。 ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:2","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"修改文章的属性 刚迁移完的每篇文章都有yaml配置，像这样： title:年度总结tags:[]id:'1191'categories:- - 生活date:2022-01-21 11:35:06其实直接丢到hugo的posts文件夹里也没问题，但咱最好还是自己改一下。比如改成这样： author: sunbaile categories: - 随笔杂记 date: 2022-01-21 11:35:06 draft: false title: 年度总结 写了一个python脚本，100多篇文章，1秒钟全搞定（写脚本写了一下午qwq)： import os import yaml import re path = \"/Users/sunbaile/myBlog/content/posts\" # path = \"/Users/sunbaile/myBlog/python脚本\" cnt = 0 for file in os.listdir(path): if file[-3:]==\".md\" : #判断是否为md文件 cnt += 1 print(cnt,file) with open(os.path.join(path,file),\"r+\") as f: all_text = f.read() yaml_text = re.findall(\"---([\\s\\S]*?)---\",all_text)[0] #找到yaml字符串 old_dic = yaml.load(yaml_text) # 用yaml库转字典对象 # print(\"categories:\",old_dic[\"categories\"]) new_dic = { \"title\": old_dic[\"title\"], \"author\": \"sunbaile\", \"draft\": False, \"categories\": old_dic['categories'], \"date\": old_dic[\"date\"] } # print(\"new_dic\",new_dic) yaml_res = yaml.dump(new_dic,allow_unicode=True) #用yaml库将字典解析为yaml字符串 # print(\"***\",yaml_res,\"***\") res = all_text.replace(yaml_text,\"\\n\"+yaml_res) with open(os.path.join(path,file),\"w+\") as f: f.write(res) ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:3","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"图片迁移 如果你打算用github+jsdelivr做图床，迁移图片更简单。思路就是先从服务器上把wordpress的wp-content目录（里面有个uploads文件夹存了你所有的图片）下载下来，然后原封不动的丢到github仓库里，最后把文章中的路径改一下就可以啦。 注意：每张图片都是由固定链接+路径+名字组成。 比如说原来文章的图片链接是这样的： ![](https://www.leyoubaloy.xyz/wp-content/uploads/2021/06/728da9773912b31b0c11b3568418367adab4e154.jpg) 或者是这样的： ![](/wp-content/uploads/2021/02/image-1-1024x431.png) 要替换成这样： ![](https://cdn.jsdelivr.net/gh/leyouBaloy/mypic/wp-content/uploads/2021/06/728da9773912b31b0c11b3568418367adab4e154.jpg) 和这样 ![](https://cdn.jsdelivr.net/gh/leyouBaloy/mypic/wp-content/uploads/2021/02/image-1-1024x431.png) 那肯定还是用python脚本啦，python，yyds! import os import re path = \"/Users/sunbaile/myBlog/content/posts\" # path = \"/Users/sunbaile/myBlog/python脚本\" cnt = 0 for file in os.listdir(path): if file[-3:]==\".md\" : cnt += 1 print(cnt,file) with open(os.path.join(path,file),\"r+\") as f: all_text = f.read() res = re.sub(\"\\((\\/wp-content\\/uploads)\",\"(https://cdn.jsdelivr.net/gh/leyouBaloy/mypic/wp-content/uploads/\",all_text) res = res.replace(\"www.leyoubaloy.xyz\",\"cdn.jsdelivr.net/gh/leyouBaloy/mypic\") with open(os.path.join(path,file),\"w+\") as f: f.write(res) ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:4","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"视频教程： ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:5","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"需求 很简单，就是想在gitee上一提交代码，服务器就自动执行一个sh脚本。脚本的内容就是把代码拉取下来。gitee webhook和sh脚本都好办，关键是如何让服务器监听webhook发来的请求。 在网上一搜，各路大神各显神通，有用jenkins的，有用php的，还有travis CI…各位大佬，我就想实现一个简单的小功能，用这么牛逼的工具真没必要qwq（求饶 终于在谷歌上（百度真的搜不到）搜到一个用nodejs解决的，确实很方便。原博主写的很好，但是有几个小坑，我在这里提醒一下。 版权声明：CSDN博主「如风521」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_31667715/article/details/100117028 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:1","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"什么是webhook webhook也叫钩子。粗浅的来说，就是你写一个小脚本，每次提交代码的时候，让gitee或者github帮你执行一下。重点是这个脚本是你自己编写的，但不是你自己执行的，是GitHub或者gitee帮你执行的。就像在钩子上放个东西，让人家帮你拉一下，所以叫钩子。 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:2","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"环境 Git ，这个服务器上肯定要装的 nodejs ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:3","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"配置公钥 配了公钥后，你打git clone (repo地址)就不用输入密码了。这个很简单，网上教程很多。 有个小坑：配完公钥后git仓库地址一定要用ssh，而不是https 成功的结果就是你打git clone的时候不用输入密码了 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:4","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"用nodejs监听web-hooks服务 创建目录，用npm初始化，下载插件gitee-webhook-handler（ps:用了nodejs才发现它有很多好用的插件： mkdir /usr/soft/web_hooks #创建目录 cd /usr/soft/web_hooks npm init npm install gitee-webhook-handler --save 创建js文件，按照自己的需求修改： var http = require('http') var createHandler = require('gitee-webhook-handler') var handler = createHandler({ path: '/webhooks_push', secret: '654321'}) //post 所需要用到的密码，自己设置，跟下面对应就行 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) { resp += buffer.toString(); }); child.stdout.on('end', function() { callback (resp) }); } handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('Push Hook', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); var name = event.payload.repository.name //这个name是仓库的名字 if (name === \"Gitee FeedBack\" || name === \"xaiweb\") { run_cmd('sh', ['/www/xaiweb/pull.sh'], function (text) {// 需要执行的脚本位置 console.log(text) }); }else { console.log(\"unknow repository name:\" + name); } }) try { http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6666) // 服务监听的端口，可以自行修改 }catch(err){ console.error('Error:', err.message) } 原博主的这里的name没有定义，看日志才发现问题。 还有个小坑，如果你用gitee的话，push代码和点击“测试”的时候name的值是不一样的。前者是\"Gitee FeedBack\"，后者是仓库名。（我的仓库名xaiweb gitee和github应该也不一样，总之，测试的时候多看日志，就能发现问题。（日志下面有 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:5","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"启动服务 下载forever，这个能解决node服务自动停掉的问题。-g是全局安装 npm install -g forever 把nodejs目录下的forever软链接到系统的/usr/bin目录下，这样就能全局访问了 ln -s /usr/local/node(这里可能不一样)/lib/node_modules/forever/bin/forever /usr/bin/forever 不知道nodejs目录在哪的打whereis node或者which node试试，注意，这样找到的目录可能不是原始目录，而是软连接目录。 启动： forever start -l ./forever.log -o ./out.log -e ./err.log webhook.js #第一次启动 forever start -a -l ./forever.log -o ./out.log -e ./err.log webhook.js #之后再启动打这个 这里给两个forever常用命令 forever list #列出服务，能看到日志在哪 forever stop + id或文件名 #停止服务 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:6","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"nginx反向代理 location ^~ /webhooks_push { proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:6666; } 如果你不会nginx也没啥问题，直接用ip:6666也行 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:7","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"gitee配置 密码就是跟上面那个对应的。 大功告成。 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:8","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"1月31日补充 如果用GitHub： //webhook.js var http = require('http') var createHandler = require('github-webhook-handler') var handler = createHandler({ path: '/', secret: '密码' }) // 上面的 secret 保持和 GitHub 后台设置的一致 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function (buffer) { resp += buffer.toString(); }); child.stdout.on('end', function () { callback(resp) }); } http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6666) handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('push', function (event) { console.log('Received a push event form %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./pull.sh', event.payload.repository.name], function (text) { console.log(text) }); }) 请求：http://ip:6666/ content type: application/json ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:9","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["随笔杂记"],"content":"读书和锻炼 书大概看了15本。书\\影评10个。 书看的多没用，写书评才是有用的，明年多写书评。 跑步202公里。明年继续。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"明年的计划 没什么计划， 就是继续读书、继续锻炼。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"大学 唯读书和锻炼二事不可辜负。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["书影记录"],"content":"明天也是小春日和 英子内心一直有一个田园梦，他的丈夫修一是建筑师，年轻时工作十分忙碌，但她始终支持丈夫的志愿。退休后，修一履行他的承诺，带着英子乔迁田野，在这里植树，建屋，耕作。 “小春日和”在日语中意指“晚秋到初冬里阳光和煦的好天气”。本书介绍了相伴走过近六十年的老人，在以自然为友，彼此相伴的每一天里，都是小春日和。 春有枝头新绿，秋有红叶满园，夏天茂盛的枝叶遮挡住阳光，带来纯天然的清凉，冬天落叶覆地，暖阳西照。一年四季，这片树林静静地守护着津端一家。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:1","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"“吃”是人生最重要的部分 英子女士记得小时候母亲经常亲手为家里人做面包等美味，并教导自己的女儿：“民以食为天，‘吃‘是人生中最重要的部分“。“吃”不仅是生活中最重要的部分，也是本书最重要的部分。在本书的众多插图中，一半以上都是跟“吃”有关的。 春天里，修一先生亲手用月桂熏制培根，伴随着四溢的香气与客人高谈畅饮；夏天，早餐的主食是刚从菜园采摘的玉米，放在庭前的七厘炭炉烤熟，再配上新鲜的蔬菜鸡肉沙拉，格外好吃；秋天，秋栗做成的栗金团味道自然甘怡，炖的烂熟的牛肉是滋补暖身的佳肴；到了冬天，先过新年再过生日，餐桌摆上了堪称豪华的料理，有烤全鸡、水果沙拉、年节菜和杂煮，每天都在吃大餐。除此之外，四季之中还有拌入艾草的捣年糕，鲜红欲滴的草莓酱，清凉爽口的大麦茶，看到就想流口水的梅干，别有一番风味的柚饼子和修一先生最爱的帕玛森干酪咸饼干。所有的美食都是亲手烹饪，厨具叮叮当当的声音是生活最美妙的伴奏。 春季大餐的必备菜是修一先生亲手熏制的培根。经历过无数次失败后，他终于摸索出了制作方法。往砖块搭成的熏炉里加入炭火，吊三块猪肉，用月桂等熏烤，有时会换种香叶，并没有特别的独家秘方。客人们伴着熏烤时飘出的香气畅饮高谈，正是所谓 “男人间的待客之道”。 美食与生活密不可分，会制作美食的人一定是会享受生活的人。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:2","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"可爱的修一先生 喜欢记录自己的生活： 修一先生非常擅于整理归纳，所做记录之详细，更是体现出他身为建筑师的职业素养。 是一个细心的“理工男”： 英子女士的性格粗枝大叶，修一先生却是个标准的“理科生”，凡事讲求细节，连文件夹封皮的颜色都十分讲究。 对新鲜事物永保热情： 修一先生永远保持着对外界新事物的热情。除了喜欢驾驶帆船，他在日本大地震发生后，曾坚持收集相关报道并剪辑成册；他还想淘一个工台，把粗木加工成器皿，把“自娱自乐”对精神发挥到极致。 认真的做每一件事： 英子女士笑着说：“修一打的邮包整齐漂亮，我就没那么细心了。““这个要放进去吗那个怎么弄？”修一先生边跟英子女士。确认，边细致地打包。 … ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:3","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"宁静的生活，时间一晃而过 穿林而过的秋风渐带凉意，夫妇二人开始更换家中的起居用品。为即将到来的冬天做准备。 橱柜里摆放的玻璃器皿换成了稳重而温润的陶器，床单、靠垫套则从棉麻布换成了蓬松柔软的毛织品。整间居室更显温暖舒适，老两口可以安心度过整个冬天。 从高高的东窗射人的晨光不知不觉落下，时间一晃就过去了。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:4","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["随笔杂记"],"content":"今天跟基友探店，找到一家主机游戏。 我俩对着超大屏幕玩双人成行玩一个小时笑一个小时。 老板说别人玩这个都对骂，就你俩一直笑。 我跟老板说这才是男人的默契。 去你妈的腾讯游戏，什么是游戏？这TM才叫游戏！ 不比女朋友好玩一百倍？ ","date":"2022-01-15","objectID":"/posts/%E8%B7%9F%E5%9F%BA%E5%8F%8B%E7%8E%A9%E5%8F%8C%E4%BA%BA%E6%88%90%E8%A1%8C%E8%BF%99%E8%BE%88%E5%AD%90%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E8%BF%87/:0:0","tags":null,"title":"跟基友玩双人成行这辈子没这么开心过","uri":"/posts/%E8%B7%9F%E5%9F%BA%E5%8F%8B%E7%8E%A9%E5%8F%8C%E4%BA%BA%E6%88%90%E8%A1%8C%E8%BF%99%E8%BE%88%E5%AD%90%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E8%BF%87/"},{"categories":["随笔杂记"],"content":"2020期末复习有感： 每门课复习时都要有一个抓手，这个抓手一定要足够可靠可信赖，它是你复习最主要的线索，当你把这条线索都走一遍后你要能自信的说你复习完了。 什么可以成为抓手呢？比如每次布置的作业，最好每次都自己写，写完不要随便一夹，要装订成册。再比如课本，平时就要通读，复习的时候再重新捋一遍。 这学期的线代和数电就没有抓手，复习的时候非常痛苦。手边的复习资料很多（没读过的课本，不配套的试卷，乱七八糟的习题），但很乱，不知道看哪一个，感觉知识点都是碎的，复习起来很没有动力，根本坐不住。这样复习不仅低效，而且很容易放弃。最后还是拿了别人的习题来当抓手。 ","date":"2022-01-15","objectID":"/posts/%E6%8A%8A%E5%8A%9F%E5%A4%AB%E7%94%A8%E5%9C%A8%E5%B9%B3%E6%97%B6/:0:0","tags":null,"title":"把功夫用在平时","uri":"/posts/%E6%8A%8A%E5%8A%9F%E5%A4%AB%E7%94%A8%E5%9C%A8%E5%B9%B3%E6%97%B6/"},{"categories":["随笔杂记"],"content":"十分精美的证书+《深度学习》+一双蓝色的袜子+单片机身份卡 最最最帅的就是这个单片机身份卡，太你妈的炸裂帅了 说实话，我真没给百度做过什么事情，以后也很难，有点愧对百度。 ","date":"2022-01-14","objectID":"/posts/%E7%99%BE%E5%BA%A6%E5%AF%84%E7%9A%84%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A4%BC%E5%93%81%E6%83%8A%E5%96%9C/:0:0","tags":null,"title":"百度寄的证书和礼品，惊喜！","uri":"/posts/%E7%99%BE%E5%BA%A6%E5%AF%84%E7%9A%84%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A4%BC%E5%93%81%E6%83%8A%E5%96%9C/"},{"categories":["随笔杂记"],"content":"今年过年早，复习周被压缩到了元旦三天，接下来一个星期要考5门试。分别是大物、线代、数电、英语、Java。后两者还好说，比较容易复习。前三者真是让我苦不堪言，尤其是线代，复习到现在已经非常疲惫了，但还是心里没底，还好复习时有秀儿陪着我，不然我真撂挑子不干了。 看来功夫还是得用在平时。50个学时以上的课，一定要好好做平时作业qwq ","date":"2022-01-05","objectID":"/posts/%E5%A4%8D%E4%B9%A0%E5%91%A8%E8%8B%A6%E4%B8%8D%E5%A0%AA%E8%A8%80/:0:0","tags":null,"title":"复习周苦不堪言","uri":"/posts/%E5%A4%8D%E4%B9%A0%E5%91%A8%E8%8B%A6%E4%B8%8D%E5%A0%AA%E8%A8%80/"},{"categories":["随笔杂记"],"content":"2021-12-10 从小到大，我都生活在家人为我打造的蜜罐温床里。他们爱我，处处为我考虑，给予我他们所拥有的一切，而我一味的索取，从不想过回报，把被爱当作了一种理所应当。 所以我从来没有培养出爱人的能力，我不会心疼别人。不会在下雨天提醒人打伞，不会在降温时提醒人多穿衣，不会特意记下别人的生日，不会给人买奶茶，不会没事就想给一个人打电话，不会随时就想知道人家在干什么，不会请人吃饭，不会给人挑礼物，不会把别人的开心当作自己的开心。我只想过我自己，我是个利己主义者。 当我没有学会拥有爱的能力时，我认为世界是轻浮的，势利的。我认可 “ 天下熙熙皆为利来，天下攘攘皆为利往 ” ，却不认可 “ 人间有真情，人间有真爱 ” 。我把人际关系当成交易，我认为既然我帮助了你，那么你也得帮助我，最好谁都不欠谁的人情。我从来没体会到无私奉献的感受，也不知道为什么要无私奉献。 但当我遇见了你，我发现我在正在学会拥有爱的能力。爱这种东西，好像是埋藏在泥土里的一颗种子，它一直隐藏在深处，直到我遇见了你，它轻悄悄的萌芽了。 当我开始学会拥有爱的时候，我发现这个世界并不是如我原先认为的这般轻浮。正是由于爱的存在，这世上很多超出理性的感情，比如母子之间的感情，比如情人之间的感情…都能解释得通了。 但我在拥有爱这方面，仍然是个小白，以后还要努力学习！💪 ","date":"2021-12-20","objectID":"/posts/%E5%AD%A6%E4%BC%9A%E6%8B%A5%E6%9C%89%E7%88%B1%E7%9A%84%E8%83%BD%E5%8A%9B/:0:1","tags":null,"title":"学会拥有爱的能力","uri":"/posts/%E5%AD%A6%E4%BC%9A%E6%8B%A5%E6%9C%89%E7%88%B1%E7%9A%84%E8%83%BD%E5%8A%9B/"},{"categories":["随笔杂记"],"content":"2022-02-04 每个人都应该有平等享受爱的权利，当我在付出我的爱的时候，我也渴望获得爱。我付出爱的同时，可能也付出金钱、物质，这些都不重要，重要的是这些金钱、物质是包含在我的爱中的。我渴望获得的爱，不一定包含金钱、物质，哪怕只是一句嘘寒问暖，只要它是爱，我就能满足了。 我一直在付出爱却得不到回报的爱的时候，我会感觉很累。我快坚持不下去了… ","date":"2021-12-20","objectID":"/posts/%E5%AD%A6%E4%BC%9A%E6%8B%A5%E6%9C%89%E7%88%B1%E7%9A%84%E8%83%BD%E5%8A%9B/:0:2","tags":null,"title":"学会拥有爱的能力","uri":"/posts/%E5%AD%A6%E4%BC%9A%E6%8B%A5%E6%9C%89%E7%88%B1%E7%9A%84%E8%83%BD%E5%8A%9B/"},{"categories":["书影记录"],"content":"图书简介 《史蒂夫·乔布斯传》是美国作家沃尔特·艾萨克森为苹果公司创始人史蒂夫·乔布斯所作的传记，记录了乔布斯从童年开始，到卸任苹果公司CEO所发生的故事。该书是乔布斯唯一授权的传记，但乔布斯从未干涉艾萨克森的写作，甚至乔布斯从来没有阅读过本书，因此相比于其他名人的传记，本书更加客观真实。它为我们提供了一个毫无掩饰的视角，充分展现了一个“伟大的乔布斯”和“讨厌的乔布斯”。有人说，天才在左，疯子在右，这两种属性是如何在缠绕在同一人身上的呢？想知道的话就翻开这本书吧。 我非常崇拜乔布斯，因此阅读这本书给我的感觉就像是在知心的朋友进行一场畅快的交谈。我要把打动我的句子拒录下来： ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"摘抄及感想 “如果你不忙着求生，你就在忙着求死” 你必须不断地去推动创新。迪伦本来可以一直唱抗议歌曲，可能会赚很多钱，但是他没有那么做。他必须向前走，1965年在民谣中融入电子音乐元素时，他疏远了很多人。1966年的欧洲巡演是他的巅峰。他会先上台演奏原声吉他，观众非常喜欢。然后他会带出The Band乐队，他们都演奏电子乐器，观众有时候就会喝倒彩。有一次他正要唱《像一块滚石》，观众中有人高喊“叛徒”，迪伦说：“搞他妈个震耳欲聋！”他们真那样做了。披头士乐队也一样。他们一直演变、前行、改进他们的艺术。那就是我一直试图做的事情——不断前进。否则，就如迪伦所说，如果你不忙着求生，你就在忙着求死。 乔布斯的一个商业原则就是：永远不要害怕内部相残。他说：“与其被别人取代，不如自己取代自己。”（If you don’t cannibalize yourself，someone else will.）所以，即使iPhone的出现会蚕食iPod的销售，或者iPad影响了笔记本电脑的销售，都没有阻碍他的想法。 迪伦是乔布斯最喜欢的歌手，迪伦的歌曲一直在革新，苹果公司也一直在革新。iPod曾是苹果最成功的产品，但当乔布斯意识到iPod会被手机取代后，他做出了iPhone取代了自己的iPod。有人说，革别人的命容易，革自己的命难。我们见过太多取得了成功后就固步自封的例子，而苹果公司却能一往无前，与其让别人革自己的命，不如自己革自己的命。 “人们不知道想要什么，直到你把它摆在他们面前” 有些人说：“消费者想要什么就给他们什么。”但那不是我的方式。我们的责任是提前一步搞清楚他们将来想要什么。我记得亨利·福特曾说过，“如果我最初问消费者他们想要什么，他们应该是会告诉我，‘要一匹更快的马！’”人们不知道想要什么，直到你把它摆在他们面前。 这是乔布斯最经典的话之一。亨利·福特造出汽车之前，人们只知道骑马。乔布斯造出iPhone之前，人们也没有使用触摸屏的需求。乔布斯的伟大之处就是他总是能洞见未来，没有需求就创造需求，这可不是一般人具有的天赋。 有一次在他进行深度麻醉时，胸科医生要往他脸上戴麻醉面罩。乔布斯把面罩扯掉，嘟囔着说他讨厌这个面罩的设计，拒绝戴它。虽然他几乎无法说话，但他还是命令医生拿来五种不同的面罩，选出一个他喜欢的。 这是乔布斯在接受癌症治疗的时候发生的故事。可以看出乔布斯的完美主义已经深入骨髓，甚至把设计看作比生命还重要。 “你是想卖一辈子糖水呢，还是想抓住机会来改变世界？\" 斯卡利后来讲述了接下来那个最为激动人心的时刻，“史蒂夫低着头，看着自己的脚。在一段沉重的、尴尬的沉默之后，他向我抛出了一个问题，让我几天都无法释怀，‘你是想卖一辈子糖水呢，还是想抓住机会来改变世界？’” 斯卡利回忆说，感觉就像有人往他的肚子上狠狠揍了一拳，除了默许，他无言以对。人人都曾怀揣过伟大的梦想的火种，但大多数人都被世俗浇灭到奄奄一息了。乔布斯是少数保留火种的人之一，他想拉斯卡利入伙，用一句\"你是想一辈子糖水呢，还是想抓住机会来改变世界？“唤醒了斯卡利的内心的火种，就像是用一根火炬点燃了另一根火炬。 他拒绝使用CEO专有车位，却霸占了残疾人停车位。他希望被（他自己和其他人）看成一个愿意为1美元年薪工作的人，却又希望得到大笔的期权。从一名反主流文化的叛逆者变为一名商业创业者，他自身充满了矛盾。他希望在心灵上得到的启迪和感悟，与他通过股票和期权获得的财富并无关联。 读到这段话，我太感同身受了。我想问问读者，你觉得你是一个矛盾的人吗？你活成了自己讨厌的人吗？我的回答是：既是，也不是。你不得不承认你的目光有限，思想在变，当年你认为对的事，现在不一定认为是对的。 他说：“当1999年Adobe背叛了我们之后，我的第一个想法就是，在我们所涉足的任何领域，必须要同时控制硬件和软件，否则我们迟早要受制于人。” 你一定有过类似的经历，你把事情交给别人来做，结果别人不付吹灰之力把它搞砸了…很多优秀的程序都是一个牛逼的程序员自己开发出来的，因为这样才能保证作品有完美的整体性，而合作往往只能做出中规中矩的作品。 “我们苹果的员工已经忘记了自己是谁。要回想起你是谁的方法之一，就是要想起你的偶像是谁。这就是那次宣传活动的缘起。” 我们喜欢在QQ空间里发自己的偶像，不就是为了给自己打标签吗？你想成为一个什么样的人，回答这个问题的参考资料首先是你的偶像。 “Windows赢了。”他说，“很不幸，它打败了Mac，打败了Unix，打败了OS/2。一个低劣产品胜出了。” 乔布斯说这句话的时候特别的无奈。哈哈，正义并不总是能战胜黑暗。 “我们相信，苹果有道德责任让色情远离iPhone，”乔布斯在回复一位消费者的邮件中写道，“需要色情的人可以用安卓。” 乔布斯坚持把苹果打造成有道德有底线的公司，并且尽可能避开政治斗争、地域歧视。在隐私保护、无障碍功能上，苹果一直都是行业标杆。苹果公司位于美国，但苹果是属于世界的。 Mac发布当天，来自《大众科学》（Popular Science）的一位记者问乔布斯做过什么类型的市场调研工作。乔布斯语带嘲讽地回应：“亚历山大·格雷厄姆·贝尔在发明电话之前做过任何市场调研吗？” 取得成功后，把自己跟先贤贝尔相提并论，我就喜欢他这种拽拽的样子。人生得意须尽欢，当我得意的时候我也要这样拽一下。 ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"苹果的产品 苹果是以产品为核心的。苹果产品的设计简洁为原则，简洁是为了实用，而不是牺牲实用性才做到的简洁。苹果的产品能让人一眼看出使用逻辑，一个5岁的孩子不用教就能学会玩iPad，这正是苹果的目的。不仅是实用，还要尽可能的优雅，在各方面注入美学。这样的产品能让人产生使用的欲望，而不是为了生计不得不去使用的工具，苹果想让使用他们产品的顾客的生活变得美好，而不是变得繁琐。 初上手苹果的产品，你并不觉得它很惊艳，苹果的确不会像其他品牌那样制造噱头去吸引你。但当你实际使用一段时间，当你沉浸在丝滑的交互中，再把它与其它产品比较时，你会发现其它产品是多么幼稚。苹果就像是一位特别可靠的父亲，他为你考虑到了处处细节，让你有足够的舒适感和安全感，同时又在用他的魅力激发你的创造力。它的惊艳是落到实处的，一直使用你就会一直被惊艳。 ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"起因 从大一我刚做昕哥的学生开始，他就建议刚学完c程序设计的我趁热打铁，去考一个ccf csp认证。我当时对算法不感兴趣，也没参加acm，就没有关注这个认证。 结果没想到昕哥主持了今年的csp认证，考点就在我们学校。昕哥当然首先拉我们参加，还说给我们报销费用，让我们先垫着。（估计是不会给报销了qwq）这怎么好拒绝呢，考一个试试！ ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考前 在考试前一周，我甚至对这个考试一无所知。直到前三天，我才多方面打听到了ccf csp认证没有通过/不通过的概念，只有分数。一共五道题，满分500分，每年的平均分在150分左右。往年在青岛大学有考点，但在咱们学校举办的次数很少。我知道自己就是去考着玩的，但还是花了点时间准备一下。 我做了往年的题目，发现这题目出的还挺有意思。第一题一般是热身题，很easy。第二题也不难，用暴力方法可以做到70分，拿满分需要用到一些算法。第三题是阅读理解题，特别长，但也不涉及很多算法。第四题和第五题会考到树、图等数据结构，第五题就是究极难题了，很少有人能做出来。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考中 中午没睡觉，从1:30考到5:30，四个小时注意力集中。这酸爽，就好像是做了一晚上的噩梦一样。 考完特别的累，晚上又去考英语六级模拟，考完腰就顶不住了。 但是我特别享受考试的过程！ 无论是在准备考试，还是正式考试，我都特别享受那种专注的感觉。绞尽脑汁，花了好长时间，写出了代码，提交拿到了分数的那种喜悦，真是太棒了，就好像是一口气看完一本悬疑小说！ 我觉得这才是本科生该干的事情。一个人，一台电脑，就能在图书馆呆一晚上。比起做项目来说，这是非常舒服的事情，做项目不仅累，而且要操心的事情特别多，更可怕的是还要忍受傻逼队友。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考后 我特别想把对算法的研究继续下去，就怕客观条件不足，我自己意志力又不够强，坚持不下去。 我觉得我要继续研究算法，就是要多做题，搞算法的离开了做题都是扯淡，只有做题是实在的。 真的真的希望我能渐次下去。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"包含几乎所有课堂上讲的题目 ","date":"2021-12-01","objectID":"/posts/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"数值计算方法","uri":"/posts/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"今天在线上听了西交的孟德宇教授的小讲座，非常亲切朴实，真正的打动了我。 如何写好论文 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:0","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"细节，careful 不要有typo 不要用长句 避免过度修饰，冗长 至少修改30遍 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:1","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"逻辑通顺 写提纲 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:2","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"理论、实验点支撑 支撑什么观点？从哪些角度？ ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:3","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"讲一个合理的故事，前呼后应，自圆其说 拍电影 宁浩《疯狂的石头》、《疯狂的赛车》、《我不是药神》 张艺谋（不讲逻辑） 拒绝言过其实、过度包装、前言不搭后语 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:4","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"花时间认真挑选研究方向，科研问题 拒绝incremental Large margin策略，从0到1，从粗糙到细致 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:5","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"理解，深刻，洞察（insight） ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:6","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"不必随大流，make difference 《Embedded vision summit 2018》 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:7","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"深入思考，长远打算 小问题 本质性，创新性，冷门性，可用性 考虑好未来系统框架 一个好的论文一定是小的，朴素的 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:8","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"四个建议 多做报告、精心准备报告slides 参与社交活动 三句话概括自己的研究方向 让外行人理解 大智若愚、大道至简 拒绝诱惑、不要以功利的目标做科研、不要丢失情怀 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:9","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"举重若轻、游刃有余 当成一种体验而去好好感受 无为而无不为 讲一个能够满足和感动自己的故事！ ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:10","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["技能分享"],"content":"起因 傻逼Mac，每次开屏幕都要重新输入账号密码运营商连接校园网，所以我想办法用脚本去实现连接校园网的操作。 mac可以直接运行shell脚本，写一个超级简单的脚本放在桌面，每次点一下就可以自动连接校园网了。 ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:1:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"第一步 从GitHub上下载一段自动连接校园网的python代码，地址：https://github.com/UPCUnofficial/UPCNet 然后解压，修改其中config.py文件。 在config.py文件下输入学号、密码和运营商编号，然后运行 python3 NetworkAuth.py 运营商对应编号： default -\u003e 校园网 unicom -\u003e 联通 cmcc -\u003e 移动 ctcc -\u003e 电信 local -\u003e 校园内网 再用终端cd进入该文件夹，pip install 所依赖的库。 运行代码。(以上所述在readme里都有） python3 NetworkAuth.py 成功啦！ ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:2:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"第二步 用文本编辑器创建一个文件，里面打上这行代码： python 你的路径/NetworkAuth.py 将文件重命名为XXXX.sh 然后右键—\u003e打开方式—\u003e其它—\u003e所有应用程序—\u003e终端 然后把它放在桌面，每次等连上wifi后点一下就能连接校园网啦。 ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:3:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"问题描述 如图，有一天在push的时候要求输入Username和Password，输入了GitHub登录名和密码后，提示“鉴权失败”。 ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:1","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"解决方案 看它给的提示，Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. 2020年7月，我们宣布打算要求对所有经过身份验证的Git操作使用基于令牌的身份验证（例如，个人访问、OAuth或GitHub应用程序安装令牌）。从2021年8月13日开始，在GitHub.com上验证Git操作时，我们将不再接受帐户密码。 也就是说输入的Password不是登录密码，而是这个Access Token！另外，Username也不是用户名，而是登录邮箱。 获取个人Access Token的方法：https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 记得一定要把repo的权限勾选上 ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:2","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"在命令行上使用令牌 一旦您拥有了令牌，在通过HTTPS执行Git操作时，您可以输入令牌而不是密码。 例如，在命令行中，您将输入以下内容： $ git clone https://github.com/username/repo.git Username: your_username Password: your_token ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"后续 怎么把Access Token添加到环境变量里呢？ ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:1","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["随笔杂记"],"content":"我的第一台macbook 犹豫了一年，终于在2021年11月份买了这台m1版本的macbook air。非常感谢我哥借给我不敢想象的8k块。 精准 在很多人眼里macbook只是个花瓶，不能打游戏，不能装专业软件，价格还死贵。但是在我眼里，它精准的满足了我的需求： 不打游戏 轻薄的机身、超长的续航，我可以带出去一整天（这个很重要！ 堪比pro的性能 类unix系统，舒服使用终端 没有风扇，安静写代码 非常出色的屏幕，长时间看都不累 基本适配软件开发所需的软件 恰到好处的装逼 实际上，这台m1的MacBook Air可能是苹果最具性价比的电脑之一，学生党完全可以考虑入手！ 优雅 对于计算机专业的学生来说，电脑就是老婆。而这台macbook就如一个俄罗斯美人，不仅干活猛，还好看。希望使用这台优雅的电脑能帮助我改掉以前在windows上养成的坏习惯，比如资料胡乱放。 ","date":"2021-11-14","objectID":"/posts/%E7%B2%BE%E5%87%86%E8%80%8C%E4%BC%98%E9%9B%85macbook-air/:0:0","tags":null,"title":"精准而优雅——MacBook Air","uri":"/posts/%E7%B2%BE%E5%87%86%E8%80%8C%E4%BC%98%E9%9B%85macbook-air/"},{"categories":["技能分享"],"content":"网上教程大多都是说下载微软雅黑字体到系统文件夹，然后更改matplotlib的配置文件。实际操作过程发现更改系统文件夹需要权限，而且matplotlib的配置文件也和网上说的不一样。 后来参考了：https://www.cnblogs.com/cymwill/p/10554916.html ","date":"2021-11-12","objectID":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:0","tags":null,"title":"macOS下matplotlib无法显示中文字体问题解决","uri":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"解决方法 找到字体路径 import matplotlib print(matplotlib.matplotlib_fname()) 进入该路径然后编辑文件matplotlibrc可以直接在最下面加上三行： font.family: sans-serif font.sans-serif: Arial Unicode MS, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif axes.unicode_minus: False 然后把~/.matplotlib目录下的两个文件删除掉（缓存文件可以放心删）：  rm -rf ~/.matplotlib/* 重启python，并引入字体 plt.rcParams[‘font.sans-serif’] = [‘Arial Unicode MS’] 即可解决中文及负号无法正常解决的问题。 ","date":"2021-11-12","objectID":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":null,"title":"macOS下matplotlib无法显示中文字体问题解决","uri":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"如下图，在英语朗读视频中添加文稿可以让刘老师清晰地看到你读的每一个单词，更准确地判断你的朗读水平，从而对你进行更好的指导。那么如何在英语朗读视频中添加文稿呢？ 你所需要用到的工具是剪辑软件，下面推荐几个很好用的剪辑软件： ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:0:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"1.剪映（电脑和手机） 你可以把你的视频直接拖拽到导轨上，然后再把文稿以图片也拖拽进来。控制好每张图片时间区间，使其与你的视频对应。不到五分钟，你就可以处理完你的视频。 剪完后，点右上角导出视频，你可以像我一样使用下图的参数，这样你能得到一个清晰度够用但是占用内存特别小的视频。 剪映的下载地址（官方）：https://lv.ulikecam.com/?_s=4 在剪辑时，运用分割、分离、变速、快捷键等技巧会让视频更完美，你可以在b站学习这些知识。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:1:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"2.花瓣剪辑（手机） 用手机也可以剪辑。花瓣剪辑是华为手机自带的剪辑软件。操作逻辑和剪映一样。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:2:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"3.Premiere（电脑） ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:3:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"4.final cut pro（苹果电脑） ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:4:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"5.iMovie(ipad) ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:5:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"…… 工具其实都一样，选择一个称手的就好。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:6:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["随笔杂记"],"content":"大一的时候，看到这个社团感觉就很对胃口，想加入。但是Linux自由软件协会太低调了，那年的百团大战我都没找到摊位。 大二阴差阳错，我直接从局外人成了会长。 起因是我当了飞桨领航团团长，要借一个社团办线下活动，没人愿意跟我合作。 陈荣灿学长跟我都是李昕老师的学生，我问他可不可以合作办一个活动，他说正好现在社团换届，直接把会长给我了。 现实真的比小说还魔幻，小说是讲逻辑的，现实不讲逻辑。 换届现场 我还把王文婕、廖集秀拉来了。很多事情有女生来做的话是很合适的。还拉了一个刘原歌，他对学校的部门事务比较了解。 然后就顺理成章的搞了百团大战活动，搞活动之前我还被社团管理部的老师约谈，因为学校不允许和外部企业合作，让我避讳“百度”。我照做了，不过从此之后我也下定决心不想再给百度干活了。 然后紧接着下周就要准备新生见面会。由我来主持，顺便讲一节课。 我对待这次见面会＋课程，是非常认真的。因为我真的把这次当成很好的锻炼机会。为了准备这个，确实花费了一些心血，开始前可以说是寝食难安。 现场的效果很不错。我真的没想到能来这么多人（94个），教室快坐满了，室友和同学很给面子，都来了。 我表现的也很不错，讲了一节课，全称吹牛逼吹得都很流畅。 为一件事准备的越多，收获的也越多。不能做“佛系青年”，不愿意挑战自己。也不要给自己增加焦虑，什么都想做好，搞太大压力。要践行一种中庸之道，有的放矢，分清主次。 这两周我太累了，同时收获也太多了。 ","date":"2021-10-30","objectID":"/posts/linux%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%8D%8F%E4%BC%9A%E8%BF%8E%E6%96%B0%E7%BB%93%E6%9D%9F%E6%9C%89%E6%84%9F/:0:0","tags":null,"title":"Linux自由软件协会迎新结束有感","uri":"/posts/linux%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%8D%8F%E4%BC%9A%E8%BF%8E%E6%96%B0%E7%BB%93%E6%9D%9F%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"思路 先安装Python版本管理器pyenv 再用Pyenv安装Python ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:1","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"安装pyenv 标准安装：找到项目地址pyenv/pyenv: Simple Python version management (github.com) 先git clone，再配环境变量。 作者还提供了一个自动安装的脚本，只需一行命令。 失败！因为国内云主机墙了github（真是emo了 我的方法： 参考https://blog.csdn.net/m0_37616927/article/details/108770185 从gitee上下载pyenv: git clone https://gitee.com/ibuki_fuuko/pyenv.git ~/.pyenv 会把pyenv下载到当前用户的～/.pyenv目录下 再把以下内容加到~/.bashrc 里，没有就新建 export PATH=~/.pyenv/bin:$PATH export PYENV_ROOT=~/.pyenv eval “$(pyenv init -)” 激活 source .bashrc 安装成功，可以看到pyenv提供可安装的python版本 pyenv install –list ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:2","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"安装python 标准思路：直接pyenv install 3.7.5 就能一键安装Python了 失败！因为Python镜像默认是从官网下的，国内网络上不去（再次emo 这之后我就开始瞎捣鼓了，参考： https://blog.csdn.net/yxiaom/article/details/103468954 找了一个国内的镜像地址： http://npm.taobao.org/mirrors/python/ 安装Python之前需要安装很多依赖，多用apt装一装 最后查看一下已安装的Python版本 pyenv versions 然后设置默认版本，这样你打python的时候默认使用这个版本 pyenv global 版本号 最离谱的是，我尝试这个命令没有成功，什么都没做，到第二天居然可以了（第三次emo 没想到在linux上装Python比在Windows上难的多，win上装一个anaconda就能解决所有问题 ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:3","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"懒人方案 装一个宝塔面板，安装Python就比较方便了，但是也失去了学习的价值 ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:4","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["书影记录"],"content":"时间 2021年国庆期间，10月3日至5日。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:1:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第一站：翡翠谷 翡翠谷是一个很经典的景点。据说是1988年有36位来自上海的青年男女邂逅于这条峡谷，当时景区尚未开发，他们一路上互相搀扶，克服重重困难，最后有10队成了情侣，所以翡翠谷又名情人谷。 翡翠谷是一条长长的峡谷，一路走进去有很多大大小小的水潭，潭水清澈见底，都是碧绿颜色。但是碧绿程度不一样，有的颜色深，有的颜色浅，像是不同品种的翡翠，因此得名翡翠谷。 此景点对体力的消耗很小，如果你像我一样第二天准备爬黄山，第一天很适合来翡翠谷转一转。最大的缺点就是只有一条路，走进去之后还得原路返回。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:2:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第二站：黄山 首先，对于黄山我是怀着一颗敬畏之心的。记得小学时学过一篇课文，专门讲黄山的奇石，如今亲眼看见，说实话，还真是没那个想象力。但我仍然抱着一颗欣赏的态度去品味黄山的风景。 我们的路线是：汤口镇住宿=\u003e景交车上山=\u003e慈光阁=\u003e坐玉屏索道上山=\u003e莲花亭，迎客松=\u003e一线天=\u003e白云宾馆=\u003e光明顶=\u003e白云宾馆=\u003e坐网红小火车（缆车）=\u003e西海大峡谷（没有游玩）=\u003e网红小火车=\u003e白云宾馆=\u003e第二次上光明顶=\u003e观石亭（观87红楼梦飞来石）=\u003e白鹅岭=\u003e一路走下山去 我们没有按旅行团规划的路线走，中间想去一次西海大峡谷，但是坐了网红小火车去了之后感觉没有体力游玩了，于是原路返回。没有爬黄山最高峰莲花峰，但是爬了两次光明顶。 下山后，大多数人走路都不太正常，一瘸一拐的。我和我妈看到人们踉踉跄跄的样子都觉得很好笑。 可能是一天时间比较短参观景点少，也可能是国庆节人太多心烦意乱，下山回来后，很多旅客都觉得黄山的风景没有想象中那么震撼，有点失望。但我觉得，这次开了一个好头，赶上了大晴天，我的体力也完全够用。黄山是举世闻名的大景点，以后可以再来。 迎客松 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:3:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第三站：宏村 宏村真是太美了（至少从外面看很美）。整个村子被大山包围起来，有碧水萦回，徽派建筑粉墙黛瓦，就像是一幅水墨画。人在地上走，就像是人在画中游。 参观宏村让我了解了徽州文化。徽州到处是山，不能耕作，所以人们行商，后来发展壮大，成为古代的商业中心。徽商的足迹遍布全国，他们赚的盆满钵满，回到家乡建起了独具特色的徽派建筑。士、农、工、商，商是社会的最底层，徽商结交名人，捐钱买官，但还是会受到歧视。徽商重视教育、讲究商业道德、有爱国精神，真是非常值得现在的企业学习。 宏村里面是商业化的，很多麦糕点的店铺，路过门口的时候还有店员往你手里塞糕点，让你试吃。走一圈下来能吃个半饱。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:4:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"其它 还去了一趟谢裕大茶叶博物馆，本质上来说，这个博物馆其实就是搞营销卖茶叶的。但是在里面可以听到很不错的讲解，还会被邀请到房间里白嫖喝茶，一分钱不花也没关系。 回来的路上发生一件胆战心惊的事情。国庆节路上比较堵，连服务区都进不去，大家都很焦躁。因为一些小事，乘客、送行导游和司机吵了起来。最可怕的是这司机也是个暴脾气，直接在高速路上停车要把这个乘客赶下去。好在其它人劝架，把风波平了下去。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:5:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"总结 同样一辆车，同样的旅游路线，心态不同，收获也不同。在回来的路上，我听到身边有乘客在抱怨说这三天一点也不好玩，坐了好长时间车玩的还不开心。我想说的是，我很开心，我开心的原因有两个，一是我很清楚我出行的目的，就是为了脱离舒适区，去感受不一样的风景，接触不一样的人，学习不一样的文化。这个目的已经达到了。二是我善于发现美丽，所以我能拍出很好看的照骗，发到朋友圈里让大家给我点赞。所以我很开心。 最后还是建议大家不要在国庆节来黄山，人真的很多。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:6:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["刷题"],"content":"获奖名单： 排名不分先后，恭喜以上获奖同学。 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:1:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["刷题"],"content":"领奖须知： **第一步：**扫描二维码，注册飞桨人工智能训练平台aistudio（需要手机号） **第二步：**在gitee开源社区上为首家开源国产深度学习框架paddle paddle点个star（如果没有账号，请注册一个） **第三步：**将您的aistudio注册手机号和gitee注册手机号（或邮箱）填入在线表格：【腾讯文档】百度飞桨ai知识竞赛获奖名单https://docs.qq.com/sheet/DY1JBVkR3dmtaR2d1 **第四步：**加qq群：931294105 与群主孙百乐联系领取奖品 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:2:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["刷题"],"content":"其它说明 若想更换奖品，请自行联系其他获奖者，并在备注中写清楚“与XXX更换” 小度雨伞暂时没有到货，请获奖同学等待一段时间 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:3:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["技能分享"],"content":"现在主流浏览器的安全机制就是对非https和localhost的ip拒绝调用摄像头和麦克风。在设置里无法直接更改权限。 其实这是因为浏览器不支持http：IP开头的路径，认为这个路径不安全 浏览器只支持file:,https:,http://localhost， ","date":"2021-09-23","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/:0:0","tags":null,"title":"浏览器不支持getUserMedia","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/"},{"categories":["技能分享"],"content":"解决方法 chrome 地址栏输入：chrome://flags/#unsafely-treat-insecure-origin-as-secure 然后就ok了 ","date":"2021-09-23","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/:0:1","tags":null,"title":"浏览器不支持getUserMedia","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/"},{"categories":["技能分享"],"content":"思路 安装snap 安装certbot 自动配置nginx 完事儿了，确实很方便。具体执行语句访问 https://certbot.eff.org/ 按下图选择环境后就能看到所有执行语句 踩过的坑 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:0","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"配置nginx的时候报错如图 报错的意思就是说，在nginx的配置文件中server_name字段不正确。我把它修改成了aiupc.xyz，仍然报错。 后来问了我哥，才知道nginx配置文件最底下有一行： wordpress真正的配置文件其实是在/usr/local/nginx/conf/vhost文件夹里。把这个里面的server_name改一下就OK了。 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:1","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"server_name不能随意 server_name = aiupc.xyz 和 server_name = www.aiupc.xyz 是不一样的，弄混的话会导致站点一些图片链接浏览器不予显示。 我的解决方案：nginx配置server_name = www.aiupc.xyz，server_name = aiupc.xyz, 域名解析aiupc.xyz和www.aiupc.xyz， certbot给aiupc.xyz和www.aiupc.xyz都申请证书， wordpress后台设置里url写https://www.aiupc.xyz， 这样，在浏览器中打aiupc.xyz也会跳转到www.aiupc.xyz 的，这个问题应该已经彻底解决了。 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:2","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"图像 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:0","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"位图（raster graphics)和矢量图（vector graphics) 位图是有像素的，色彩丰富。矢量图放大不会失真。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:1","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"通道 单通道 灰度图，每个像素点只有一个值表示，如果图像的深度是4-(256 = 2_2_2*2)，那么他的像素值0(黑)~255(白)； 三通道 也就是通过见到的彩色图，每个像素点有三个值表示，如果图像深度是4-(256 = 2_2_2*2),那么他的像素值有红(0~255)、绿(0~255)、蓝(0~255)叠加表示，色彩更加艳丽; 四通道 四通道：也就是在三通道图像基础上加上透明程度，Alpha色彩空间，如果图像深度是4-(256 = 2_2_2*2),那么0是完全透明，255是完全不透明；png图像是四通道。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:2","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"读取图片（numpy的array) import matplotlib.image as mpimg im = mpimg.imread(fname) 读取一张200*200的png图像 im.shape() \u003e\u003e (200, 200, 4) 表示像素是200*200，有四个通道 数组是这个样子： im[0]矩阵，长为200, 宽为4，自己体会一下。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:3","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"显示图片 import numpy as np import matplotlib.pyplot as plt plt.imshow(arr) #根据像素绘制图片 origin表示渐变程度 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:4","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"numpy.array 的shape属性理解 二维情况 \u003e\u003e\u003e import numpy as np \u003e\u003e\u003e y = np.array([[1,2,3],[4,5,6]]) \u003e\u003e\u003e print(y) [[1 2 3] [4 5 6]] \u003e\u003e\u003e print(y.shape) (2, 3) \u003e\u003e\u003e print(y.shape[0]) 2 \u003e\u003e\u003e print(y.shape[1]) 3 可以看到y是一个两行三列的二维数组，y.shape[0]代表行数，y.shape[1]代表列数。 三维情况 \u003e\u003e\u003e x = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[0,1,2]],[[3,4,5],[6,7,8]]]) \u003e\u003e\u003e\u003e print(x) [[[1 2 3] [4 5 6]] [[7 8 9] [0 1 2]] [[3 4 5] [6 7 8]]] \u003e\u003e\u003e print(x.shape) (3, 2, 3) \u003e\u003e\u003e print(x.shape[0]) 3 \u003e\u003e\u003e print(x.shape[1]) 2 \u003e\u003e\u003e print(x.shape[2]) 3 可以看到x是一个包含了3个两行三列的二维数组的三维数组，x.shape[0]代表包含二维数组的个数，x.shape[1]表示二维数组的行数，x.shape[2]表示二维数组的列数。 总结 可以看到，shape[0]表示最外围的数组的维数，shape[1]表示次外围的数组的维数，数字不断增大，维数由外到内。 ———————————————— 版权声明：本文为CSDN博主「Lavi_qq_2910138025」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/liuweiyuxiang/article/details/79384435 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:5","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"numpy的梯度函数np.gradient(f) np.gradient(f):用于计算数组f中元素的梯度，当f为多维时，返回每个维度的梯度。 一维 a = np.random.randint(0,20,(5,))\u003e\u003earray([10, 0, 7, 0, 19]) np.gradient(a)\u003e\u003earray([-10. , -1.5, 0. , 6. , 19. ]) 由梯度计算公式得到梯度计算结果: -10=（0-10）/1 -1.5=（7-10）/2 二维 c = np.random.randint(0,50,(3,5)) \u003e\u003earray([[25, 49, 14, 13, 20], [43, 6, 13, 15, 24], [ 9, 2, 7, 5, 36]]) np.gradient(c) \u003e\u003e[array([[ 18. , -43. , -1. , 2. , 4. ], [ -8. , -23.5, -3.5, -4. , 8. ], [-34. , -4. , -6. , -10. , 12. ]]), array([[ 24. , -5.5, -18. , 3. , 7. ], [-37. , -15. , 4.5, 5.5, 9. ], [ -7. , -1. , 1.5, 14.5, 31. ]])] 对于二维数组，任意一个元素的梯度存在两个方向，所以求得的梯度为两个数组对象，第一个数组表示最外层维度的梯度值，第二个数组表示第二层维度的梯度值。 对于n维数组，gradient函数会生成n个数组，每个数组代表元素在第n个维度的梯度变化值，梯度反应了元素的变化率，尤其是我们在进行图像，声音等数据处理，梯度有助于帮助我们发现图像和声音的边缘，在那些变化不是很平缓的地方，可以很容易的发现。 ———————————————— 版权声明：本文为CSDN博主「June �」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/MachineLearner/article/details/104403097 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:6","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"创建虚拟环境 conda create -n 名字 python=3.8 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:1","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"进入虚拟环境 conda activate 名字 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:2","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"退出虚拟环境 conda deactivate ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:3","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"删除虚拟环境 conda remove -n 名字 --all ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:4","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"查看环境下已有安装包 conda list ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:5","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"查看已有虚拟环境 conda-env list ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:6","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"jupyter notebook使用虚拟环境 安装一个库 pip install ipykernel 往kernel里写入虚拟环境 python -m ipykernel install --user --name 环境名字 --display-name 显式的名字 a 虚拟环境里没有notebook，安装一下 pip install notebook 启动 ipython notebook 在Notebook里更换环境： Kernel =\u003e Change kernel =\u003e 环境名 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:7","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"安装 参考地址：paddlepaddle.org.cn/install/quick?docurl=/documentation/docs/zh/install/docker/linux-docker.html 先安装docker，参考官网 拉取镜像： docker pull registry.baidubce.com/paddlepaddle/paddle:2.1.2-jupyter 运行容器 docker run -d -p 8080:80 --rm --env USER_PASSWD=sbl -v /root/jupyter_docker:/home/paddle registry.baidubce.com/paddlepaddle/paddle:2.1.2-jupyter # -d表示后台运行 # -p端口，指定宿主机的8080端口映射到容器内80端口 # --rm运行完删除容器 # USER_PASSWD=密码 # -v挂载，对应容器内的jupyter目录 这里有个坑，访问ip地址:8080进入notebook的时候，还有一个账号，默认是paddle ","date":"2021-08-29","objectID":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/:0:1","tags":null,"title":"jupyter-paddle使用docker安装","uri":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/"},{"categories":["技能分享"],"content":"容器内安装dlib 更新apt: 在安装 g++ 等工具时 会提示 Unable to locate package build-essential，这种情况下先执行 sudo apt-get update 更新一下， 更新完。继续 sudo apt-get install build-essential 使用apt安装依赖： `sudo apt-get install build-essential cmake` `sudo apt-get install libgtk-3-dev` `sudo apt-get install libboost-all-dev` pip安装 dlib pip install dlib 作者：花花儿 链接：https://www.zhihu.com/question/34524316/answer/182278536 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-08-29","objectID":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/:0:2","tags":null,"title":"jupyter-paddle使用docker安装","uri":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/"},{"categories":["随笔杂记"],"content":" 现在距离开学没几天了，暑假在一起玩的朋友、同学都纷纷开学了，就剩我一个人呆在家越来越无聊。在家里呆腻了，我就在晚上出去走走。一路向西，或一路向北，不到穷尽不回头。这是我第一次用自己的脚步丈量我的家乡城市——蚌埠。 我是一个路痴，我觉得我之所以会成为路痴，不是因为我天生缺少方向感，也不是因为我不出门，而是因为我那疼我的父母。从小到大，去任何地方都是我父母带着我去。去北师大附中上学，去文化广场补课，去百货大楼买衣服，去高铁南站坐车…父母不能送我的，就告诉我坐哪辆公交车，到哪个路口向哪拐弯。我也没有自己在城里溜达的爱好，连东南西北都分不清，更别说弄清楚方位了。 虽然我是土生土长的蚌埠人，对蚌埠的很多地方都特别眼熟，但是在我脑中没有形成空间记忆，不知道这些地方之间的位置关系。总的来说，就是我对这个城市的记忆是碎片化的。  前面说过，这几天我特别闲，就骑了个共享电瓶车自己到外面溜达。第一天，我往北走。先走到红鼎会所，再走到宏业路，看到了财经大学、第二人民医院还有我高考的地方铁路中学，最后到了我的母校师范附属小学，在对面的大润发里买了点吃的。回来的时候我换了条路，故意绕的远一点，走风景不错的环湖西路回家。 第二天，我一路向西。先到了银泰、万达，再到张公山公园，过了桥，还是张公山公园，继续向前就能一路到达北师大附中，但是实在是太远了，而且过于荒凉，我就没去。回来的时候我走的是涂山路，经过了传说中的“田家炳中学”，再经过文化广场，拐两个弯到慕远学校，又回到了东海大道上。 这两天溜达的过程中，我看到了好多好多记忆中熟悉的地点。直到今天，我才彻底弄明白它们到底在哪里。 我家对面的东海大道，可真算蚌埠市的脸面，它连接了太多地方，这些地方承载了我这18年来所有的回忆。如果我是宋冬野，我也能为东海大道写出这样的词： “让我再看你一眼，从南到北。”  我的家乡蚌埠，就让我在离开你之前，重新认识你吧！ ","date":"2021-08-27","objectID":"/posts/%E5%86%8D%E8%AE%A4%E8%AF%86%E6%88%91%E7%9A%84%E5%AE%B6%E4%B9%A1%E8%9A%8C%E5%9F%A0/:0:0","tags":null,"title":"再认识我的家乡——蚌埠","uri":"/posts/%E5%86%8D%E8%AE%A4%E8%AF%86%E6%88%91%E7%9A%84%E5%AE%B6%E4%B9%A1%E8%9A%8C%E5%9F%A0/"},{"categories":["笔记"],"content":"python中与时间相关的标准库有三个： time datetime calendar 吐槽：真tm傻逼，时间也要用三个库？搞得我现在都不会 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:0","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"时区坑 查看时间的方式有很多 法一： from datetime import datetime print(datetime.now()) 在windows上输出2021-08-22 15:04:09.958720，没问题 法二： import time localtime = time.localtime(time.time()) print(\"本地时间为 :\", localtime) 本地时间为 : time.struct_time(tm_year=2021, tm_mon=8, tm_mday=22, tm_hour=15, tm_min=5, tm_sec=20, tm_wday=6, tm_yday=234, tm_isdst=0)，没问题 注意：可是到了linux上都不对 GMT 时间：格林威治时间，基准时间 UTC 时间：Coordinated Universal Time，全球协调时间，更精准的基准时间，与 GMT 基本等同 CST 中国基准时间：为 UTC 时间 + 8 小时，即 UTC 时间的 0 点对应于中国基准时间的 8 点，即为一般称为东八区的时间 在我的linux机器的shell里打date，可以显示正确CST的时间，但是在python里用上述两种方法，时区都是GMT，写程序的时候一直都没发现，真是害惨我了。 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:1","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"datetime引入 datetime下有个类名字还叫datetime，所以你得这样写代码 import datetime datetime.datetime.now() 或者 from datetime import datetime datetime.now() 哇这真是太傻逼的，python这么好用的语言也有反人类的时候。 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:2","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"python获取当前时间（CST时间） 很简单，如果你发现你用datetime获取到的是UTC时间，就把他加上8小时就是CST时间了 import datetime,timedelta localtime = datetime.now()+timedelta(hours=8) 获取小时（格式化字符串） import datetime,timedelta localtime = datetime.now()+timedelta(hours=8) print(localtime.strftime(\"%H\")) ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:3","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["书影记录"],"content":"一句话概述  《人类简史》在2012年以希伯来文出版。本书从人类的起源开始谈，谈到人类的认知革命、农业革命、再谈到人类的融合统一、科学革命，最后谈一谈人类的未来。构造了一个横跨人类历史的巨大历史框架。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介  作者是以色列年轻人尤瓦尔·赫拉利（出书时不到40岁），现在是牛津大学历史学博士。简史三部曲《人类简史》、《未来简史》、《今日简史》都出自他笔下。（这三本书都是畅销书，在书店里常看到~） ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"语言特色  本书的可读性非常强！读的时候感觉就像在听作者侃侃而谈，很有趣，完全不像教科书那样枯燥。作者是江湖派，书中观点尖锐，但有理有据，让人受震撼的同时又觉得很有道理。真是“听君一席话，胜读十年书！”  该书中文版所参照的英文版，加入了很多中国元素，是作者特地为中国读者“量身定做”的。这位译者林俊宏先生也是旷达敏捷，文笔生动晓畅，翻译后的语言生动，比喻贴切，对中国读者非常友好。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"收获和感想  看这本书的第一感受就是满足了好奇心，知道了很多有趣但貌似没用的知识。收获很大，但是具体收获到了什么，说不清楚。就好比贾宝玉经常说他悟了，但林黛玉问他悟到了什么，他说不上来。可谓是：“此中有真意，欲辨已忘言”。  但仔细想一想，收获有两个方面：第一、补充知识。《人类简史》为我构建了一个宏大的，关于全人类历史的知识框架。从原始社会，到农业革命，到科学革命到工业革命再到现代最后到未来，人类经历了若干个时代，进入每个时代的原因是什么，每个时代是什么样子，各什么特点，都在这本书里有论述，解决了很多以前产生过但是懒得去查的问题。比如，什么是帝国主义？这个经常在新闻里听到，但是读这本后我才弄懂是什么意思。  **第二、拓宽思维。**除了客观的历史陈述之外，作者还提供了独到的观点，让我大呼“卧槽，说的好几把对！” 印象最深刻的是，作者认为人类可能并不是一直在进步的，比如农业革命之后，人类从采集狩猎的生活变成了定居种地的生活。农民比原始人工作时间更长，干的活更多，还要被统治阶级压迫。和家禽住在一起更容易得疾病，饮食过度单一导致营养不良。从DNA的角度看，人口增加，DNA复制的越来越多，这是DNA的胜利。但是从个人的角度看，每个人的生活质量都下降了，农业革命可能是史上最大的一桩骗局。与其说人类驯服了小麦，不如说小麦驯服了人类。  作者尤瓦尔·赫拉利知识广博，旁征博引，串联起不同的地区，不同的时代，从多学科的角度描述现象，解释原因。读完这本书之后，有个很深切的感受，就是认清了自己的无知与傲慢，我们所处的时代其实并没什么特别之处，它仅仅只是人类历史的一个阶段。而人类历史也只是地球这个星球漫长演化过程的冰山一角。罗翔老师说，“读万卷书” 是为和古人对话，走出时代的偏见。这本书，很好的帮助我走出时代的偏见。  另外，这本书提出的哲学问题，也引人深思。举个例子，人类存在的意义是什么，是追求快乐吗，追求的快乐是自由主义所说的感官快乐，还是佛教所说的无欲无求？想到最后就会发现人类的存在根本没有意义，既然没有意义我还存在干嘛，好烦，罢了罢了，别想乱七八糟的了，还是过好当下的生活吧！ ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人类的未来难以预料  在21世纪，自然法则开始被人类打破，而由智慧设计法则取而代之。这是人类最接近造物主神的一次。目前有三种方式可能让智慧设计取代自然选择：生物工程、仿生工程与无机生命工程。这三者的发展，都让未来不可想象。试想一下，如果未来诞生了基因和身体被改造的精英人类，他们看待普通人类，是不是像我们看待黑猩猩一样。他们和我们是一个物种吗，我们会奴役其它物种，而他们会奴役我们吗？  当然，以上是悲观看法。目前的人类技术发展趋势更多的是向乐观发展，人类最终会进入乌托邦还是地狱，谁也预测不了。但有一点是肯定是，就是未来人类的世界肯定有翻天覆地的变化。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:5","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"现在是最好的时代  现在是最好的时代，全球局势以和平为主，经济空前繁荣，大多数人拥有自由，环境也没有被严重破坏。无论你是有神论者，无神论者，种族主义者、资本主义者、共产主义者等等，都有追求自己想要生活的权利。中国在飞速的进步，谈到未来没有一个人不信心满满，要珍惜这个充满希望的时代。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:6","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"这个星期我去了六次网吧，吃了三次炸鸡。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:0","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"网吧 虽然说我家里也有电脑，也能打lol，但就像是别人的女朋友总是比自己的女朋友好看一点，外面的电脑也比自己家的好玩一点。 现在好多网吧都倒闭了，剩下的经常爆满，我和刘金金金宇在三家网吧都充了钱，随时更换阵地。 打LOL终极魔典，一开始我两被敌人玩弄于股掌之间，然后我两玩弄敌人于股掌之间，再到后来我两被队友玩弄于股掌之间。 l4d2这个游戏，就是LOL的互补品，有的时候玩LOL玩得便秘，就拿这个游戏疏通一下。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:1","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"炸鸡 炸鸡配菠萝啤——金童玉女 炸鸡配可乐——两小无猜 单点炸鸡——玉体横陈 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:2","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"华莱士 别跟我说吃华莱士成喷射战士，上20块钱网吃20块钱华莱士不香么。它卖的确实是泻药，你看不起泻药？泻药也是药。治便秘，不含糖。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:3","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["笔记"],"content":"安装python 1）安装依赖包 安装 “Development tools” 软件组： sudo yum groupinstall \"Development tools\" 因为 Python 3.7 源文件使用 zlib 格式打包，所以需要安装 zlib 软件包；Python 3.7 编译安装时需要使用 zlib 的头文件和链接库，所以需要安装 zlib 的头文件和链接库 zlib-devel 软件包： sudo yum -y install zlib zlib-devel Python 3 有个内置模块 ctypes，它是 Python 3 的外部函数库（Foreign function library），它需要使用系统外部函数库（libffi）的头文件和链接库，所以需要安装外部函数库（libffi）头文件和链接库 libffi-devel 软件包： sudo yum -y install libffi-devel 2）运行如下命令配置、编译、安装 Python 3.7 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz tar xJf Python-3.7.0.tar.xz cd Python-3.7.0 sudo ./configure sudo make sudo make install 如果在编译安装时提示 zipimport.ZipImportError: can’t decompress data; zlib not available 错误，请查看关于 zlib 的解决方法。 如果在编译安装时提示 ModuleNotFoundError: No module named ‘_ctypes’ 错误，请查看关于 ctypes 的解决方法。 3）安装完成后，Python 3.7 安装在了/usr/local文件夹中，可运行文件/usr/local/bin，库文件/usr/local/lib。因为 /usr/local/bin 在 Shell 路径中，所以可以直接在 Shell 中输入如下命令 python3 运行 Python 3.7 解释器。 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"升级sqllite3 亲测有效 [root@localhost /]# sqlite3 --version [root@localhost /]# wget https://www.sqlite.org/2019/sqlite-autoconf-3270200.tar.gz [root@localhost /]# tar -zxvf sqlite-autoconf-3270200.tar.gz [root@localhost /]# cd sqlite-autoconf-3270200 [root@localhost /]# ./configure --prefix=/usr/local [root@localhost /]# make [root@localhost /]# make install [root@localhost /]# find /usr/ -name sqlite3 ＃检查版本 ## 最新安装的sqlite3版本 [root@localhost /]## /usr/local/bin/sqlite3 --version 3.27.2 2019-02-25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0f6d7 [root@localhost /]# ## Centos7自带的sqlite3版本 [root@localhost /]# /usr/bin/sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 [root@djangoServer ~]# ## 可以看到sqlite3的版本还是旧版本，那么需要更新一下。 [root@localhost /]# sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 [root@localhost /]# ## 更改旧的sqlite3 [root@localhost /]# mv /usr/bin/sqlite3 /usr/bin/sqlite3_old ## 软链接将新的sqlite3设置到/usr/bin目录下 [root@localhost /]# ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3 ## 查看当前全局sqlite3的版本 [root@localhost /]# sqlite3 --version 3.27.2 2019-02-25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0f6d7 [root@localhost /]# ＃将路径传递给共享库 # 设置开机自启动执行，可以将下面的export语句写入 ~/.bashrc 文件中，如果如果你想立即生效，可以执行source 〜/.bashrc 将在每次启动终端时执行 [root@localhost /]# export LD_LIBRARY_PATH=\"/usr/local/lib\" ＃检查Python的SQLite3版本 [root@localhost /]# ipython3 Python 3.7.1 (default, May 3 2019, 09:55:04) Type 'copyright', 'credits' or 'license' for more information IPython 7.5.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import sqlite3 In [2]: sqlite3.sqlite_version Out[2]: '3.27.2' In [3]: exit ———————————————— 版权声明：本文为CSDN博主「Echo......」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_43883625/article/details/100709484 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"cron表达式 linux中cron表达式有五位数 （秒）[分 时 日 月 星期] （年） 秒和年都不是unix系统自带的 21 17 14 7 7 #在7月14日星期天17时21分执行，只执行一次 “*” 表示每一 20 * * * * #每小时的20分钟执行一次，一天执行24次 20,40 * * * * #每小时的20分钟，40分钟执行一次，一天执行48次 20-40 * * * * #每小时的20到40分钟执行，每分钟执行一次，闭区间，每小时执行21次 */2 * * * * #0,2,4,6...58分钟时执行 其它，在这里https://www.bilibili.com/video/BV19t411G7KU?from=search\u0026seid=1398478951454031547 有的时候，在crontab里必须把命令写全，路径要是绝对路径，例如： * * * * * /root/.pyenv/shims/python3.7 /home/mail.py » /home/mail.log ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"解压 filename.zip的解压: unzip filename.zip filename.tar.gz的解压: tar -zxvf filename.tar.gz 其中zxvf含义分别如下 z: gzip 压缩格式 x: extract　解压 v:　verbose　详细信息 f: file(file=archieve)　文件 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"查看时间 date ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"models 写入新数据，返回此条新数据 `new_data = Queue.objects.create(**queue_dic)` 访问新写入数据的id字段 `new_data.id` 查询数据 查询一条数据 `student = Student.objects.get(name='django')` 查看字典类型 `student.__dict__(前后两个下划线)` 筛选多条数据 `student = Student.objects.filter(name='python')` 它返回的student是一个对象的列表，可以看的出来student[0]和上面的get方式返回的student的结果是一样的。 修改数据库 对单一数据修改 data = Queue.objects.filter(statue=-1)[0] data.score = points data.msg = errorLst data.statue = 1 data.save() 批量修改 Queue.objects.filter(id=1).update(username='nick',is_active=True) ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:1:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"screen 新建窗口 `screen -S 名称` 连接到窗口 `screen -r 名称` 强制连接 `screen -D -r 名称` 查看列表 `screen -ls` ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:2:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"python导包 导入上级目录的包 import sys sys.path.append(\"..\") import xxx **sys.path的作用：**当使用import语句导入模块时，解释器会搜索当前模块所在目录以及sys.path指定的路径去找需要import的模块，所以这里是直接把上级目录加到了sys.path里。 **“..”的含义：**等同于linux里的‘..’，表示当前工作目录的上级目录。实际上python中的‘.’也和linux中一致，表示当前目录。 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:3:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"django-crontab定时任务 django-crontab还挺方便的，但是不好使:https://www.jianshu.com/p/b1ac0d7ae20c django-crontab官网：django-crontab · PyPI cron表达式：https://cloud.tencent.com/developer/article/1343175 菜鸟教程linux：https://www.runoob.com/w3cnote/linux-crontab-tasks.html crontab -e #编写cron python3 manage.py crontab add python3 manage.py crontab remove python3 manage.py crontab show linux中cron表达式有五位数 （秒）[分 时 日 月 星期] （年） 秒和年都不是unix系统自带的 21 17 14 7 7 #在7月14日星期天17时21分执行，只执行一次 “*” 表示每一 20 * * * * #每小时的20分钟执行一次，一天执行24次 20,40 * * * * #每小时的20分钟，40分钟执行一次，一天执行48次 20-40 * * * * #每小时的20到40分钟执行，每分钟执行一次，闭区间，每小时执行21次 */2 * * * * #0,2,4,6...58分钟时执行 其它，在这里https://www.bilibili.com/video/BV19t411G7KU?from=search\u0026seid=1398478951454031547 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:4:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"在外部使用django的orm import sys import os from django.core.wsgi import get_wsgi_application sys.path.extend(['/autoReport',]) #修改django项目位置 os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\",\"autoReport.settings\") #修改自己的django项目名 application = get_wsgi_application() from home.models import Reportinfo ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:5:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"部署 gunicron 安装 pip3 install gevent pip3 install gunicorn 配置文件，和settings.py放在同一目录 # gunicorn.py import logging import logging.handlers from logging.handlers import WatchedFileHandler import os import multiprocessing bind = '0.0.0.0:1234' #绑定ip和端口号 backlog = 512 #监听队列 chdir = '/autoReport' #gunicorn要切换到的目的工作目录 timeout = 30 #超时 worker_class = 'gevent' #使用gevent模式，还可以使用sync 模式，默认的是sync模式 workers = multiprocessing.cpu_count() * 2 + 1 #进程数 threads = 2 #指定每个进程开启的线程数 loglevel = 'info' #日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置 access_log_format = '%(t)s%(p)s%(h)s\"%(r)s\" %(s)s%(L)s%(b)s%(f)s\" \"%(a)s\"' #设置gunicorn访问日志格式，错误日志无法设置 \"\"\" 其每个选项的含义如下： h remote address l '-' u currently '-', may be user name in future releases t date of the request r status line (e.g. ``GET / HTTP/1.1``) s status b response length or '-' f referer a user agent T request time in seconds D request time in microseconds L request time in decimal seconds p process ID \"\"\" accesslog = \"/autoReport/gunicorn_access.log\" #访问日志文件 errorlog = \"/autoReport/gunicorn_error.log\" #错误日志文件 启动服务器 gunicorn -c ./autoReport/gunicorn_conf.py autoReport.wsgi:application 关闭 fuser -k 1234/tcp nginx 用宝塔 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:6:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["技能分享"],"content":"QQ邮箱设置 ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:1","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"python代码 import json import requests import smtplib from email.mime.text import MIMEText from email.utils import formataddr import re #发邮件 def mail(my_sender,my_user,subject,msg_text): my_pass = 'XXXX' # 发件人邮箱密码 ret = 1 try: msg = MIMEText(msg_text, 'html', 'utf-8') msg['From'] = formataddr([\"XXX\", my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['To'] = formataddr([\"收件人昵称\", my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['Subject'] = subject # 邮件的主题，也可以说是标题 server = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender, [my_user, ], msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret = 0 return ret ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:2","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"时间判断 import datetime # 范围时间 d_time = datetime.datetime.strptime(str(datetime.datetime.now().date())+'9:30', '%Y-%m-%d%H:%M') d_time1 = datetime.datetime.strptime(str(datetime.datetime.now().date())+'9:33', '%Y-%m-%d%H:%M') # 当前时间 n_time = datetime.datetime.now() # 判断当前时间是否在范围时间内 if n_time \u003e d_time and n_time\u003cd_time1: pass ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:3","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"vscode的这个ssh remote插件真是让我又爱又恨，本来用着好好的，今天突然连不上远程服务器了。看控制台，唯一能看懂的就是这一句“试图写入的管道不存在。”在网上找了好久，总共有四五种解决方法，没有一种是管用的。 ","date":"2021-08-03","objectID":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/:0:0","tags":null,"title":"win10 vscode remote ssh \\\"试图写入的管道不存在\\\"相关报错解决","uri":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"解决方法 在ssh配置文件目录下`C:\\Users\\sunbaile\\.ssh` 有两个文件。`config```是配置文件，另一个```known_hosts`是出问题的文件。 编辑`known_hosts`，把出错的那个主机ip那一行记录的信息删了。 然后我发现虽然没有报错了，还是连不上去。 重启一下电脑，竟然就连上去了。 草拟吗windows 每次都会遇到不明不白的环境问题，然后忙了大半天，不明不白的解决了qwq ","date":"2021-08-03","objectID":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/:0:1","tags":null,"title":"win10 vscode remote ssh \\\"试图写入的管道不存在\\\"相关报错解决","uri":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"categories":["笔记"],"content":"NGINX ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"nginx常用命令 whereis nginx #找到nginx目录 cd /usr/local/nginx/sbin #sbin是存放命令的目录 ./nginx #启动nginx ./nginx -s stop #停止 ./nginx -s quit #优雅退出 ./nginx -s reload #重新加载配置文件（常用 ps auxgrep nginx #查看Nginx进程 ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置文件 # /usr/sbin/nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 配置文件解释参考： https://blog.csdn.net/tjcyjd/article/details/50695922 ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"老同学没有忘记 高中同学感情很深，分别一年，互相想念。我才刚到家两天，泽枫，国荣，宇龙都发消息给我找我出去玩。我对高三博雅班的同学没有任何好感，但是对以前二班的同学我很愿意继续相处。 ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:1","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"张宇龙的升学宴 一个五河的小伙子，我高中的好兄弟。今年复读一年考上北京的对外经贸大学，大喜，十分热情的邀请我去五河县他家里吃席。 同去的还有一年没见的二班同学，刘星宇、周锐、叶雨辰。见了面我们几个老二班人聊得很开心，大家变化都不大。刘星宇还是那个吃货，复读一年考上安徽大学。周锐在西北农林科技大学大展身手，也是很牛的。叶雨辰去了北外，性取向仍然不明确。周锐和叶雨辰不知道啥时候能公开在一起（调皮） 去五河的路上还有一个小插曲，就是我们四个理科生全部理解错了张宇龙的意思，买错了票，坐错了车。而文科生都买对票了。哈哈哈太有趣了。 我跟他们在一起真的很舒服，说了好多有趣的话，之前没发现我口才这么好哈哈哈哈（自夸） ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:2","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"张宇龙 张宇龙我最佩服的是他的胸怀，他有真正男人的胸怀，以天下为己任，信仰共产党，热爱祖国热爱人民。他是优秀的文科生，跟浮躁的理科生是完全不同的。 我跟他兴趣爱好，家庭环境差别很大，但是我两就是很能聊得来。我对他感兴趣，他也对我感兴趣，这个朋友是要好好处的。 ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:3","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"型号LG 29wk500，入门级带鱼屏 ","date":"2021-07-30","objectID":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/:0:1","tags":null,"title":"带鱼屏真是太太太爽爽爽啦","uri":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/"},{"categories":["随笔杂记"],"content":"真沉浸感！ ","date":"2021-07-30","objectID":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/:0:2","tags":null,"title":"带鱼屏真是太太太爽爽爽啦","uri":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/"},{"categories":["笔记"],"content":"展示  概括来说，就是用django开发的web项目。相当于一个学生管理系统＋评测系统，开发完成后部署。这个项目，在一起参与暑期实习的很多同学看来，应该是很牛很牛的项目了。牛在哪里呢？牛在我们真正把东西做出来，部署好，让每个人打开浏览器就能访问，让大家都能体验到我们做的这个项目是实实在在的，不是只会做ppt，纸上空谈。  我们也确实策划了很久，半个学期之前李昕老师就找我们就开始做了，受了老师很多指点，我们自己也很早开始学习相关知识。项目能做成这个样，既是意料之外，又是情理之中。 ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:1","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"组员  我们这一组四个人两男两女，真是默契到让好多人羡慕。整个小学期的开发过程真是行云流水，稳步推进，没遇到大的阻碍。每个人的分工明确，各自做各自的内容。组员之间没有交流障碍，互帮互助，氛围十分融洽。时不时开个玩笑，大家欢声笑语，没有压力。如果有任务没完成的，不用组长催，组员自己愿意留下来加班到11点。  我作为组长，不谦虚的说，我们组能这么默契，跟我的领导能力有一点关系的，哈哈哈。我自己超前学习，掌握大方向。平时布置任务就分工明确，分工合理。我跟组员相处很好，实习前特地请大家吃了顿火锅。实习结束后，大获成功，请大家喝了杯奶茶。我觉得一个做项目的小组，不应该是冷冰冰的，而应该是一起既能工作，又能吃喝玩乐。  徐朔，和我爱好相投，都对电子产品感兴趣，我两特别聊得来。解决问题的能力非常强，虽然有时有点不靠谱，但是是顶梁柱之一。  廖集秀，性格很好。虽然是后期加入的，但是很好学，很快就跟上了我们的进度。很负责，为了做好自己的内容主动加班，点赞。  王文婕，挺能干的，一个人，光是views.py里就写了700多行代码。性格比较活泼，活跃气氛很好。 ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:2","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"未来  我其实并不期望我们能把这个项目做得很大，像大创的项目概述里写的那样。只期望我们几个能一直进步，组里氛围依旧融洽，产品最终可以投入使用。也希望新的成员李传兰同学能很好融入我们。  就这样吧，来日方长，再接再厉！ ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:3","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"打开docker服务 systemctl start docker docker一直在后台运行 `docker run -dit judge:0.2 /bin/bash` 复制 `docker cp 容器id:容器内路径 目的主机路径` `docker cp /root/testPython/test01/ $(docker ps -q):/usr/src/app` `docker cp /root/testPython/judge_file_o.py $(docker ps -q):/usr/src/app/test01/judge` 容器外执行命令 `docker exec -it $(docker ps -q) /bin/bash -c \"python /usr/src/app/test01/judge/judge_file_o.py\"` 进入正在运行的容器 `docker exec -it $(docker ps -q) /bin/bash` `docker attach 容器id` 显示容器编号 `$(docker ps -q)` 将文件拷贝出来 `docker cp $(docker ps -q):/usr/src/app/test01/user/tmp.txt /root/testPython/` 强制删除容器 `docker rm -f $(docker ps -q)` 停止容器 docker stop 容器ID或容器名 优雅的停止容器 删除镜像 docker rmi -f 镜像id docker rmi -f $(docker images -aq) MySql同步数据 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"拉取 docker search mysql docker pull mysql:5.7 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"运行 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345 --name mysql01 mysql:5.7 -d后台运行 3306是容器外端口 -v数据挂载；本地：容器 要配密码，怎么配？在dockerhub上帮助文档 容器名 所选镜像 python操作数据库 `pip install mysqlclient` 使用mysqlclient，要自己写sql语句 conn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', ) 数据库权限 mysql\u003eGRANTALLPRIVILEGESON*.*TO'root'@'%'IDENTIFIEDBY'123456'WITHGRANTOPTION;mysql\u003eflushprivileges;//其中各字符的含义：//*.*对任意数据库任意表有效//\"root\"\"123456\"是数据库用户名和密码//'%'允许访问数据库的IP地址，%意思是任意IP，也可以指定IP//flushprivileges刷新权限信息Dockerfile FROM # 基础镜像，当前新镜像是基于哪个镜像的 MAINTAINER # 镜像维护者的姓名混合邮箱地址 RUN # 容器构建时需要运行的命令 EXPOSE # 当前容器对外保留出的端口 WORKDIR # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 ENV # 用来在构建镜像过程中设置环境变量 ADD # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY # 类似ADD，拷贝文件和目录到镜像中！ VOLUME # 容器数据卷，用于数据保存和持久化工作 CMD # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最 后一个生效！ ENTRYPOINT # 指定一个容器启动时要运行的命令！和CMD一样 ONBUILD # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"这话我是故意这么说的。今天是7月17日，我“大病”一场，身体彻底垮了，才知道身体和健康是多么重要。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:0","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"胡吃海喝 昨天是军训结束的第一天，晚上正好是啤酒节开幕式，我和秋豪一起去逛逛。本来我是想在学校吃完再去的，但是秋豪兴致勃勃地对我说，咱们一定要出去再吃一次海鲜，如果你不跟我出去吃我立马回寝室学习。秋豪找了一家美团评分4.9的“金鱼村海鲜大排档”，离啤酒节不远。我想上次咱们去找海鲜大排档没有找到，这次也很想去尝尝，就同意了。 这家“金鱼村海鲜大排档”确实是大排档，但是价格比上次在店里吃的还贵，海鲜大咖没上次的海鲜品种多，味道也不如上次。吃饱之后，我们就去逛啤酒节了。 晚上睡觉吃了个西瓜（后来我才知道西瓜不能和海鲜一起吃），晚上啥事儿没有。我知道第二天早上可能会拉肚子，但是没想到会这么严重。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:1","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"被送去急诊 早上5点，肚子疼，拉了三次，吐了两次。实在受不了，孙萃骑着电驴把我送进校医院急诊。这两天看《红楼梦》，看到晴雯、黛玉都病死了，我也觉得我要不行了。 我当时疼的在床上打滚，萃萃帮我挂号，接吐，扶我去便检，真的好感动。我疼的大喊大叫，那种感觉最好一辈子都不要再有了，就好像有人在拧毛巾似的在拧你的胃，还拧了两三个小时！医生给我屁股上打了针麻醉，半个小时后才疼痛才慢慢缓解，我就立刻睡着了。 起来之后，发现帅帅来看我了，又感动一波。再过一会儿，桐桐、苏文、云川也来了，再感动一波。人家是事不过三，后来秋豪也来了，我绷不住了，吊完水我们一起回去的。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:2","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"身体最重要 好多年没这样酣畅淋漓的生病了，生病疼就不说了，浑身乏力，啥也干不了。花这些冤枉钱，还不如平时多买点水果吃。以前对饮食都不当回事儿，从这件事以后，我对我的饮食要多加小心了，尤其是辛辣油腻的食物。我现在看到大荤大肉就觉得恶心，这两天当素食主义者吧。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:3","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["书影记录"],"content":"87版《红楼梦》  87红楼梦拍得是相当好的。小时候看不懂，不以为然。后来看了新版红楼梦（10版），才知道87版红楼梦是多么经典。导演王扶林拿捏了每一处细节，用高超的手法尽可能地还原了红楼梦原著。为拍摄此剧付出的代价也远高于现代拍摄的古装剧。演员也各个都是颜值天花板，看得好不过瘾！  看看拍这部剧的投资： 1984年9月10日，该剧在安徽黄山正式开机，录下了第一组镜头，1987年上半年完成拍摄，总投资为680万人民币。整个拍摄过程历时三年之久，剧组先后走遍全国10个省市的41个地区的219个景点，拍摄镜头近万个。（来自百度百科）  拍摄时王导采用军事化管理，全剧组一百多位演员每天早上要在北京圆明园练功。就连演丫鬟的都要学唱戏，学走路，还要求所有人熟读红楼梦。剧组在北京专门修了一座大观园用于拍摄，由于北京用地紧张，荣国府和宁国府建在河北。现在都是旅游景点。  据说当时拍摄用了三千套衣服，基本还原了曹雪芹原著。因为曹雪芹没有写完红楼梦，所以全剧的结尾是由各地红学家齐聚一堂商讨出来的，并非高鹗续本。 陈晓旭（饰演林黛玉）  主要演员的竞选很激烈，林黛玉组中陈晓旭胜出。陈晓旭面试的时候，把她14岁时写的一首诗《我是一朵柳絮》寄给王导： 我是一朵柳絮， 长大在美丽的春天里， 因为父母过早地把我遗弃， 我便和春风结成了知己。 我是一朵柳絮， 不要问我的家在哪里， 愿春风把我吹送到天涯海角， 我要给大地的角落带去春的消息。 我是一朵柳絮， 生来无忧又无虑， 我的爸爸是广阔的天空， 我的妈妈是无垠的大地。  生活中的陈晓旭就是把自己当成了林黛玉，演员和剧中人物的气质和性格如出一辙。  刚拍红楼梦时，大家对陈晓旭饰演的林黛玉不太满意。很多人认为剧中的林黛玉没有原著中“仙女”的感觉，说陈晓旭演把林黛玉演的太尖酸刻薄，无异于常人。但是后面大家渐渐发现，陈晓旭已经把林黛玉演到了极致。林黛玉就是这种任性可爱的角色。  晓旭拍完红楼梦三年就没有再拍戏，1999年落发出家，法号妙真。2007年香消玉殒，享年41岁。  张国荣拍完《霸王别姬》后深陷其中，难以从剧中人物程蝶衣走出来。红楼梦其它很多演员也是如此，比如陈晓旭、欧阳奋强（饰演黛玉）、张莉（饰演薛宝钗）。尽管荧幕已经结束了，但是荧幕中角色的灵魂和他们的灵魂相融，到底是现实还是荧幕？入戏太深，真真假假分不清楚。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人物评价（仅个人观点 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第一代 贾母：一生享尽荣华富贵，对人情世故明澈洞察。是贾府的精神支柱，贾母没了之后贾府加速衰败。 贾敬：红楼梦化学家，炼丹给自己毒死了。本来考上清北了，但是人家不去。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:1","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第二代 贾政：典型严厉大父亲。本来能考清北，被保送普通一本。 贾赦：色批头子。 贾珍：色批三人组之一，跟儿媳妇偷情，无能之辈。 邢夫人：蠢女人。 王夫人：“吃斋念佛大善人”。（讽刺） 尤氏：软弱无能。被王熙凤骂作“锯了嘴的葫芦”。 赵姨娘：长得有几分姿色，但情商极低。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:2","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第三代 贾琏：好色，但人家长得帅，被很多女人嫖过，天天惹凤凤生气。 宝玉：虽难得有怜惜女孩儿之心，模样俊俏得贾母喜爱，但毕竟是纨绔子弟，不谙世事，也没啥出息。 贾蓉：感觉是贾府唯一正常公子，能干事情，也会耍花招。 贾环：反面人物，猥琐小人。跟丫鬟赌钱赖账，故意把蜡油撒宝玉脸上。 贾芸：跟着贾芸学说话，白手起家赚大钱。 薛蟠：大傻逼，不过倒活的也挺自在，跟大帅哥柳湘莲拜把子。薛家一大祸害，后期怕老婆。 宝钗：富贵宝姐姐，大气端庄有才华，诗词百科全书。 史湘云：湘云小可爱，太妹性格，史家被抄之后就见不到了。最后在一艘船上沦为娼妓，跟这首诗一样凄凉： “寒塘渡鹤影，冷月葬花魂。” 湘云美颜暴击： 贾瑞：b站弹幕称red爷（瑞大爷），贾家远亲，癞蛤蟆想吃王熙凤，与其说被王熙凤整死，不如说自己痴情而死。 探春：有王熙凤的气魄，可惜赶上贾府衰败，后被太妃远嫁，不知结局如何。 黛玉：宝玉的学霸女友。冷艳孤高但可爱，多愁善感又专情。 最标志的古典美人之一，曹雪芹评价为： “两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。” “闲静时如姣花照水，行动处似弱柳扶风”。 下图林妹妹美颜暴击： 迎春：软弱无能。 元春：前额饱满，长得就很贵妃。心肠不太好，最后被皇上赐死（猜测）。 惜春：三春中只有惜春是东府姑娘，冷漠无情，与其它人划清界限，最后出家，结局算好的。 秦可卿：大美人，长得有点妖。据说是神仙，启蒙宝玉性教育。秦可卿之死是个谜。 王熙凤：“北大光华管理学毕业”，性格泼辣，口齿伶俐，办事得体，长得还漂亮。啥都能管，就是管不住老公。全剧的核心人物，几乎每一集出场，台词最多。演员邓婕老师也很牛。 凤姐美颜暴击： 林黛玉进贾府，影响最深刻的就是王熙凤，“未见其人先闻其声”，高中语文课本名场面。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:3","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"丫鬟 袭人：宝玉性教育启蒙，宝玉房里首席丫头，宝玉准未婚妾，每日寻宝任务，后期有点黑化。 晴雯：模样俊俏（有点像林妹妹），脾气刚烈，撕扇子经典桥段。最清白，最可爱，声音最好听，却被王夫人害死。 晴雯判词： “霁月难逢，彩云易散，心比天高，身为下贱，风流灵巧招人怨。寿夭多因诽谤生，多情公子空牵念。” 晴雯是为数不多死在曹雪芹笔下的红楼女子，从判词可以看出曹雪芹也很喜欢晴雯。 晴雯美颜暴击： 麝月：吵架吵不过了请叫麝月姐姐来帮忙。 平儿：真的好喜欢平儿，美人坯子，不卑不亢，王熙凤助理兼闺蜜兼情敌，王熙凤和贾琏每次吵架都是平儿背锅挨打，好心疼。 小红：红楼梦鸡汤主角，靠才华成功的励志人物典范之一。贾家被抄后意外遇见贾芸，很好的结局。 金钏：跟宝玉淘气，被“教子有方，心地善良”的王夫人逼死。 紫鹃：微胖的小可爱，跟了黛玉一辈子。 紫鹃美颜暴击： ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:4","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"其它人物 刘姥姥：看似小丑，实则精明。没多少人能比得上刘姥姥的。 贾雨村：“知恩图报贾雨村”。林黛玉老师，第一集带林黛玉进贾府，最后一集带忠顺王抄贾家。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:5","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"宝玉和黛玉  黛玉和宝玉的爱情故事太凄惨了，曹雪芹的《枉凝眉》写道： 一个是阆苑仙葩，一个是美玉无瑕 。若说没奇缘，今生偏又遇着他；若说有奇缘，如何心事终虚化？一个枉自嗟呀，一个空劳牵挂。一个是水中月，一个是镜中花。想眼中能有多少泪珠儿，怎经得秋流到冬尽，春流到夏！  宝玉和黛玉本是天造地设的一对，可惜覆巢之下安有完卵，贾府衰败已成定局。宝玉连林妹妹最后一面都没见到，只提着黛玉送的玻璃绣球灯出家去了。看到这里真绷不住了，我为宝黛一大哭！  黛玉的性格现代人看来是有缺陷的，太多愁善感、太悲观，啥事儿都往坏处去想，没有革命乐观主义精神，天天读诗经，西厢记那种闲书有啥用，不如学学马克思主义。（调皮 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:6","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"贾家被抄  贾家被抄，红楼一梦终破碎。原贾府常买卖丫鬟，现贾府的大小姐当成商品被贱卖。原刘姥姥向王熙凤下跪求施舍，现王熙凤向刘姥姥下跪求找巧姐。原宝玉戏说贾芸像他儿，现贾芸救宝玉出狱。史家出事，贾家没怎么帮忙，还怕惹上关系。现在贾家也出事了，贾家平日的那些至交要么落井下石，要么冷漠无视。来狱中看望的，仅有当年被贾府嫌弃的贾芸和刘姥姥！今昔对比，多么讽刺！  最后建议大家在b站看87版《红楼梦》电视剧，看弹幕真的特别有趣。 此文在迁移站点时图片全挂，现在是替换后的版本。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:7","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"阅读经历  学期初，室友刘桐荐此书，从图书馆借阅，全书600页。初捧读，爱不释手，觉此书为模仿红楼梦所著，多描写封建大家族男女情爱之事。期末，又有闲，再捧读。读罢，忽觉此书内涵之丰富，有深刻历史背景。  此书在文学上的地位虽比不上四大名著之一的《红楼梦》，但绝对算是一本旷世巨著。作为一个普通读者，浅读完毕，我是没有资格去“评判”这本书。但是每次阅读完一本经典，都是心灵的洗涤，有很多思考和感受，想尽可能记录下来。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"一句话概括内容  《京华烟云》故事始于1901年义和团运动，讫于上世纪30年代抗日战争，前后跨越30多年，借北平姚、曾、牛三大家族的悲欢离合和恩怨情仇反映了家国变迁和世道兴衰。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介  林语堂（1895年10月3日—1976年3月26日），和鲁迅同一时代。不是传统的中国文学家，多用英文写作，致力于把中国文化扬播四海。《京华烟云》这本书翻译的很不错，不知道译者是谁。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"随便写两句感想  在封建大家庭中，承担整个家庭顶梁柱的，固然是男性。但是家庭内部，维持着每一个细节的是女性。《红楼梦》和《京华烟云》，都是以女性为主要视角，讲述大家庭内部的故事。  书中让我印象最深刻的，就是对上个世纪初“封建”大家庭的生活图景的描绘。封建之所以打双引号，是因为自从辛亥革命清政府被推翻后，中国早不再是完全的“封建”。那个年代，大多数人还保持着“封建”的思想，但是又有各种新思想涌入国内，而北京，又是一个开放包容的城市。于是，各种文化交融在一起，产生了奇妙的化学反应。同一桌吃饭的人，服装都各有千秋，穿长衫的，穿西装的，穿旗袍的，穿裙褥的…如此有趣的时代。  下等人的生活，自然是劳苦乏味，也不值得描写。而上等人的生活，实在是精彩浪漫。一大家子住在香榭庭苑，没事儿就读书写字，吟诗作对。男人不必工作，女人也不用做家务，反正钱多的花不完。无聊了，就找几个朋友一起谈花饮月赋闲，或者和朋友一起外出登山揽胜，游山玩水。怕累？笑死，爷根本不走路，轿子直接给你抬到山顶。怕吃不好？笑死，直接给你在西湖游船上设宴，船头还有舞女吹箫助兴。少爷一方面都有自己的“青梅竹马”，另一方面没事儿的时候还能调戏调戏丫鬟。小姐也会向心上人暗送秋波，委婉表达爱意。男女之事，不是我们理解的“父母之命，媒妁之言”，而往往是少男少女先互相看上，有恋爱的意思了，才会有媒婆去提亲。这种婚姻一般也都是门当户对，幸福美满。什么是人上人？这才是人上人！  这本书有一位贯穿始终的女性人物，堪称男人心中的理想女性——姚木兰。她能满足你对“大家闺秀”的所有幻想。不仅长得好看，还特别聪明。这种“聪明”，是女性特有的聪明，能猜出人心思，会跟人聊天，还有一套化解夫妻矛盾的妙招。她有文化，能跟你品茗赏月，做风雅之事，但不露锋芒，不喧宾夺主。性格好，性格活泼，会吹口哨，时不时给你搞点小惊喜。感情专一，遵守儒家道德，安分守己，喜欢过平静日子。但所谓“理想”女性，只不过是男人心中的理想罢了，作为男人确实惋惜像木兰这种女子不能遇见。  书中写到抗日战争时期，日本人在中国犯下的种种罪行引起我心中强烈共鸣。我终于开始明白老一代人为什么那么痛恨日本。叫日本人“小日本鬼子”，是因为二战时日本人真的很矮，男人平均身高就1米5左右。他们粗俗野蛮，穷兵黩武，狂妄自大，收买培养中国汉奸，屠杀中国百姓，而且对于“性”，似乎永远不能满足，下至女童上至老妇都不放过。日本士兵是全世界士兵中最没有德行的，土匪好歹讲究仗义，只劫富不欺穷，而日本兵真的连土匪都不如。  《京华烟云》这本书是1939年出版的。那时的中国已经建立起抗日民族统一战线，全民族的抗日热情达到高潮，老一代腐败军阀大多已经被打倒。新一代年轻人怀着一腔报国热血，一批又一批参军加入抗日前线。小说的结尾中，木兰一行人逃亡内地，一路上收留了四个孤儿，这些孩子不是白收留的，他们生下来就怀着对日本的仇恨，未来也将成为抗战的栋梁。一路上不断有满载军人的卡车呼啸而过，他们都是自愿参军的年轻人，戴着钢盔在车上站的威风凛凛，向老百姓招手。军人得到民众的欢迎，开始唱出军哥，重复的句子是： “上战场 为家为国去打仗 山河不重光 誓不回家乡”  抗日战争胜利是1945年，本书出版日期比日本正式投降早了6年，但是对华夏文明知根知底的林语堂先生，已经预测战争的胜利者必然是中国，他知道中国人的血脉里，从古至今都流淌着不屈的血液。  此书原版林语堂先生用英文写作，为外国人了解中国作出巨大贡献。写在抗日战争时期，政治意义可能大于文学意义。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"随便说两句人物 木兰：前面说过了，想了解请看原著，千万别看电视剧。 姚老爷子：神人，信奉老庄哲学，看透一切。 曼娘：典型传统女性，终生保留贞操。 陈妈：典型中国母亲，倾其一生找寻儿子。 红玉：原型林黛玉！古典女性，多愁善感，殉情而死。 姚体仁：纨绔子弟。 孔立夫：赤子之心，有点看不透。 顺便画下人物关系： （仅部分） ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:5","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"最后  本书大部分片段的意境是宁静芬芳的味道，与《浮生六记》一样，让人向往以前人缓慢、舒适、宁静的生活。读书就是为了跨越时代的偏见，和古人对话，从现在浮躁的社会中获取一份心灵的安宁。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:6","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"起因  做大学物理大作业。张丽红老师给的课题很宽泛，做实物、写小论文都可以。我和何为就寻思着做一辆小车。本来想买树莓派，自己找配件，做一辆智能车，但是时间成本太高，于是就从淘宝上240块钱买了辆青少年编程学习玩具车。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:1","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"microbit单片机  微软搞的东西，面向青少年学习编程使用。上手十分简单，就真的是小学生的玩具。对于计算机专业的大学生来说毫无学习成本，编程完全可视化。在线编程地址：https://makecode.microbit.org/ microbit这个板子质量还是不错的，功能、接口也很多，实用性强。价格还好，100多块钱，比arduino贵不少，但是学生党可以接受。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:2","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"其它模块  电机、超声波模块、红外模块，车子底盘、还有一块电路板。基本都是淘宝卖家做好的成品，买回来花一个小时组装好就能玩了。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:3","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"演示效果  效果超好，红花在绿叶衬托下才好看，其它组几乎都搞的是综述、论文，只有我们组做出了实物。现场演示让老师赞不绝口，大大的表扬了我们。很开心，但是有点惭愧，其实我们买的都是成品组装的，没啥技术含量，没有那些搞论文的花时间多。有点愧不敢当。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:4","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"后续  男孩子对这种东西其实都蛮感兴趣的。以后可以结合咱们专业，拓展更高级的功能，比如计算机视觉。这个单片机用处也很大，可以拿来装在别的东西上。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:5","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"​ 毛主席在《恰同学少年》中说： “我最佩服的，是古希腊的斯巴达人，人数那么少，却能称霸希腊。为什么？因为他们不仅重视精神之文明，更崇尚野蛮之体魄。” ​ 说起锻炼，重要性不言而喻。锻炼可以减轻压力、可以增强自信、可以减肥、可以让人少生病…不要觉得锻炼浪费了你的时间，我认为锻炼实际上是一种稳赚不赔的投资。每天投资一个小时去锻炼，收获的是每天多两小时充沛的精力。有这两小时充沛的精力，可以做更多的事情，健身世界上成本最低的升值方式。 ​ 很多人都曾有过锻炼的冲动吧。总有那么一阵子，为了谈恋爱、减肥、打篮球等理由，突发奇想去锻炼身体。第一天踌躇满志，跑了3公里，发个朋友圈，感觉美好的未来就属于自己了。第二天跑2公里就累了，第三天找个理由就不想再坚持了…大家都知道锻炼是好的，但是坚持下来的人少之又少。 ​ 我很骄傲的一件事，就是我坚持每天锻炼，坚持了整整一学期。这一学期的每一天，我都去器械场做力量训练，还经常到操场跑步。风雨无阻，没有落下一天。我练习长跑，最长一次跑了6公里，配速5分钟，跑完15圈，大汗淋漓，压力彻底被释放了。我想：这么长的距离都跑下来了，还有什么事能难得倒我了呢？ ​ 能一直坚持，也是因为有人陪我一起坚持。最开始，我和舒成一起约好每天在操场见面，后来有一些同学加入我们，但都是浅尝辄止，断断续续，不能坚持。到期末，每天都能到场的，基本上还是我和舒成两人。”坚持“的品质多重要啊，曾国藩一生不断强调恒之重要性，他说： “凡人作一事，便须全副精神注在此一事，首尾不懈，不可见异思迁，做这样想那样，坐这山望那山。人而无恒，终身一无所成。” ​ 锻炼要坚持，写日记要坚持，背单词要坚持，敲代码要坚持…很多能力素养，都是靠坚持培养出来的。大家的聪明才智都差不多，但为什么最终有的人走得很远，而有的人半途而废呢？我想，恐怕唯“坚持”二字，非人皆有之！ ​ 毛主席年轻时最爱干的两件事：一是读书，二是锻炼。读书和锻炼二事，也是我的目标，是我在整个大学期间不懈的追求。 ","date":"2021-06-21","objectID":"/posts/%E9%87%8E%E8%9B%AE%E5%85%B6%E4%BD%93%E9%AD%84/:0:0","tags":null,"title":"“野蛮“其体魄！","uri":"/posts/%E9%87%8E%E8%9B%AE%E5%85%B6%E4%BD%93%E9%AD%84/"},{"categories":["笔记"],"content":"课程时长  这门课上的不长，就大半个学期。任课教师王老师，是一位教学经验丰富的老师。也是统计学方面的专家，跟着他学习，感觉在很短的时间内学到了很多知识。 ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"课程感受  “概率论与数理统计”实际上是两门课，“概率论”内容包括：随机事件与概率、随机变量及其分布、随机变量的数字特征、大数定律与中心极限定理。“数理统计”是以“概率论”知识为基础的，课程中学习的内容包括：数理统计初步、回归分析。 这是一门很明显的数学课程，用到了数学工具“微积分”，定理有严格的数学推导证明。但是，在“数理统计”这一块，在进行参数估计、假设检验、回归分析时，对于我们构建的模型，只讨论“好”还是“不好”的问题，而不是“对”、“不对”，这是与数学的区别。 这门课可以说是我们人工智能专业的核心课程。这学期我自学了一段时间机器学习，发现机器学习需要大量用到数理统计的知识。而且在课本《随机数据处理方法》中，我看到了像“极大似然估计”、“回归分析”、“正交试验”等名词在机器学习中出现。可惜的是，由于课时较短，书本上后面大部分内容都不在课程内容中，只能自学。  如果不是为了搞人工智能，我觉得这门课也很值得学习。因为它给我带来了看待世界的全新角度。自然界中的分子，原子，人类生产生活中的产品等等，这些东西都是大量的。那么对于大量的，有规律的数据，我们如何去研究它，找出它的规律，预测它的性质？这个问题，由这门学科给出了解答。我不得不佩服人类的智慧，人借助数学工具，总是能用“奇淫巧技”解决问题，并把技巧上升到如此美妙的数学理论。当然，我感觉这门学科还是有很大的完善空间的，尤其是现在进入大数据时代，这门课更应该被重视，理应会有更多人去研究，贡献新的研究成果，为构建完整的概率论与数理统计大厦添砖加瓦。 ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"总结  这门课还挺难的，希望考试能过，千万别挂了qwq ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":" 现在人工智能真是火到了极点，各个专业都想转行搞人工智能。作为本来就是人工智能专业的学生，更是要趁早开始。所以，大一下学期，在老师的指导，以及同学和合作下，我开始接触人工智能的学习。 ","date":"2021-06-13","objectID":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"本学期“人工智能”学习结束总结","uri":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"学习资料 从机器学习开始： **《统计学习方法》**作者：李航 教科书/课本，理论性强，也很权威。分为监督学习和非监督学习两部分。b站有啃书指导，“深度之眼”有视频教程，github上有代码实现：https://github.com/Dod-o/Statistical-Learning-Method_Code 和鲸社区 在这个平台上参加校内数据分析竞赛，学习资料蛮不错的，貌似是翻译的kaggle？ 机器学习的算法很多，涉及到很多概率论知识（真的好多），对数学功底要求比较高。 然后是深度学习： 飞浆 真的好好用，可以直接运行。https://aistudio.baidu.com/aistudio/projectdetail/1855447?qq-pf-to=pcqq.group d2l 国外的，有中文版，外国人的教程读起来都挺难受的，不过很全。https://zh-v2.d2l.ai/chapter_preliminaries/linear-algebra.html 这学期只算是刚刚入门吧，连代码都没跑过。 半个月后开始暑假小学期，期待进入下一阶段！ ","date":"2021-06-13","objectID":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"本学期“人工智能”学习结束总结","uri":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/"},{"categories":["书影记录"],"content":"我用不到一周的时间读完了这本《消失的13级台阶》，这本书是典型的日系推理小说，作者高野和明用电影式的叙述手法，清晰地讲述了一起跨度长达10年并且牵涉到多起犯罪事件的故事。读完之后，我深感震撼，不仅仅是因为精彩的故事情节和出乎意料的结局，还因为本书揭露了深刻的社会现实问题，生活在阳光下的我们或许从未关注过的关于“死刑”问题。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介 高野和明 日本小说家、编剧。他从小立志当导演，小学六年级就开始自己制作电影。1989年赴美深造钻研电影制作，1991年回国后开始剧本创作。 高野和明的科幻小说《人类灭绝》一经出版，立即横扫日本推理作家协会奖、山田风太郎奖等多项大奖。 《消失的13级台阶》是高野和明的出道作，一举斩获第47届江户川乱步奖，得到日本著名推理小说家宫部美雪的极力推荐和评委的一致好评，引发读者广泛关注。 高野和明的小说读起来像电影，具有相当立体的画面感，戏剧张力十足，节奏明快，毫无冷场。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说的情节 一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记忆…… 死刑执行官南乡携手刚假释出狱的纯一调查，希望替这位丧失记忆的死刑犯洗清冤屈。但他们查到的唯一线索，就是树原亮记得自己曾“走在台阶上”。 距离树原亮被执行死刑的时间所剩无几，但这起案 件始终疑云重重，仅有的线索“台阶”仿佛也凭空消失了…… 情节大赞，如果你对推理小说感兴趣，喜欢惊险刺激的故事情节，这本书值得一读！个人认为，在故事情节方面，完全不输于大名鼎鼎的推理小说作家东野圭吾。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说描绘了哪类人群 在我们的生活中，有一些我们很少接触到的人。他们有着特殊的职业或者特殊的经历。小说描绘了检察官中森、管教官南乡、律师杉蒲、有犯罪前科的纯一和安藤以及他们的家属等人的生活情状，让我看到了社会的另一面。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说讨论的问题：死刑应不应该被废除？ 大家都知道，漂亮国废除了死刑，中国没有废除，而日本对待死刑是极为慎重的态度。全世界国家对死刑的态度不同，死刑是敏感话题之一，有的政客把自己对死刑的主张作为个人标签宣传。 小说中不同的人对死刑持有不同的态度： 对于管教官南乡来说，他亲手对两位罪犯执行了绞刑，这样的经历让他十分痛苦，甚至破坏了他圆满的家庭，他对死刑制度恨之入骨。 而身为杀人犯的三上纯一，却在小说末尾支持死刑。我认为他的观点实际上也是作者的观点。当犯罪发生后，必须要由第三方来“公正”的审判，惩罚的力度必须足够，因为人类在对待生死的问题上不可能保持理性，如果允许人们使用“私刑”，将“冤冤相报何时了”。 关于审判罪犯，自古以来争议就没有停止过，究竟什么样的法律是公正的？人类怎么才能克服感性，做出最理性的判决？到底是支持“报应刑论”还是“教育邢论”？这些问题，可能永远都不会有标准答案吧。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:4","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"课程时长 离散数学上了大一上，大一下两个学期（貌似是80个学时。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"课程目录 总共四个篇章，分别是“集合论”、“数理逻辑”、“抽象代数”、“图论基础”。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"课程感悟 这是一门数学课，但是和数学分析、概率论又完全不同。离散数学研究的真的是离散的数学知识，与微积分完全无关。其中各个章节相关性不大，也有部分章节相关。 这门课程要求不高，难度不大，离散数学中出现的新概念非常多，书中有了大量的定义和定理，因此特别适合画思维导图学习。 考试题型一半是概念考察，另一半是证明考察。 上学期学了前两篇，没体会到这门课的精髓，下学期学后面两篇，感觉后面才是这门课的重点内容。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"思维导图 上下学期的思维导图我都画了，在QQ群里可以找到，但是我懒得扒拉了。 这里只展示下半学期的两篇。     ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"回顾上周 主要做了下面这些事情： 学习《统计学习方法》，目前学到决策树。 开发“人工智能平台”web项目，目前已经实现了最基本的普通类型题目测评。 坚持锻炼，开始养成长跑的习惯。 上周课少了很多，而且各种项目也都放缓了进度，我突然变得很闲，很不适应。而且又赶上5月20日和5月21日情人节，校园里到处都是恋爱的酸臭味儿，搞得我一个单身狗很难受。 ","date":"2021-05-21","objectID":"/posts/%E6%B2%89%E4%B8%8B%E5%BF%83%E6%9D%A5%E8%80%90%E5%BE%97%E4%BD%8F%E5%AF%82%E5%AF%9E/:0:1","tags":null,"title":"沉下心来，耐得住寂寞","uri":"/posts/%E6%B2%89%E4%B8%8B%E5%BF%83%E6%9D%A5%E8%80%90%E5%BE%97%E4%BD%8F%E5%AF%82%E5%AF%9E/"},{"categories":["随笔杂记"],"content":"沉下心来，耐得住寂寞 虽然空闲时间很多，但我也没有浪费，用零散的时间，读张宏杰先生的《曾国藩传》。阅读这样的著作，走近这位伟大的圣人，收获的是迷茫中的指引，我有心作了摘抄： 曾先生一生不断强调恒之重要性，他教育晚辈说： “有恒为作圣之基。凡人作一事，便须全副精神注在此一事，首尾不懈，不可见异思迁，做这样想那样，坐这山望那山。人而无恒，终身一无所成。” 曾先生才智不过人，能位极人臣靠的是一股韧劲儿，他感叹道： “极耐得苦，故能艰难驰驱，为一代之伟人。”曾国藩也经常遇到熬不下去的情况。在这个时候，他只有一个办法：以强悍的蛮劲打通此关。他以练习书法为喻，说明人在困难、倦怠、麻木面前应该如何做：“（写字写到）手愈拙，字愈丑，意兴愈低，所谓困也。困时切莫间断，熬过此关，便可少进。再进再困，再熬再奋，自有亨通精进之日。不特习字，凡事皆有极困难之时，打得通的，便是好汉。 曾先生遭人妒忌，受人排挤，他也曾寂寞难捱，但是品格高尚的他说： “木秀于林，风必摧之，锋芒毕露，人必非之。众人皆醉，我独醒。” 可爱的国藩先生，教我反思我这一周，确实鬼迷心窍，迷茫无往了。上了大学，没有人管了，但是要自律坚持做有益的事情；进了本研一体班，决定走学术这条路，就得做好“坐冷板凳”的准备；受到导师的器重，被予以期盼，就应该担起责任，向更高更远的目标前进！ 室友在寝室里说的玩笑话，在寝室里笑笑就过去了，那些桃色新闻，除了扰乱人心，没有任何价值。别被乱七八糟的东西蛊惑啦！抬起头，真正的目的地就在前方，一定要沉下心来，耐得住寂寞，风雨兼程，踏实走过。 ","date":"2021-05-21","objectID":"/posts/%E6%B2%89%E4%B8%8B%E5%BF%83%E6%9D%A5%E8%80%90%E5%BE%97%E4%BD%8F%E5%AF%82%E5%AF%9E/:0:2","tags":null,"title":"沉下心来，耐得住寂寞","uri":"/posts/%E6%B2%89%E4%B8%8B%E5%BF%83%E6%9D%A5%E8%80%90%E5%BE%97%E4%BD%8F%E5%AF%82%E5%AF%9E/"},{"categories":["随笔杂记"],"content":"上大学之后，我对好多东西都很感兴趣，都想亲自去尝试，但是我做事情往往只有三分钟热度，坚持不了多久就会放弃。这样，我的精力被严重分散，我所拥有的知识，虽然有广度，但是没有深度。我知道这样对我长期的发展很不好。 昨天和上海回来的表哥交流，他已经有将近10年的工作经验了，跟他聊天我获得的信息非常有价值。我知道现在互联网行业的残竞争残酷，大家都知道学计算机捞钱，于是都去学计算机，计算机这个江湖很大，其中有很多二五仔进入凑热闹，没过多久他们就会被浪潮淹没，被历史忘记。真正能从江湖中混出来的，勇立潮头的，只有一小部分有真本事的人。 如何让自己成为有“真本事”？我觉得所谓“真本事”，就是那种只有你会，别人都不会的本领。我想起来孙运雷老师给我们的建议，他见我们第一节课就说了一个“一万小时理论”，他说，如果你在一个领域内深耕1万小时，那你一定会成为这个领域的专家。我曾是他的学生，他曾是我的导师，他给我们的建议就是要沉下心来，专心致志地研究一个领域，做好一件事。这个观点，和我表格所传达的是一样的。总结成一句话，就是“宁可要深度，也不要广度。” 高中政治课本上介绍了“主要矛盾”和“次要矛盾”的关系： 在复杂事物发展过程中，处于支配地位，对事物发展起决定作用的矛盾，叫主要矛盾，其他处于从属地位、对事物发展不起决定作用的矛盾叫次要矛盾。主要矛盾和次要矛盾相互依赖、相互影响，在一定条件下可以相互转化。 现阶段，对于我来说，“次要矛盾”就是弹吉他、打篮球、吃饭、谈恋爱、穿衣服、人际关系、读乱七八糟的书、学乱七八糟的知识等等。 而主要矛盾，只有如下两个方面： 写代码 功课（数学分析，离散数学、概率论与数理统计等，其它水课不算） 花花世界迷人眼，找到自己的定位很重要，可能会决定一个人一生的命运。对主要矛盾和对次要矛盾分配的精力是不一样的，对待主要矛盾，要“精益求精”，要抓紧时间，抓住机会，舍得下大力气，下大功夫去解决；对待次要矛盾，要“锦上添花”，有时间就搞一搞，没时间也不强求，但是得养成良好的习惯定期去做，不能浅尝辄止。 主要矛盾就像是人长身体所需要的蛋白质，需要大量摄入；次要矛盾就像是维生素，人需要的量很少，但是如果一点都没有，就会得病。有的团学，走了极端路线，要么只关注主要矛盾，省略了次要矛盾；要么错把主要矛盾抛在一边，把次要矛盾当成了主要矛盾，这更不可取。现在的我，反对极端主义，支持全面发展、协调发展，要统筹规划，理清主次、抓大放小，坚持走一种“中庸之道”。 以上写的都蛮虚的，其实我今晚真正的感悟是：我觉得我代码写得太少了，这段时间研究django、数据库、前端等等乱七八糟的东西，看似学的很多，其实啥都没学会，等到写大作业的时候才发现自己写代码能力很差。李昕老师也强调多次，说大一要把写代码的功底打牢，我现在才意识到我有一点跑偏。 ","date":"2021-05-03","objectID":"/posts/%E7%90%86%E6%B8%85%E4%B8%BB%E6%AC%A1%E9%9B%86%E4%B8%AD%E7%B2%BE%E5%8A%9B%E8%A7%A3%E5%86%B3%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE/:0:0","tags":null,"title":"理清主次，集中精力解决“主要矛盾”。","uri":"/posts/%E7%90%86%E6%B8%85%E4%B8%BB%E6%AC%A1%E9%9B%86%E4%B8%AD%E7%B2%BE%E5%8A%9B%E8%A7%A3%E5%86%B3%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE/"},{"categories":["书影记录"],"content":"今天是世界读书日，我想给大家推荐一本《如何阅读一本书》。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"基本介绍 《如何阅读一本书》初版于1940年，1972年又大幅增订改写为新版，是一本有六十多年历史经典名著。作者是美国作家[莫提默·J·艾德勒]和[查尔斯·范多伦]，二者都参加过《大英百科全书》的编写工作。 如书名所见，这本书的主题就是教人如何阅读一本书。该书介绍了一系列阅读的规则（或者说方法、技巧，下面统称为规则），熟练运用这些规则，可以高效阅读任何一种类型的书。本书主要介绍了四个阅读层次，分别是“基础阅读”、“检视阅读”、“分析阅读”、“主题阅读”，此外，还穿插介绍了如何对一本书做出评价、如何使用辅助工具、有哪些不同种类的读物、阅读对人的作用等等关于“书”的一般性知识。可以说，这本书介绍的内容涉及到了阅读的各个方面。其语言风格偏学院风，结构清晰，表达严谨，理论性强，所以比较难读，再加上又是译著，读起来就更是困难重重了。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"我的感受 我们从小到大，读的书说少也不算少，但是对于“阅读的目的”，“阅读的方法”，“如何挑选一本书”等问题，不能说知之甚少，只能说完全没有思考过。遇到这本书，真是幸运，它让我对“书”这个概念，有了全面的、一般性的了解，让我减少今后阅读书籍时的盲目，像是灯塔一样指引我阅读。 作者的观点我很赞同，比如 “阅读要主动。” 阅读的过程就跟上课一样，上课的时候，大脑要跟着老师一起思考；阅读也是如此，在阅读时，要努力地记忆、思考，这样才是高效的阅读方法，才不至于读了好几页都不知道作者在说什么。很多人拒绝在阅读时主动思考，书籍对他们来说只是消遣的工具，所以他们只能接受通俗作品而不愿意去阅读论述类作品和经典作品。 作者还认为，在你没有真正读懂作者说的东西时，不要轻易评价一本书！这个道理放到网络生活中也同样适用。我们可能经常看到这样的评论：“我不知道你在说什么，但我觉得你说得可能不对。” 这句话一被说出来，就充满了偏见。但是在网络中，这种“键盘侠”的言论无处不在。 古人说“读万卷书行万里路”，因为行万里路之后就会从地方性偏见走出来，就不会认为自己待的地方比其它地方更优越；读万卷书就会走出时代性偏见，因为在读书的过程中会跟过去的时代进行对话，走出时代性偏见，我们这一生从某种意义上来说其实都是在走出偏见。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"坚持养成读书的好习惯 这本书我只是走马观花地读了一遍，吸收了的知识大概只有10%，如果以后有时间，我还想再重新捧读一遍这样的经典作品。养成良好的阅读习惯，是我大学阶段的目标之一。 读书是一件性价比非常非常高的事情。一位作者，研究一个领域几年，甚至几十年得到的成果，写到一本书中，而我们只需要一周的时间阅读这本书，就可以获得这些知识！“读万卷书，行万里路”，作为大学生的我们，可能现在还没有机会“行万里路”，但是图书馆的万卷藏书一直摆在那里，那是知识的海洋，等待着我们去遨游。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"话不多说，看看豆瓣评分吧： 8.8分，对于一个喜剧电影来说，算是不可多得的高分了。排名116名，妥妥的经典。豆瓣评分很多人都有争议，但其实我蛮认同豆瓣评分的。在豆瓣上，评分较高的电影往往都不是靠炫酷的特效或者出名的演员，而是看一部电影是否有内涵，有高超的艺术表现力，这和我评判一部电影是不是“好”电影的标准是一样的。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 公路剧，正男是一个和奶奶相依为命的小学生，菊次郎是一个老混混。阴差阳错，富有童心的菊次郎带着偏早熟的正男一起去找他的妈妈，一路上遇到的各种有趣的事情。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"观影感受 这是一部开头20分钟就能让我眼眶湿润的电影，中间又让我捧腹大笑，笑完之后继续哭，哭完再笑…… 日式幽默真是太合我的胃口了，正好戳中我的笑点，哈哈哈，好多经典桥段真的好有趣。 感觉特别温馨，菊次郎和正男一路上碰到的人都好可爱好友善，影片描绘的“夏天”，正是我理想中的那种夏天的氛围，慵懒、和谐、美好。 影片的叙述手法毋庸置疑是采用一种超现实手法，所有人看起来都呆呆的，在夏天好像都晒昏了头脑。但是一点也不影响故事的趣味性，再一次证明，“艺术源自于生活但是一定高与生活！” ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"独特之处 久石让的配乐真的很到位，《summer》这首歌的名气应该和这部电影“珠联璧合”。 看完之后，我觉得这部电影并没有特别想说明说明道理，也并没有特别想要歌颂什么。就像是音乐一样，贝多芬、莫扎克这样的音乐大师的音乐被称为经典，并不是它们说明了多么深刻的道理，而是它们可以引起观众内心的共鸣。《菊次郎的夏天》这部电影就是让我看的时候觉得非常舒服，让我流泪让我笑，我真是太爱这部电影了。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["技能分享"],"content":"大物实验得到的数据，用python的matplotlib很方便处理 数据准备： r = np.arange(0.5,6.0,0.5) u2 = np.array([6.66,6.49,6.37,6.37,6.17,6.12,6.18,5.98,5.97,5.93,5.91]) i2 = np.array([2.06,2.01,1.97,1.98,1.91,1.90,1.92,1.85,1.85,1.84,1.83]) uw = np.array([0.145,0.259,0.338,0.419,0.467,0.513,0.552,0.586,0.616,0.641,0.663]) n = ((uw*uw)/r)/(u2*i2) # len(r) # r n 画图： import matplotlib.pyplot as plt import numpy as np %matplotlib inline x = np.linspace(0.5,5.5,11) #横坐标11个数据 # y = np.array([0.31,]) #纵坐标11个数据 plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 plt.grid(True)#网格线 plt.title('热机效率随负载大小变化曲线图')#标题 plt.plot(x,n,'r') #显示红线 plt.plot(x, n, 'k.') #显示黑点 plt.xlabel(r'负载大小/R') plt.ylabel(r'热机效率') plt.xticks(x) #重新设置x坐标 plt.show plt.savefig('./热机效率随负载大小变化曲线图.png',dpi=200) #保存图片，清晰度200 效果 ","date":"2021-04-02","objectID":"/posts/matplotlib%E4%BD%9C%E7%83%AD%E6%9C%BA%E6%95%88%E7%8E%87%E9%9A%8F%E8%B4%9F%E8%BD%BD%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF%E5%9B%BE/:0:0","tags":null,"title":"matplotlib作热机效率随负载大小变化曲线图","uri":"/posts/matplotlib%E4%BD%9C%E7%83%AD%E6%9C%BA%E6%95%88%E7%8E%87%E9%9A%8F%E8%B4%9F%E8%BD%BD%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF%E5%9B%BE/"},{"categories":["随笔杂记"],"content":"从开学开始，我就接到了李昕老师的任务——为我们寒假的成果“一种基于docker和jupyter notebook的复合类型题目在线检测方法”撰写一份“专利申请”，并完成申请。第一作者当然是李昕老师，因为我们的核心代码全是李昕老师写的，第二作者包括我和另外一位贡献较大的成员。申请专利并署名我们既是一种奖励，又是一种考验。 申请文件包括四个小文件，分别是“说明书”、“权利要求书”、“说明书摘要”、“说明书附图”。整个撰写过程还是比较困难的，毕竟是从零开始做这种工作，期间除了询问李昕外，还得到了王志宽学长的极大帮助，学长真的很不错！点赞！ 在这个过程中，有如下体会： ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:0","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"撰写说申请书也是一门学问 撰写申请书也是一种学问，甚至有一种职业，就叫专利代理师。他们的工作大致就是帮发明人撰写专利申请。不要小看这项工作的技术难度，它要求专利代理师有非常广阔的知识面（能懂得很多技术），极强的语言表达能力（特别是写说明文的能力）。 “说明书”和“权利要求书”是整个申请文件的两个核心文件。其中说明书写得越详细越好，要把这项技术描述得“前无古人”，这样才能通过专利局的审核。 而权利要求书则要写得简练概括，因为如果把一项发明的特征写得太详细，日后通过权利要求书维权的时候就不容易成功。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"语文真的太重要了 语文真的太重要了，我现在深刻体会到语文真的太重要了。我现在也深刻体会到我的中学语文tm都学了啥几把玩意儿，就是为了考试去背东西，没读过几本书，也没写过什么好文章。 之前一直把语文学偏了，就觉得语文是文人墨客抒发情感，写文章越是让人看不懂越牛逼，净整些没用的玩意儿。其实并不是，学习语文，关键是提升阅读理解能力，语言表达能力。这两种能力，对一个人来说，前者是输入能力，后者是输出能力。马克思说过：“人是一切社会关系的总合”、“一个人只有在社会中才能实现其价值”。而在社会中生活，必定会和外界进行交流，产生输入输出。所以说，语文能力是相当重要的。 写专利说明书的过程中，每一句话都有其意义，每一个标点符号都有要求。比如，如果在下文中提到一个新概念，上文必须有对应的铺垫内容，否则会让人看不懂；权利要求书中每一点权利要求中间不能出现句号，因为一个句号的差别就可能使特征的表述产生歧义，给侵权人反驳的机会。这也是为什么会有人专门从事这样的职业，他们写专利申请考虑到未来可能出现的各种情况，虽然一次收费5k元，但是帮发明人维护了重要的权利。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"收获 收获还是蛮大的，了解了一个新的领域，提升了表达能力以及表达的严谨性。另外，使用word的技巧更熟练了。 又点亮一项技能，进一步降低了以后吃不上饭的可能性。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"任务拆分 一个html页面，左边是题目，右边是文本框，可以编写代码。右下角有一个“提交”按钮，点击之后将代码发送到后台进行评测。 现在已有基于jupyter notebook的评测多个题目的评测代码，需要把它拆分后放在django后台运行。 可能需要用到数据库，统一使用的是mysql ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:1","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"3月23日 正在看白月黑羽的django教程，从http协议开始讲的，讲的很全，边看边做任务。 http://www.python3.vip/tut/webdev/django/http/ ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:2","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"3月27日 学习内容： HTTP协议 明白了浏览器打开网页的大致过程，明白了请求的几种类型get，post等，请求的内容由哪些部分组成，还了解了服务器返回的状态码等 django安装与运行 django在整个web中的角色是application(应用)，如何创建django项目，django项目中包含哪些东西 url路由 路由是干什么的，如何在django项目中配置路由，当路由过多时，该如何配置 ORM的概念 django的数据库为什么可以方便更换，这与orm有关。因为orm，不懂数据库的语句也可以对数据库增删改查 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:3","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月5日 说实话，有些动力不足。学习之路漫长又曲折，但是无论走得有多慢，都要走下去。这几天学的东西如下： 定义数据库表 在models里像定义“类”一样定义数据库字段，这种设计挺巧妙的。 创建数据库表 修改settings，告诉django去创建数据库表 Django Admin管理数据 使用django内置的管理界面 读取数据库数据 编写函数，使得浏览器可以使用get请求获取数据库信息 过滤条件 在上一步的基础上实现了更高级的功能 前后端分离的架构 不使用模板的时候写函数要把数据混在html代码里，使用的“模板”就可以实现前后端分离。明白了“前端”、“后端”、“架构师”之间的关系。还明白了“API接口”到底是什么。 至此，我对web开发的原理越来越明了。但是不具备实操技能，现在让我写代码还是一行也写不出来。继续学习。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:4","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月11日 看到了“数据的增删改查5”的3'58''，“和前端集成”前面。 json是前端和后端沟通的桥梁 后端把从数据库里查到的东西重构成json格式，前端再将json解析成内容填充到网页里，确实很巧妙啊。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:5","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月17日 这周已经把基础知识学完了，开始着手写代码。但是这周有数学分析期中考试，还有很多杂七杂八的事情，时间都被冲散了，拿不出整体的时间，让我很头疼。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:6","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月22日 有头绪啦，有头绪啦！昨天我写出了第一个评测的代码（虽然非常非常简单） 今天遇到的第一个问题： 如何将在页面上写出来后的code，保留原格式传给后台运行？ 李昕老师提示我用富文本框，我打算去看一个bootstrap教程学习。地址如下：https://www.bilibili.com/video/BV1TU4y1p7zU 小姐姐声音很好听。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:7","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"老婆不在家，看点刺激的 ","date":"2021-03-16","objectID":"/posts/pathlib%E5%BA%93/:0:0","tags":null,"title":"pathlib库","uri":"/posts/pathlib%E5%BA%93/"},{"categories":["笔记"],"content":"安装虚拟环境 在Powershell中执行 Set-ExecutionPolicy Unrestricted #执行策略更改 y #yes pip freeze #输出所有在本地已安装的包 pip install virtualenv cd 目标文件夹 virtualenv . #在当前目录创建虚拟环境 .\\Scripts\\activate #切换虚拟环境 deactivate #取消虚拟环境 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"安装django pip install django ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"创建django项目 django-admin startproject 项目名(mysite) cd ./mysite code . #用vscode启动 python manage.py runserver #启动服务器 解决报错信息 python manage.py migrate #注意要在mysite目录下执行 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置路由urls 在虚拟环境中，且在mysite目录下 python manage.py startapp 名字(misterwu) 在mysite的settings.py里的INSTALLED_APPS里添加’misterwu’进行关联 在mysite的urls.py里添加import path,include，再添加一个urlpatterns 在misterwu里新建一个urls.py，把mysite里的urls拷贝到这里 删掉import admin和第二行末尾的path 删掉urlpatterns里的内容 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示html页面 在misterwu的urls.py的urlpatterns里添加 path('',views.home,name=\"home\") 还要在前面添加 from . import views 在misterwu的views.py里定义一个\"home\"方法 def home(request): return render(request,'home.html',{}) 在misterwu下创建一个新文件夹templates，在下面创建home.html，在里面写 \u003ch1\u003ehello world!\u003c/h1\u003e ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"创建公共html模板 打开www.bootcss.com，进入bootstrap4中文文档，初学者模板，拷贝一份 \u003c!doctype html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003c!-- 必须的 meta 标签 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\u003e \u003c!-- Bootstrap 的 CSS 文件 --\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css\" integrity=\"sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l\" crossorigin=\"anonymous\"\u003e \u003ctitle\u003eHello, world!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHello, world!\u003c/h1\u003e \u003c!-- JavaScript 文件是可选的。从以下两种建议中选择一个即可！ --\u003e \u003c!-- 选项 1：jQuery 和 Bootstrap 集成包（集成了 Popper） --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-LCPyFKQyML7mqtS+4XytolfqyqSlcbB3bvDuH9vX2sdQMxRonb/M3b9EmhCNNNrV\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003c!-- 选项 2：Popper 和 Bootstrap 的 JS 插件各自独立 --\u003e \u003c!-- \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js\" integrity=\"sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js\" integrity=\"sha384-gRC4eoaRyQ8xv2X6Mnf+eOIrtON3wId3dAkwO0HQX26OrFBoLpjX/XWOJacSiZhL\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e --\u003e \u003c/body\u003e \u003c/html\u003e 在misterwu下的templates里新建一个base.html，把初学者模板拷贝到这里 然后在home.html里添加代码，最终样子如下: {% extends 'base.html'%} {% block content %} \u003ch1\u003ehello world!\u003c/h1\u003e \u003cp\u003e测试是否可以看到我!\u003c/p\u003e {% endblock %} 然后在base.html的body里调用这个代码块(这种写法貌似是php里的) ... \u003cbody\u003e link1link2link3 {% block content %} {% endblock %} ... ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:6","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示导航信息 在base.html的导航那一部分替换成如下代码： \u003cbr\u003e \u003cdiv class=\"container\"\u003e {% block content %} {% endblock %} \u003c/div\u003e 从bootstap上找到导航条源码 \u003cnav class=\"navbar navbar-expand-lg navbar-light bg-light\"\u003e \u003ca class=\"navbar-brand\" href=\"#\"\u003eNavbar\u003c/a\u003e \u003cbutton class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"\u003e \u003cspan class=\"navbar-toggler-icon\"\u003e\u003c/span\u003e \u003c/button\u003e \u003cdiv class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"\u003e \u003cul class=\"navbar-nav mr-auto\"\u003e \u003cli class=\"nav-item active\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eHome \u003cspan class=\"sr-only\"\u003e(current)\u003c/span\u003e\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eLink\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item dropdown\"\u003e \u003ca class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e Dropdown \u003c/a\u003e \u003cdiv class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eAction\u003c/a\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eAnother action\u003c/a\u003e \u003cdiv class=\"dropdown-divider\"\u003e\u003c/div\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eSomething else here\u003c/a\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link disabled\" href=\"#\" tabindex=\"-1\" aria-disabled=\"true\"\u003eDisabled\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003cform class=\"form-inline my-2 my-lg-0\"\u003e \u003cinput class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"\u003e \u003cbutton class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"\u003eSearch\u003c/button\u003e \u003c/form\u003e \u003c/div\u003e \u003c/nav\u003e 上述代码也粘贴到下面 效果图 把home所在的标签都删掉 dropdown，disabled标签也删掉 把Navbar改掉，如（米斯特务） search也可以改掉 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:7","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"接口介绍 pass ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:8","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"接口请求和解析 在misterwu的views.py的 def home(request)函数中加入以下代码： import requests import json api_request = requests.get(\"https://api.github.com/users?since=0\") api = json.loads(api_request.content) 注意，在虚拟环境里先装requests 然后在return render(request,‘home.html’,{})后面的空字典里添加： return render(request,'home.html',{\"api\":api}) 来到home.html，在{%block content%}…{%endblock%}内添加 \u003cp\u003e{{api}}\u003c/p\u003e 成功！ ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:9","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示数据信息 在misterwu的home.html的block里写入 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e {% for x in api %} \u003cdiv class=\"col-sm\"\u003e \u003cdiv class=\"card\" style=\"width: 18rem;\"\u003e \u003cimg src=\"{{x.avatar_url}}\" class=\"card-img-top\" alt=\"...\"\u003e \u003cdiv class=\"card-body\"\u003e \u003ch5 class=\"card-title\"\u003e{{x.login}}\u003c/h5\u003e \u003cp class=\"card-text\"\u003e{{x.login}}的github\u003c/p\u003e \u003ca href=\"{{x.html_url}}\" class=\"btn btn-primary\"\u003e点进他的博客主页\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr\u003e \u003c/div\u003e\u003e {% endfor %} \u003c/div\u003e \u003c/div\u003e 上面代码中div里的内容是bootstrap4复制来的，原文如下 \u003cdiv class=\"card\" style=\"width: 18rem;\"\u003e \u003cimg src=\"...\" class=\"card-img-top\" alt=\"...\"\u003e \u003cdiv class=\"card-body\"\u003e \u003ch5 class=\"card-title\"\u003eCard title\u003c/h5\u003e \u003cp class=\"card-text\"\u003eSome quick example text to build on the card title and make up the bulk of the card's content.\u003c/p\u003e \u003ca href=\"#\" class=\"btn btn-primary\"\u003eGo somewhere\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:10","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"搜索页面跳转 在misterwu的urls.py的urlpatterns里加入一行： path('user/',views.home,name=\"user\"), 在views.py里加入一个函数: def user(request): return render(request,'user.html',{}) 在templates里创建user.html，写入： {% extends 'base.html'%} {% block content %} \u003ch1\u003ehello user\u003c/h1\u003e {% endblock %} 成功 在base.html的\u003cform class=“form-inline my-2 my-lg-0” \u003e里，再加两个属性 method=\"POST\" action=\"{% url 'user' %}\" 并在下面加入 {% csrf_token %} 之后点搜索，就可以正常跳转了 在base.html的下的里面加一个属性name=“user” 再到views.py里面的函数user里增加语句: user = request.POST['user'] return render最后的字典里面写 {'user':user} 在user.html中改成 hello {{user}} ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:11","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取搜索数据 在base.html的\u003ca class=“navbar-brand” href=\"#\"\u003e米斯特务里添加属性 href = \"{% url 'home' %}\" 在\u003ca class=“nav-link” href=\"#\"\u003eLink里添加属性 href = \"{% url 'user' %}\" “link”改成\"查询\" 在views.py的user函数中修改如下： 妈的，不想记了 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:12","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"map()和apply()和applymap()区别 map()是Series对象的一个函数，DataFrame中没有map()，map()的功能是将一个自定义函数作用于Series对象的每个元素。 apply()函数的功能是将一个自定义函数作用于DataFrame的行或者列 applymap()函数的功能是将自定义函数作用于DataFrame的所有元素 案例可以看这个：https://www.cnblogs.com/jason–/p/11427145.html 讲的非常清晰 能看出map,apply,apply还是蛮有用的，但是上手不太容易 ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"sort_values()和sort_index()区别 1、sort_index() sort_index()通俗点讲，就是根据index的值进行排序，如果是按行排序，可以认为是根据index的值排序，如果是按列排序，可以认为是根据columns的值进行排序。用法如下： ### 按索引排序，需要指定轴和方向，默认为列方向排序 unsorted_df.sort_index()#默认为index升序 unsorted_df.sort_index(ascending=False)#此时为index降序 unsorted_df.sort_index(axis=1,ascending=True,inplace=False,na_position='last') #此时为columns方向升序，inplace指明是否替代原df,na_position指明缺失值的位置（'last'，'first'） unsorted_df.sort_index().sort_index(axis=1,ascending=True,inplace=False,na_position='last') #index和colimns同时排序，可以直接粘在后面 sort_values()对dataframe按某一列的值进行排序，或者按某一行的值进行排序。具体的参数设置如下： # 参数 DataFrame.sort_values（by，axis = 0，ascending = True，inplace = False，kind =' quicksort '，na_position ='last' ） #参数说明 by: str或str的列表，如果axis=0或axis='index'，那么by='列名'；如果axis=1或axis='columns'，那么by='行名' axis: {0或'index';1或'columns'} 默认为0，即纵向排序，如果为1，则为横向排序 ascending: 布尔型，默认为True,即升序 inplace: 布尔型，是否用排序后的数据代替现有数据 kind: 排序算法， {'quicksort'，'mergesort'，'heapsort'}，默认'quicksort' na_position: {'first'，'last'}，默认'last' ,即将缺失值放在最后。 摘自https://blog.csdn.net/u011412768/article/details/107251808 ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"pd.read_csv()参数 df=pd.read_csv(filepath, header=None,encoding=\"gbk\", names=[\"A\",\"B\",\"C\",\"D\",\"E\"], skiprows=1, skipfooter=1, usecols=[\"A\",\"B\",\"C\"], index_col=0, engine=\"python\") ———————————————— 版权声明：本文为CSDN博主「此间的少年1128」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_44056331/article/details/89366105 filepath_or_buffer: 数据输入的路径：可以是文件路径、可以是URL，也可以是实现read方法的任意对象。这个参数，就是我们输入的第一个参数。 还可以是一个URL，如果访问该URL会返回一个文件的话，那么pandas的read_csv函数会自动将该文件进行读取。比如：我们用fastapi写一个服务，将刚才的文件返回。 sep: 读取csv文件时指定的分隔符，默认为逗号。注意：“csv文件的分隔符” 和 “我们读取csv文件时指定的分隔符” 一定要一致。 比如：上面的girl.csv，我们将其分隔符从逗号改成\"\\t\"，如果这个时候还是用默认的逗号分隔符，那么数据读取之后便混为一体。 delimiter: 分隔符的另一个名字，与 sep 功能相似。 header/names: 当names没被赋值时，header会变成0，即选取数据文件的第一行作为列名。 当 names 被赋值，header 没被赋值时，那么header会变成None。如果都赋值，就会实现两个参数的组合功能。 index_col: 我们在读取文件之后，生成的DataFrame的索引默认是0 1 2 3…，我们当然可以set_index，但是也可以在读取的时候就指定某个列为索引。 usecols: 如果列有很多，而我们不想要全部的列、而是只要指定的列就可以使用这个参数。 详细看这篇博文，写得非常好！！https://www.cnblogs.com/traditional/p/12514914.html ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"样式问题 困扰了我很久是pandas样式问题，在这篇博客里写的很详细！ https://www.gairuo.com/p/pandas-style-function ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"视频地址：https://www.bilibili.com/video/BV1Jx411L7LU?p=13\u0026spm_id_from=pageDriver 仅用于学习 感谢莫烦up主 ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:0","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"图中图 import matplotlib.pyplot as plt fig = plt.figure() x = [1, 2, 3, 4, 5, 6, 7] y = [1, 3, 4, 2, 5, 8, 6] # below are all percentage left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 ax1 = fig.add_axes([left, bottom, width, height]) # main axes ax1.plot(x, y, 'r') #r表示red，红颜色 ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_title('title') ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25]) # inside axes ax2.plot(y, x, 'b') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_title('title inside 1') # different method to add axes这是与上面两种不同的增加axes的方法 #################################### plt.axes([0.6, 0.2, 0.25, 0.25]) plt.plot(y[::-1], x, 'g') plt.xlabel('x') plt.ylabel('y') plt.title('title inside 2') plt.show() ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:1","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"次坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.arange(0, 10, 0.1) y1 = 0.05 * x**2 y2 = -1 *y1 fig, ax1 = plt.subplots() ax2 = ax1.twinx() # mirror the ax1将ax1的坐标轴镜像对称过去 ax1.plot(x, y1, 'g-') ax2.plot(x, y2, 'b-') ax1.set_xlabel('X data') ax1.set_ylabel('Y1 data', color='g') ax2.set_ylabel('Y2 data', color='b') plt.show() ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:2","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"Animation动画 import numpy as np from matplotlib import pyplot as plt from matplotlib import animation fig, ax = plt.subplots() x = np.arange(0, 2*np.pi, 0.01) line, = ax.plot(x, np.sin(x)) def animate(i): line.set_ydata(np.sin(x + i/10.0)) # update the data return line, # Init only required for blitting to give a clean slate. def init(): line.set_ydata(np.sin(x)) return line, # call the animator. blit=True means only re-draw the parts that have changed. # blit=True dose not work on Mac, set blit=False # interval= update frequency ani = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=False) # save the animation as an mp4. This requires ffmpeg or mencoder to be # installed. The extra_args ensure that the x264 codec is used, so that # the video can be embedded in html5. You may need to adjust this for # your system: for more information, see # http://matplotlib.sourceforge.net/api/animation_api.html # anim.save('basic_animation.mp4', fps=30, extra_args=['-vcodec', 'libx264']) plt.show() 我试过了，jupyter notebook根本动不了 又试了pycharm，也动不了 完结撒花，再次感谢莫烦老师 ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:3","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["随笔杂记"],"content":"可以进行的学习 matplotlib kaggle刷题pandas等 web前端（css,javascript） Python爬虫实战 继续看课本（这个可能是最无聊的） 现在就好迷，在寝室里不知道学啥。 这样吧，学学云顶之弈把 ","date":"2021-03-02","objectID":"/posts/%E5%BC%80%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%98%8E%E7%A1%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/:0:1","tags":null,"title":"开学第二天明确学习方向","uri":"/posts/%E5%BC%80%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%98%8E%E7%A1%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/"},{"categories":["笔记"],"content":"视频地址：https://www.bilibili.com/video/BV1Jx411L7LU?p=13\u0026spm_id_from=pageDriver 仅用于学习 感谢莫烦up主 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:0","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"image图片 import matplotlib.pyplot as plt import numpy as np # image data a = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3) \"\"\" for the value of \"interpolation\", check this: http://matplotlib.org/examples/images_contours_and_fields/interpolation_methods.html 参数interpolation见下图 for the value of \"origin\"= ['upper', 'lower'], check this: http://matplotlib.org/examples/pylab_examples/image_origin.html 参数origin如果为'upper'图像就会反过来 \"\"\" plt.imshow(a, interpolation='nearest', cmap='bone', origin='lower') plt.colorbar(shrink=.92) #shrink压缩到百分之九十二 plt.xticks(()) plt.yticks(()) plt.show() interpolation参数有这些 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:1","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"3D数据 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D #添加3D坐标轴显示 fig = plt.figure() ax = Axes3D(fig) #在figure上加一个3D的Axes # X, Y value X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X ** 2 + Y ** 2) # height value 高度是Z轴 Z = np.sin(R) #创建3D图 ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow')) \"\"\" r代表row, c代表col， rstride和cstride都是控制跨度的参数，简单理解，就是控制这个3D图像的稠密程度 ============= ================================================ Argument Description ============= ================================================ *X*, *Y*, *Z* Data values as 2D arrays *rstride* Array row stride (step size), defaults to 10 *cstride* Array column stride (step size), defaults to 10 *color* Color of the surface patches *cmap* A colormap for the surface patches. *facecolors* Face colors for the individual patches *norm* An instance of Normalize to map values to colors *vmin* Minimum value to map *vmax* Maximum value to map *shade* Whether to shade the facecolors ============= ================================================ \"\"\" # I think this is different from plt12_contours #在3D图下面创建一个等高线图 ax.contourf(X, Y, Z, zdir='z', offset=-2, cmap=plt.get_cmap('rainbow')) \"\"\" zdir='z'表示这个等高线图是从z轴压下去的，offset表示把等高线图放到-2这个位置 ========== ================================================ Argument Description ========== ================================================ *X*, *Y*, Data values as numpy.arrays *Z* *zdir* The direction to use: x, y or z (default) *offset* If specified plot a projection of the filled contour on this position in plane normal to zdir ========== ================================================ \"\"\" ax.set_zlim(-2, 2) plt.show() ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:2","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"Subplot 多合一显示 import matplotlib.pyplot as plt # example 1: ############################### plt.figure(figsize=(6, 4)) # plt.subplot(n_rows, n_cols, plot_num) plt.subplot(2, 2, 1) #2行2列，共4张图，编辑第1张图 plt.plot([0, 1], [0, 1]) plt.subplot(222) #2行2列，共4张图，编辑第2张图，这里不写逗号也可以识别（惊了） plt.plot([0, 1], [0, 2]) plt.subplot(223) #2行2列，共4张图，编辑第3张图 plt.plot([0, 1], [0, 3]) plt.subplot(224) #2行2列，共4张图，编辑第4张图 plt.plot([0, 1], [0, 4]) plt.tight_layout() # example 2: ############################### plt.figure(figsize=(6, 4)) # plt.subplot(n_rows, n_cols, plot_num) plt.subplot(2, 1, 1) # figure splits into 2 rows, 1 col, plot to the 1st sub-fig plt.plot([0, 1], [0, 1]) plt.subplot(234) # figure splits into 2 rows, 3 col, plot to the 4th sub-fig plt.plot([0, 1], [0, 2]) plt.subplot(235) # figure splits into 2 rows, 3 col, plot to the 5th sub-fig plt.plot([0, 1], [0, 3]) plt.subplot(236) # figure splits into 2 rows, 3 col, plot to the 6th sub-fig plt.plot([0, 1], [0, 4]) plt.tight_layout() plt.show() figure1 figure2 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:3","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"Subplot分格显示 import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec # 方法一：method 1: subplot2grid ########################## plt.figure() ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) # 分3行3列的格子，从(0,0)开始，跨列=3,跨行colspan默认为1 ax1.plot([1, 2], [1, 2]) ax1.set_title('ax1_title') ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2) ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2) ax4 = plt.subplot2grid((3, 3), (2, 0)) ax4.scatter([1, 2], [2, 2]) ax4.set_xlabel('ax4_x') ax4.set_ylabel('ax4_y') ax5 = plt.subplot2grid((3, 3), (2, 1)) # 方法二：method 2: gridspec ######################### plt.figure() gs = gridspec.GridSpec(3, 3) # use index from 0 ax6 = plt.subplot(gs[0, :]) ax7 = plt.subplot(gs[1, :2]) ax8 = plt.subplot(gs[1:, 2]) ax9 = plt.subplot(gs[-1, 0]) ax10 = plt.subplot(gs[-1, -2]) # 方法三：method 3: easy to define structure #################################### f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True) #用ax11,ax12,ax13,ax14接收返回的第一行第一列图，第一行第二列图，第二行第一列图，第二行第二列图 ax11.scatter([1,2], [1,2]) plt.tight_layout() plt.show() method1和method2效果图 method2 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:4","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"内容均来源于：https://www.bilibili.com/video/BV1Jx411L7LU?p=9\u0026spm_id_from=pageDriver 仅供学习使用 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:0","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Legend图例 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() # set x limits plt.xlim((-1, 2)) plt.ylim((-2, 3)) # set new sticks new_sticks = np.linspace(-1, 2, 5) plt.xticks(new_sticks) # set tick labels plt.yticks([-2, -1.8, -1, 1.22, 3], [r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) l1, = plt.plot(x, y1, label='linear line') #这里前面加个“l1 = ”是接收返回对象，如果不用到下面的handles，就没必要接收这个对象了，直接写语句就可 l2, = plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line') plt.legend(loc='upper right') # plt.legend(handles=[l1, l2], labels=['up', 'down'], loc='best')这是在显示图例的时候没有使用本来的信息，而是又自己设置了一遍，把原来的覆盖了，估计这辈子都不会用到这么麻烦的把哈哈 # the \",\" is very important in here l1, = plt... and l2, = plt... for this step如果要用到handles,就必须把l1和l2后面加个逗号 \"\"\"legend( handles=(line1, line2, line3), labels=('label1', 'label2', 'label3'), 'upper right') The *loc* location codes are:: 'best' : 0, (currently not supported for figure legends) 'upper right' : 1, 'upper left' : 2, 'lower left' : 3, 'lower right' : 4, 'right' : 5, 'center left' : 6, 'center right' : 7, 'lower center' : 8, 'upper center' : 9, 'center' : 10,\"\"\" plt.show() 简单省事儿的写法 plt.plot(x, y1, label='linear line') plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line') plt.legend(loc='best')#自动选择好的位置显示图例，图例中每条线原本的label也会显示 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:1","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Annotation标注 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y = 2*x + 1 plt.figure(num=1, figsize=(8, 5),) plt.plot(x, y,) ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) x0 = 1 y0 = 2*x0 + 1 plt.plot([x0, x0,], [0, y0,], 'k--', linewidth=2.5) #画一条从(x0,y0)垂直到x轴的虚线 plt.scatter([x0, ], [y0, ], s=50, color='b') #在(x0,y0)上标记一个点 #下面的太几把麻烦了，不研究了 # method 1: ##################### plt.annotate(r'$2x+1=%s$' % y0, xy=(x0, y0), xycoords='data', xytext=(+30, -30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-\u003e', connectionstyle=\"arc3,rad=.2\")) # method 2: ######################## plt.text(-3.7, 3, r'$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$', fontdict={'size': 16, 'color': 'r'}) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:2","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"坐标轴刻度（tick能见度） import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y = 0.1*x plt.figure() plt.plot(x, y, linewidth=10, zorder=1) # set zorder for ordering the plot in plt 2.0.2 or higher plt.ylim(-2, 2) ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) # set zorder for ordering the plot in plt 2.0.2 or higher label.set_bbox(dict(facecolor='white', edgecolor='none', alpha=0.8, zorder=2)) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:3","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Scatter散点图 import matplotlib.pyplot as plt import numpy as np n = 1024 # data size X = np.random.normal(0, 1, n) #正态分布生成散点 Y = np.random.normal(0, 1, n) ##正态分布生成散点 T = np.arctan2(Y, X) # for color later on这个公式是表示颜色的，超纲 plt.scatter(X, Y, s=75, c=T, alpha=.5) #s是size,c是color,alpha是透明度 plt.xlim(-1.5, 1.5) plt.xticks(()) # ignore xticks 将ticks设置为空白 plt.ylim(-1.5, 1.5) plt.yticks(()) # ignore yticks plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:4","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Bar柱状图 import matplotlib.pyplot as plt import numpy as np n = 12 X = np.arange(n) Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) #uniform均匀分布 Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') #“+”号是向上的柱状图 plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') #“-”号是向下的柱状图 for x, y in zip(X, Y1): # ha: horizontal alignment 水平位置 # va: vertical alignment 垂直位置 plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='center', va='bottom') #默认宽度0.8，通过加0.4来偏移到中间（其实不太懂qwq），y+0.05是不让柱状图上显示的文本与柱状图靠的太近 #'%.2f'%y 是对于传进来的数值保留两位小数 for x, y in zip(X, Y2): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, -y - 0.05, '%.2f' % y, ha='center', va='top') plt.xlim(-.5, n) plt.xticks(()) plt.ylim(-1.25, 1.25) plt.yticks(()) plt.show() 演示中的柱状图有两条，实际中一般用的用一条就够了 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:5","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Contours等高线图 import matplotlib.pyplot as plt import numpy as np def f(x,y): # the height function 计算高度的函数，不需要太关心 return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2) n = 256 x = np.linspace(-3, 3, n) y = np.linspace(-3, 3, n) X,Y = np.meshgrid(x, y) # use plt.contourf to filling contours填充颜色 # X, Y and value for (X,Y) point plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.hot) #X,Y是横纵坐标，f(X,Y)是高度，8是稠密程度，alpha是透明度，显示“hot”类型的等高线图 # use plt.contour to add contour lines画等高线 C = plt.contour(X, Y, f(X, Y), 8, colors='black', linewidth=.5) # adding label 加入label plt.clabel(C, inline=True, fontsize=10) #画在contour对象C上面，画在线内，粗细为10 plt.xticks(()) plt.yticks(()) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:6","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"上一篇我们讲了怎么用 json格式保存数据，这一篇我们来看看如何用 csv模块进行数据读写。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"一、csv简介 CSV (Comma Separated Values)，即逗号分隔值（也称字符分隔值，因为分隔符可以不是逗号），是一种常用的文本格式，用来存储表格数据，包括数字或者字符。 csv的使用很广泛，很多程序都会涉及到 csv的使用，但是 csv却没有通用的标准，所以在处理csv格式时常常会碰到麻烦。 因此在使用 csv时一定要遵循某一个标准，这不是固定的，但每个人都应该有一套自己的标准，这样在使用 csv时才不会犯低级错误。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:1","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"二、csv库的使用 关于 csv库的使用，我们从写和读两个方面来讲。 csv库有四个主要的类 writer，DictWriter，reader，DictReader reader和 DictReader都接受一个可以逐行迭代的对象作为参数，一般是一个包含 csv格式数据的文件对象。 writer和 DictWriter则接受一个 csv文件对象，csv格式的数据将会写入到这个文件中。 他们都会返回一个对应的对象，我们通过这个对象来进行数据的读和写。 这四者中 reader和 writer对应，DictReader和 DictWriter对应，也就是说通过 writer类写的 csv文件只能通过 reader类来读取，DictReader同理。 1、csv将数据写入文件 #-*- coding: utf-8 -* import csv #通过 writer类写入数据 #待写入的数据 注意到两个列表的元素个数不一样 test_writer_data_1 = ['Tom', 'Cody', 'Zack'] test_writer_data_2 = ['Mike', 'Bill'] #创建并打开文件 with open('test_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #获得 writer对象 delimiter是分隔符 默认为 \",\" writer = csv.writer(csvfile, delimiter=' ') #调用 writer的 writerow方法将 test_writer_data写入 test_writer.csv文件 writer.writerow(test_writer_data_1) writer.writerow(test_writer_data_2) #通过 DictWriter类写入数据 #待写入的数据 注意到待写入的数据类型为 dict 且第二个字典没有 lastname test_dict_writer_data_1 = {'firstname': 'Tom', 'lastname': 'Loya'} test_dict_writer_data_2 = {'firstname': 'Tom', 'lastname': 'Loya'} #创建并打开文件 with open('test_dict_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #设置表头 fieldnames=['firstname', 'lastname'] # 获得 DictWriter对象 delimiter是分隔符 默认为 \",\" 表头为 'firstname' 'lastname' dict_writer = csv.DictWriter(csvfile, delimiter=' ', fieldnames=fieldnames) #第一次写入数据先写入表头 dict_writer.writeheader() #调用 DictWriter的 writerow方法将 test_dict_writer_data写入 test_dict_writer.csv文件 dict_writer.writerow(test_dict_writer_data_1) dict_writer.writerow(test_dict_writer_data_2) 前面讲到，csv没有统一的标准，通过上面的例子我们可以发现，csv对写入的数据不做任何检查，也就是说几乎没有任何标准可言。 我们发现 writerow方法不会对数据进行检查，即使前后两句 writerow语句写入的数据的格式不同也不会报错。 所以在用 csv写入数据时要特别注意数据的格式问题！！！ 也可以用 writerows(list) 一次写入多行，例如： with open('test_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #获得 writer对象 delimiter是分隔符 默认为 \",\" writer = csv.writer(csvfile, delimiter=' ') #调用 writer的 writerows方法将 test_writer_data写入 test_writer.csv文件 writer.writerows([test_writer_data_1, test_writer_data_2]) with open('test_dict_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #设置表头 fieldnames=['firstname', 'lastname'] # 获得 DictWriter对象 delimiter是分隔符 默认为 \",\" 表头为 'firstname' 'lastname' dict_writer = csv.DictWriter(csvfile, delimiter=' ', fieldnames=fieldnames) #第一次写入数据先写入表头 dict_writer.writeheader() #调用 DictWriter的 writerows方法将 test_dict_writer_data写入 test_dict_writer.csv文件 dict_writer.writerows([test_dict_writer_data_1, test_dict_writer_data_2]) 2、csv从文件读取数据 #-*- coding: utf-8 -* import csv #通过 reader读取文件内容 注意到之前我们设置了 delimiter为空格，这里也要继续设置为空格 with open('test_writer.csv', 'r', newline='', encoding='utf-8') as csvfile: reader = csv.reader(csvfile, delimiter=' ') for row in reader: print(row) with open('test_dict_writer.csv', 'r', newline='', encoding='utf-8') as csvfile: dict_reader = csv.DictReader(csvfile, delimiter=' ') for row in dict_reader: print(row) 打印结果： 观察打印出的结果我们发现，reader读取的内容打印出来后还是列表格式，而 DictReader读取的内容却变为了列表加元组的格式，显然和我们刚开时传入的字典格式很不同。 而我们总是希望输入和输出能够一致，但是 csv模块并没有提供这样的方法，所以我们需要自己将 csv模块再进行一次封装，封装后的包应该满足下面的标准： 统一的分隔符 delimiter 统一的编码 统一的打开文件的方式 能够自己判断文件是否存在并且选择合适的方式打开文件 输入格式和输出格式保持一致 强制检查格式，格式错误禁止插入并报错 封装后的包的源码会在完成后贴出(￣▽￣)\" 最后让我们来总结一下使用 csv库的注意事项： 打开文件时要 注意模式 读用 r，写用 w 打开文件时要设置 newline=''（空字符） 打开文件时要指定编码打开，写入时也一样 如果设置过分隔符就要一直保持，读写时的分隔符必须一致 csv不会检查格式（虽然有个 strict模式，但 strict模式下也不会对格式进行检查），写入文件时一定要注意格式 以上就是 csv库的使用方法和注意事项，觉得不错就点个赞吧(●ˇ∀ˇ●) 作者：渔父歌 链接：https://www.jianshu.com/p/51211fcdf4b8%20 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:2","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"转载自https://www.jianshu.com/p/0ba2b643c0f2 在上一篇文章里我们讲了 xpath写法的问题还以爬取我的文章信息写了示例，但是在上一篇中我们只是爬取并打印了信息，并没有对信息进行保存。 实际应用中爬取到的信息肯定是需要保存到本地的。保存信息的方式有数据库和文件的形式，数据库我们后面再讲，现在让我们先看看怎么把信息保存到文件里。 这里我们主要讲讲 将数据保存为 json格式和 csv格式，这就要用到两个库 json库和 csv库，这两个库都是 python自带的库。 关于数据存储我们分两篇来讲，这一篇先讲 json，下一篇再讲 csv。 ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:0","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"一、关于 json json的简介直接引用百度百科的定义： JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 实际上 json的格式和 python中的字典很像，也是由键值对组成，但是 python中的值可以为任何对象（列表、字典、字符串、数字等等），而 json中的值只能是数组（列表）、字典、字符串、数组、布尔值中的一中或几种。 其格式就像下面这样： 注意：json中的引号必须是双引号，否则会报错 { \"key1\": \"value1\", \"key2\": [1,2,\"value2\"], \"key3\": { \"key31\": \"value1\", \"key32\": [1,2,\"value2\"], \"key33\": true, }, } ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:1","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"二、json库的使用 json库一共有三个方法，分别是 dump、dumps、load、loads。 其中 dump和 dumps是用来把把字典和数组转换为 json格式的，dump把转换结果直接写入文件，dumps返回字符串。 load和 loads是把 json格式的数据转换为字典格式，load直接从 json文件中读取数据并返回字典对象，loads把字符串形式的 json数据转换成字典格式。 下面讲讲这些方法的具体用法。 1、dump和 dumps dump的函数原型是 dump(obj, fp) 第一个参数 obj是要转换的对象，第二个参数 fp是要写入数据的文件对象。 dumps的函数原型是 dumps(obj) 参数是要转换的对象 注意：如果要转换的对象里有中文字符的话，要把 ensure_ascii设置为 False否则中文会被编码为 ascii格式 #-*- coding: utf-8 -* import json test = { \"key1\": \"value1\", \"key2\": [1,2,\"value2\"], \"key3\": { \"key31\": \"value1\", \"key32\": [1,2,\"value2\"], \"key33\": True, \"key34\": \"测试\", }, } #没有设置 ensure_ascii为 False with open('test.json', 'w', encoding='utf-8') as fp: json.dump(test, fp) #设置了 ensure_ascii为 False with open('test_no_ascii.json', 'w', encoding='utf-8') as fp: json.dump(test, fp, ensure_ascii=False) #test.json的文件内容为： #{... ... \"key33\": true, \"key34\": \"\\u6d4b\\u8bd5\"}} #test_no_ascii.json的文件内容为： #{... ... \"key33\": true, \"key34\": \"测试\"}} #注意到 python中的 True转换成了 Javascript里的 true #另外在打开文件的时候强烈建议用 encoding指定文件编码 #还需要注意文件的打开模式 w是写入，文件已存在的话就覆盖 #要追加写入的话记得用 a模式打开 test_string = json.dumps(test, ensure_ascii=False) print(test_string) 打印结果： 2、load和 loads load的函数原型是 load(fp) 参数 fp是要读取的文件对象 loads的函数原型是 loads(string) 参数 string是要转换成 python对象的 json字符串，通常用来将网页中的 json数据转换为 python对象 #-*- coding: utf-8 -* import json #json格式的字符串 test_string = '{\"key1\": \"value1\", \"key2\": [1, 2, \"value2\"], \"key3\": {\"key31\": \"value1\", \"key32\": [1, 2, \"value2\"], \"key33\": true, \"key34\": \"测试\"}}' #从之前保存的 test_no_ascii.json中读取 注意模式为 r with open('test_no_ascii.json', 'r', encoding='utf-8') as fp: json_obj_from_file = json.load(fp) json_obj_from_web = json.loads(test_string) #打印两个返回结果的类型 print(type(json_obj_from_file)) print(type(json_obj_from_web)) #打印两个返回结果的内容 print(json_obj_from_file) print(json_obj_from_web) 打印结果 json的dump和dumps的区别 dumps是将dict转化成str格式，loads是将str转化成dict格式。 dump和load也是类似的功能，只是与文件操作结合起来了。 ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:2","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"学习视频地址：https://www.bilibili.com/video/BV1Jx411L7LU? github地址：https://github.com/MorvanZhou/tutorials/tree/master/matplotlibTUT ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:0","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"基本语法 ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:1","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"一个figure就是一张图片 这里有两个figure(两张图)，其中第二个figure有两个plot(两条线) ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:2","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"设置坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y2) # plot the second curve in this figure with certain parameters plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') # set x limits plt.xlim((-1, 2)) #限制x坐标轴范围 plt.ylim((-2, 3)) #限制y坐标轴范围 plt.xlabel('I am x') #x轴的名字 plt.ylabel('I am y') #y轴的名字 # set new sticks new_ticks = np.linspace(-1, 2, 5) #np数组 print(new_ticks) plt.xticks(new_ticks) #设置新ticks # set tick labels设置tick的标签，这些是一一对应的，反斜杠加空格是空格的转义字符，加$符号变成好看的斜体 plt.yticks([-2, -1.8, -1, 1.22, 3], [r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) plt.show() 移动坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y2) # plot the second curve in this figure with certain parameters plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') # set x limits plt.xlim((-1, 2)) plt.ylim((-2, 3)) # set new ticks new_ticks = np.linspace(-1, 2, 5) plt.xticks(new_ticks) # set tick labels plt.yticks([-2, -1.8, -1, 1.22, 3], ['$really\\ bad$', '$bad$', '$normal$', '$good$', '$really\\ good$']) # to use '$ $' for math text and nice looking, e.g. '$\\pi$' # gca = 'get current axis'，获取当前正在编辑的这张图的坐标轴 ax = plt.gca() ax.spines['right'].set_color('none') #把右边和上边的边框线的颜色设置成“无”,\"spines\"翻译成“脊梁”？？？ ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') #用“下面”的轴的ticks代替“x坐标轴”的ticks,有如下参数可选（其实不太明白qwq） # ACCEPTS: [ 'top' 'bottom' 'both' 'default' 'none' ] ax.spines['bottom'].set_position(('data', 0)) #设置下面“脊梁”的位置（即x轴的位置），以“data”的方式，设置在y轴的0刻度上 # the 1st is in 'outward' 'axes' 'data' 还可以用其它方式确定这个位置，比如outer，axes这些 # axes: percentage of y axis # data: depend on y data ax.yaxis.set_ticks_position('left') #用“左边”的轴的ticks代替“y坐标轴”的ticks,有如下参数可选 # ACCEPTS: [ 'left' 'right' 'both' 'default' 'none' ] ax.spines['left'].set_position(('data',0)) #把y轴位置设置在x轴的0刻度上 plt.show() ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:3","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["书影记录"],"content":"《喜剧之王》是一部周星驰导演的经典电影，但我仅仅有所耳闻，并没有看过全片。去年春节时，周星驰导演的《新喜剧之王》上映，当时我在准备高考，所以没有任何关注，也不知道这部电影被网友称为烂片。直到今天，我在b站找电影看时偶然发现了这部电影，就凭这部电影是周星驰导演，我果断觉得点进去看看。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 主要讲的就是一个叫如梦的年轻女演员，性格十分单纯。她是个十足的倒霉蛋，做演员十多年任然只是一个跑龙套的，男朋友是个骗子，闺蜜成为明星之后也抛弃了她。但是也偶尔有她自己的幸运，比如父母很爱她，有一个富二代喜欢上了她。尽管生活那么艰辛，她还是像打不死的小强，一直在努力奋斗。最后成功当上最佳女主角的励志故事。 题材就是这么一个丑小鸭变白天鹅的经典题材，顺便再歌颂一下父爱母爱，经典题材不免有一些老套，但是老套不一定是缺点。比如说，任天堂出的《塞尔达传说旷野之息》这款游戏，它的剧情可以用“勇者斗恶龙救公主” 八个字概括，但是这并不影响它成为神作，它的剧情一样可以让人感动到落泪。而我在看这部《新喜剧之王》时，也多次感动得热泪盈眶。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"特点 这部《新喜剧之王》，和《喜剧之王》一样都有极端的人设，画面具有强烈的表现力，这一点很符合我的胃口。很多人说这种电影太不真实了，拍得没意义。我强烈反对，艺术来自于生活，但艺术高于生活。电影，小说等这些艺术形式，就应该是从真实生活中抽象出来的。 电影很短。两个半小时的时间里，它要讲述那么长的故事，还要让你印象深刻，引起你的思考，让你落泪，如果过于追求真实，剧情就像白开水一样平淡无味，那还看个卵的电影，去看纪录片不香么。 继续说特点，挺搞笑的，还有…我想想啊….好像就没啥特点了….和《美人鱼》，《喜剧之王》相比，总感觉少了点那味儿，感觉都不像是周星驰导的电影了。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"败笔 上面提到的，就是这部电影的败笔—-没那味儿了。 电影讲的不是粤语，镜头太干净，思路太清晰，还有好多互联网广告（58同城，荣耀手机）…看到广告的时候真是太出戏啦！！ 这部电影很多桥段都是十分动人的，单独拿出来看绝对堪称经典片段，但是，一块老鼠屎坏了一锅好汤，电影中的那些商业元素就是老鼠屎。 再扯一扯我们所处的时代，现在是短视频时代，大家都在变得浮躁，在这种浮躁的心态下，经典，往往是不能被欣赏的。打个比方，《2001太空漫游》这部电影如果把名字改成《2077太空漫游》在2021年上映，绝对会被骂惨。因为这部电影没啥剧情，镜头单调，节奏巨慢，不符合2021年观众的胃口。2021年观众比较喜欢《流浪地球》这种类型，看着爽就完事儿了。谁闲着没事儿去研究镜头背后蕴含的深刻含义呢？这可能就是这部《新喜剧之王》被大家骂的这么惨的时代原因吧。 总体来说，这部《新喜剧之王》，其实我觉得还是很不错的，星爷的电影我都很喜欢。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"发现宝藏视频和宝藏up主，讲的内容正是我的疑惑点。 https://www.bilibili.com/video/BV1Pg4y1z7Lr?from=search\u0026seid=13958657789515093044 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"导入 from bs4 import BeautifulSoup #导入模块 soup = BeautifulSoup(text,‘lxml’) #实例化BeautifulSoup对象 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取所有的div标签 divs = soup.find_all(‘div’) print(divs) divs不是列表，是bs4的ResultSet，输出结果是一个列表形式，每个div作为列表中的一个元素 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取指定的div标签 div = soup.find_all(‘div’)[1] print(div) #输出第二个数据，还可以切片，不举例了 div = list(soup.find_all(‘div’)) 把结果转换成列表，还是很方便的 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取拥有指定属性的标签(id=even的div标签) 方法一： divs = soup.find_all(‘div’,id=‘even’) 如果指定属性是class，会与Python关键字冲突，改为class_ 方法二： divs = soup.find_all(‘div’,attrs={“id”:“even”,“class”:“L square”}) #以字典的形式找到多个指定属性的div标签 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取标签的属性值 alist = soup.find_all(‘a’) 方法一：通过下标方式提取 for a in alist: href = a[‘href’] print(href) 方法二：利用attrs方法提取 for a in alist: href = a.attrs[‘href’] print(href) ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"输出文字 使用string方法 print(div.string) ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:6","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"14年的电影，男主是莱昂纳多·迪卡普里奥。晚上12:05分看完这部三个小时的电影，到凌晨4点我都没有睡着觉。 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 主要讲的就是一个年轻人去华尔街当股票经理，结果倒霉的是，上班第一天就遇到金融危机。幸运的是，还遇到了人生导师，教他吸大麻打飞机。 公司破产后，他也学会了搞传销（果然在大公司里就是能学到东西），然后就带着一群人搞传销卖股票，还创建了一个公司。最先跟他干的那个人，看他这么能赚钱，于是主动找他聊天，跟他聊了一会就立刻决定把本职工作辞掉，很有魄力，最后成了二老板。 最后他们被FBI逮到，坐牢去了，干了这么多坏事，也就坐2年牢。 电影重点不是讲述这个搞传销的年轻人是怎么奋斗的，也不是讲这帮人最后怎么被绳之以法的，而是花了大量的篇幅讲男主（下面简称为“搞传销的”）是怎么挥霍这些钱财的。 “搞传销的”住豪宅，买豪车，，喝香槟，嫖名娼…这些东西即使是像我们这样穷人，也在想象力范围之内。 出乎你想象力的是，“搞传销的”把办公室开成了妓院！职员天天上班的时候一边捞钱，一边“释放压力”。男厕所的镜子前中出，摩天大楼的透明电梯里口X… “搞传销的”染上毒瘾，毒品藏在家里到处都是，他也随身携带着大麻，瘾上来了就吸一口。他还有性癖，嫖娼的时候不喜欢戴套，举办舞会的时候认识一个很漂亮的有夫之妇，就跟到她家把她给上了。这件事被老婆发现之后，果断选择跟老婆离婚，这才是真男人（误 电影的尺度非常非常大，单从情涩这个角度看，堪比AV，比AV还牛逼的是这部电影里的女优是三点全露不打码，而且个个都是影星级别的辣妹。 来源：ASC杂志（此文是官方授权翻译，如需转载，请标明来源影视工业网，十分感谢） 作者：Michael Goldman 翻译：吴晓晖 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"风格 电影是表现力极强，非常非常浮夸。男主莱昂纳多·迪卡普里奥还在前一年演过一部《了不起的盖茨比》，这两部电影都是看了之后让人印象非常深刻的。 我们在看电影的时候，会不由自主把自己代入到电影中，与主角感同身受，看这部电影的时候，我脑子里一直就是这个感觉“有钱太TM爽啦！” ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"思考 虽然看完之后我非常震惊，但我脑子里就一个“爽”字，没有任何思考的空间了。随便想了想，有以下几点： 上个世纪8,90年代，大量的精英来到华尔街，剥削“穷人”，大发股票横财，挥霍金钱。但是“穷人”们的生活其实也不差，至少比发展中国家好多了，所以美国那时候是真正的黄金时代，暴富的人肆意挥霍，没暴富的人做暴富的美梦，进入21世纪后才发现全都是泡沫，是一刹的花火。 我真的想不明白这电影是怎么拍出来的，怎么在美国放映的，尺度如此之大，涉及了毒品，性，还有敏感的政治问题。2004年那时候肯定是引起了轩然大波，那时候我才2岁，真想穿越回去调查一下。 最后，十分推荐这部电影，看完之后会对自己当前的生活有新的思考。 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"感慨 网上的教程好多好乱，我照着其中的一个做，差点把我网站给干没了。以后搞东西之前，一定要备份！！！！ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:1","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"思路 大致就是，先在腾讯云申请了一个免费的证书，然后下载是一个压缩文件，有用的是里面的Apache的配置文件（因为我的wordpress是跑在Apache上的） 然后在宝塔面板里安装，手动安装太麻烦，宝塔面板安装还是挺方便的，点赞。 最后进到wordpress里设置里，改下链接的形式，把http改成https，安装一个插件really simple ssl，把其它还没改过来的都自动改掉。 另外，细节还是蛮多的，比如说要设置各种安全组，各种尝试之后这就是不懂原理就进行操作的坏处，最后目的虽然实现了，但是现在被我搞得有点乱。反正我是不想再尝试第二遍了。 ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:2","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"走过的弯路 一定要提前备份！！！幸好宝塔，wordpress这两个软件 用的人挺多，网上教程也多，我参考了好多教程，才没有陷入僵局。 宝塔自己也提供一种免费的ssl证书，但是这个证书现在chrome,edge浏览器都是不认账的，网页根本进不去！这一步卡了我好久，我不知道问题出在哪了，还以为是自己配置过程出了差错，为此我还反复修改数据库，被迫学会了进入phpmyadmin，服了。 在安装了不安全的证书情况下，chrome，edge浏览器都进不去，但是手机上的via可以进，是否意味着via不够安全？ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:3","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"感想 其实我经常像这样去折腾一些东西，往往“折腾”的过程都非常不顺利。但是基本上我最后都能成功，而且每次折腾完都有不少收获。 一开始，我就想折腾一个博客，能写点东西就行。后来，我觉得博客太丑了，就折腾博客的主题。再后来，觉得我应该折腾个域名。再再后来，我又折腾了https。。。 探索无止境，每次折腾都是勇敢迈向未知，路漫漫其修远兮，吾将上下而求索！ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:4","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["随笔杂记"],"content":"时间？ 我是从去年暑假开始学吉他的，到目前为止也就刚好半年吧。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"学的好不好？ 学的还是挺不错的，也就半年的时间，上了不超过20节课（每节一个小时）我现在已经能弹很多很多流行歌曲了。每隔一段时间我都能找到一首我特别想弹唱的歌，“把我喜欢的歌弹出来” 这就是我学吉他的最大动力。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"除了会弹吉他，还有哪些收获？ 有机会能到琴行做做客，那里的氛围我很喜欢，那里的人甚至比学校里的同学还好相处。 遇见了两个吉他老师，除了教我弹吉他，还对我进行艺术熏陶。我与他们交流的过程中，学到很多音乐的知识，确实感受到了音乐的魅力。打个比方，你没打王者荣耀之前，看别人玩王者荣耀就跟个弱智似的，但是有一天你朋友拉你入坑，你就掉坑里出不去了。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"总结 吉他是一门下限比较低，上限比较高的一门乐器。对于我来说，学习吉他是一件性价比很高的事情，弹吉他不仅可以打发时间，而且特别装逼。尤其是当你跟你朋友相处了很久之后，他/她突然发现你竟然点亮了吉他这个技能点，那么你在他/她心中的地位会提高的。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["刷题"],"content":"https://www.bilibili.com/video/BV1A4411v7b2?p=34\u0026spm_id_from=pageDriver 这个课讲得真是太好了，很少能有把复杂抽象的知识讲得这么清楚的老师 打算一口气把这个看完 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:0","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["刷题"],"content":"2月3日 现在看到62集了，看到这个人的笔记记得还不错，以后如果知识点忘了可以作为参考 https://blog.csdn.net/qq_41872653/article/details/109256914 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:1","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["刷题"],"content":"2月4日 看到74集，不想再看了，因为到此为止，课本已经上的内容已经都能很好理解了，再深入学习，就凭个人兴趣了。而且，看了知乎上的回答，学习数据分析没必要深入学习面向对象，毕竟我们在进行数据分析的时候更多地是在调用别人写的包，而不是自己写包，数据分析遇到的问题都是临时性的，不至于写包。 最主要的原因，是越往后看，我越觉得老师讲的内容越生僻，学习的性价比不高。再加上李昕老师强调了任务，这个寒假要学到第九章！我发现我还有很多其他的东西需要学习。比如pandas 接下来的目标：每天玩一玩爬虫，肝一肝pandas视频 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:2","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["随笔杂记"],"content":"1月30日更新 增加了竹子mod 参考资料http://www.minecraftxz.com/bamboo/ 豆腐工坊mod 参考资料https://www.mcmod.cn/class/386.html 增加了小地图，进客户端就能看到 魔法金属 是一个大量级的Mod 可以观看籽岷的视频学习https://www.bilibili.com/video/BV1Qf4y1k73t 还增加了光影，在设置里可以调哦~ 另外请注意：服务器有死亡掉落哦，小心死了之后物品都没啦，最好组队一起玩，队友可以互救。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:0:1","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"进服教程 首先点开这个链接，下载由我整合的客户端~为了使下载速度更快，我没有使用垃圾百度网盘，而是用了阿里云，打开就能下载。 https://githubdownload.oss-cn-qingdao.aliyuncs.com/%E9%AD%94%E6%B3%95%E9%87%91%E5%B1%9E%E8%B1%86%E8%85%90%E5%B7%A5%E5%9D%8A1.7.10.zip 下载完成后，是一个压缩包，需要解压。电脑里没有解压软件的同学，可以下载好压软件，或者360zip 解压后的样子 解压完成后，打开文件夹里的这个启动器： 进去之后把用户名填了 （你他娘的可别填leyou1，那是我的账号。） 点击确定之后，就可以启动游戏啦 之后点多人游戏 就可以进服玩啦 服务器现有的Mod是魔法金属，可以在网上搜一搜教程，或者在b站看看视频。 无论你是建筑党，生存党，红石党，都欢迎你来建设服务器。 另外 服务器里没有装登陆插件，所以不需要密码，请勿泄露服务器的ip地址！ ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:1:0","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"开服信息公示 1.一开始是打算使用逸飞购买的阿里云轻量化应用服务器，29元三个月，平均每月9元，但是那个内存太小，没法开mod服，所以放弃。 后来图个方便，直接购买了淘宝的面板服，30元一个月。问淘宝客服要了mod文件，客服果然还是牛逼，照着他的方法弄就弄成了。 2.服务器的性质就是基友联机生存，非商业，不接受赞助。 3.如果你想增加mod，可以找我，现在加mod很方便。 4.QQ群： ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:2:0","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"寒假过得很快活，人只要一快活，就不想回顾昨天，只想着期待明天。我太快活了，所以我20多天没有写东西。现在是凌晨1:30，我有点感到孤寂，悲凉之情顿生，遂开电脑作文抒情。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"1.读书 最近在读《围城》这本书， 里面的人想出来，外面的人想进去 这本书是很有意思的一本书，很真实，真的很真实，主题是两性关系，这种题材的文学作品少之又少，强烈建议阅读。 放假前带回来一本图书馆借的书和一本课本，意料之中果然都没什么翻开过，幸亏当时没犯傻，把下学期的书都带回来，怎么带回来的，就怎么原封不动的带回去。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"2.学技术 放假了一直在学自己感兴趣的东西，像什么爬虫啦，html，github，学得也比较乱，还弄了个疫情防控通自动打卡的程序，感觉非常不错。我自己在家真是一点都不无聊。直到李老师突然让我帮他做自动测评脚本，我还当个组长，我是真觉得心有余而力不足了，一方面知识匮乏，另一方面领导者不好当。到后期是力不足，心也无余了，我才大一，我好累 ，就是这种感觉qwq ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"3.打游戏 我是有志向的人，立志要读万卷书，行万里路，打万部游戏。刚放假弄了个赛博朋克，电脑带不动，机缘巧合又弄了个生化危机3重置版，感受到了这种过去解密题材的游戏的魅力，作为lsp，我还打了不可描述的补丁，拍成视频发出去炫耀。现在打的更多的是塞尔达传说旷野之息，神作不解释，从此我的脑海中只信仰这一款游戏。MC我又双又又在弄服务器了，毕竟上大学了，同学们买电脑的多了，要求联机玩MC，明天争取把Mod服开起来。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"4.弹吉他 其它的，以后再说把，困了… ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"几天前李昕老师在群里问有没有想帮他干点活的，我们九个人就都忙着报名参加了。其中四个是外专业的，两个智科，三个本研的。有如下感想： ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:0:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"1.对Python的好感度大大提高 Python的成功再次印证了那句话：“最简单的就是最牛逼的”（我自己说的），C++，java这样的高级语言已经够简单了，但是Python比它们还简单！面向对象真是非常巧妙的设计！ Python的简单并不使它功能缺失，反而使它功能更加强大。你可以用它写脚本，写网页，数据分析，甚至做人工智能。丰富的第三方扩展库，极大缩减了编程过程造轮子的时间，简洁的语法，使它无比适合做数据分析。 我现在已经不是处于认识Python的阶段了，而是要更深刻地去学习Python，进入到实战中，感受它的魅力。如果不是这次帮李昕老师干活，看李昕老师修改我们的代码（其实代码主要都是李昕老师写的），我肯定想不到原来Python还可以这样玩！c++学了一个学期，到头来只会刷题，期末考试就做出来6道，很不爽。学了Python没多久，就能入门爬虫和数据分析了，真的挺好玩的。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:1:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"2.体会到了数据结构的重要性 之前看李昕老师的视频，听他讲json啊，列表啊，字典啊，元组什么的真是好乏味，觉得这东西很虚，没什么意思。现在实战了几天，我彻底改变了这种看法，也对数据结构的重要性有了更深的理解。数据结构就像是不同类型的交通工具，列表啊，字典啊，元组啥的就相当于飞机，高铁，大巴车，你编写一个程序实现它的功能，就相当于是选择合适的交通工具去往你的目的地的过程。比如说过年回家，你出了学校门要打出租车，到了火车站坐上高铁，下了高铁坐上家里的小轿车，到家门口了，出去买点东西再回来要骑共享单车。你写一个程序也是这样，先从json文件里，转换成字典，再提取有用信息，转换成列表方便修改，最后还要转换成字符串输出。这些东西的转换非常频繁，如果熟练掌握，就不会让操作羁绊大脑的天马行空。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:2:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"3.做事情不要想着一口吃成个胖子 这句话不是我说的，我觉得说的太对了，孙运雷老师的智能化设计报告里引用过：“任何复杂的系统的设计都是从简单开始的”，你不可能一开始就设计复杂的系统，如果这么做，一定会以失败告终。苹果的处理器这么牛逼，因为它已经出了14代了，塞尔达传说旷野之息这么好玩，这是它第十五部续作。很多时候，我们特别想把事情做好，甚至还没开始做的时候，我们脑海里就有了做成功这件事的喜悦，那个时候的灵感确实特别想实现，但当我们实际开始动手操作的时候，发现跟想象中有些不一样，最后成品做出来，也是跟最初的理想差了十万八千里，一切都是在妥协。没办法，我们都是普通人，不是天才，我们就只能和环境妥协，妥协，又妥协，人生何尝不是这样？小时候梦想当太空人，长大了卖喜之郎养家糊口，最终还是活成了自己讨厌的样子。 知道这个道理过后，就心平气和了很多。现在愿意做事情慢慢来，开始接受不完美。甚至有的时候碰巧把想象中的事情做成了之后，觉得这种完美很不真实，比如弹吉他，一首曲子我弹的竟然和原曲子这么像？是不是吉他坏了，砸了吧。 明天孙萃邀请我帮他宣讲，我脑子里是有很多东西想讲的，我也特别想提升我的演讲能力。但我确实没怎么演讲过，所以，我不对自己报太大的期望，简单的把一部分东西流畅讲出来就可以了，对自己期望太高，讲的时候也会紧张，适得其反。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:3:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["技能分享"],"content":"v2ray是一个代理工具，你不仅需要在电脑上下载这个软件，还要购买或者直接搭建v2ray服务器用于科学上网。 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:0","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"1.下载v2ray 打开以下链接，即可自动跳入下载 点击直接下载 （如果上面链接不可用，请使用备用下载地址：链接：https://pan.baidu.com/s/1G1xoYTRB5I0hGYcUWAkVHg 提取码：6sy0 ） 下载完无需安装，解压即可。 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:1","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"2.添加一个订阅 双击点开后，软件会自动跳到后台运行 在右下角你可以找到它，双击点开 点击这里的 订阅–\u003e订阅设置 点击添加 输入订阅地址后点确定，可以使用我已经购买的订阅地址，请私聊我 之后再回到界面，点击 订阅–\u003e更新订阅 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:2","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"3.切换服务器，开启代理 然后右下角这里，右键点击–\u003e选择服务器（先随便选一个），和游戏加速器一样，因为每个人的网络环境不同，你需要更换不同的节点以达到更快的网速 选择完服务器之后，再右键该图标–\u003e点击http代理，选择全局模式，或者pac模式 全局模式下，图标会变成红色，pac模式会变紫，检测一下操作是否正确 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:3","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"最后 做个测试吧！看是否能打开谷歌http://www.google.com 再搜索ip，可以查看你的网络环境已经发生改变 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:4","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"一.添加环境变量 直接在windows里面搜索“查看高级系统设置”，选择\u003c高级\u003e,\u003c环境变量\u003e，点开，以下三行填入其中： 然后点确定。 在我的电脑里\u003c环境变量\u003e和\u003c系统变量\u003e里面都有path，我也不知道该填哪个，索性把两个都填上了，这三个变量我觉得应该也有多余的，反正这个东西我是搞不太清楚的，只是照着网上说的做。 二.打开终端，进入目标文件夹，运行jupyter notebook这条指令 1.打开cmd之后cd进目标文件夹。 2.在目标文件夹里用git终端（需要安装git） 3.在目标文件夹按shift+右键，点\u003c在此处打开powershell窗口\u003e 以上三种方法打开终端都可以。 然后jupyter的黑窗口就跳出来了，或者是直接在终端里显示，进入notebook页面里就能看见打开了目标文件夹，还挺方便。 ","date":"2021-01-19","objectID":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/:0:0","tags":null,"title":"jupyter打开项目文件夹","uri":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"categories":["技能分享"],"content":"2月17日更新 新方法 打开anaconda prompt(按win搜索) 键入jupyter notebook + 目标文件地址 ","date":"2021-01-19","objectID":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/:0:1","tags":null,"title":"jupyter打开项目文件夹","uri":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"categories":["刷题"],"content":"方法一（利用的stringstream，可以是浮点数） 数字to字符串 #include \u003ciostream\u003e #include \u003csstream\u003e using namespace std; int main() { double x; string str; stringstream ss; cin \u003e\u003e x; ss \u003c\u003c x; ss \u003e\u003e str; cout \u003c\u003c str; return 0; } 字符串to数字 #include \u003ciostream\u003e #include \u003csstream\u003e using namespace std; int main() { double x; string str; stringstream ss; cin \u003e\u003e str; ss \u003c\u003c str; ss \u003e\u003e x; cout \u003c\u003c x; return 0; } ","date":"2021-01-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:0","tags":null,"title":"字符串与数字之间的转换","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { string s; s = \"123456\"; string::iterator it; it=s.begin(); s.insert(it+1,'p'); //把p插到第1个字符前，从0开始计数 cout \u003c\u003c s \u003c\u003c endl; return 0; } 运行结果 1p23456 Process returned 0 (0x0) execution time : 0.011 s Press any key to continue. ","date":"2020-12-28","objectID":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/:0:0","tags":null,"title":"给string对象插入字符","uri":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"看了课本后面的内容，发现新大陆了。string其实也是容器，而且功能很强大。 ","date":"2020-12-28","objectID":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/:1:0","tags":null,"title":"给string对象插入字符","uri":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { srand(time(NULL)); vector\u003cint\u003ev; int i; for(int i=0;i\u003c10;i++) { v.push_back(rand()%100); } for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v.begin(),v.end()); //升序排列 for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 结果： 13 32 13 85 48 99 36 53 18 16 13 13 16 18 32 36 48 53 85 99 Process returned 0 (0x0) execution time : 0.013 s Press any key to continue. 自定义函数： #include \u003cbits/stdc++.h\u003e using namespace std; bool cmp(const int \u0026a,const int \u0026b) { return a \u003e b; } int main() { srand(time(NULL)); vector\u003cint\u003ev; int i; for(int i=0;i\u003c10;i++) { v.push_back(rand()%100); } for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v.begin(),v.end(),cmp); //升序排列 for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 实测const可以去掉，不影响结果 结果： 3 26 45 43 42 72 71 63 35 63 72 71 63 63 45 43 42 35 26 3 一、const int 和int 的区别 1、返回值 const int \u0026 是返回这个数值的一个常量的引用。 而int 是返回这个数值的一个拷贝。 int 是进行拷贝构造，而const int \u0026 是返回的引用。拷贝构造更消耗时间，与此同时还用析构函数。因为产生了一个拷贝，你就可以轻易地修改拷贝的内容。 2、取指针 const int类型一旦定义以后就不能修改，int类型是随时可以修改的。 在取指针方面，const有略复杂的东西，但是常规的、合理的操作不应该涉及到，因为const int是用来保存一些全局常量的，这些常量在编译期可以改，在运行期不能改。 听起来这像宏，其实这确实就是用来取代宏的： #define PI 3.14 const float Pi = 3.14; 如果你的代码里用到了100次PI（宏），你的代码中会保存100个3.14这个常数。 鉴于使用常数进行运算的机器代码很多时候会比使用变量来的长，如果你换用100次Pi（const float)，程序编译后的机器码里就不需要出现100次常量3.14，只要在需要的时候引用存有3.14的常量就行了。 特别在复杂的运算里，3.14这个常量（其实是无法修改的变量）会被一直装载在寄存器里带来一些性能提升。 3、内容 constint* p; //p可变，p指向的内容不可变，int const* p; //p可变，p指向的内容不可变。 int* const p; //p不可变，p指向的内容可变 const int* const p; //p和p指向的内容都不可变。 二、const的作用： 1、可以定义const常量，具有不可变性。 例如：const int Max=100; Max++会产生错误; 2、便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。 例如： void f(const int i) { ………} 编译器就会知道i是一个常量，不允许修改； 3、可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以做到不变则已，一变都变！ 如1中，如果想修改Max的内容，只需要它修改成：const int Max=you want;即可！ 4、可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错； 例如： void f(const int i) { i=10;//error! } 5、可以节省空间，避免不必要的内存分配。 ","date":"2020-12-28","objectID":"/posts/%E4%BD%BF%E7%94%A8sort%E7%AE%97%E6%B3%95%E5%AF%B9%E5%90%91%E9%87%8F%E5%85%83%E7%B4%A0%E6%8E%92%E5%88%97/:0:0","tags":null,"title":"使用sort算法对向量元素排列","uri":"/posts/%E4%BD%BF%E7%94%A8sort%E7%AE%97%E6%B3%95%E5%AF%B9%E5%90%91%E9%87%8F%E5%85%83%E7%B4%A0%E6%8E%92%E5%88%97/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { srand(time(NULL)); vector\u003cint\u003ev(10); for(int i=0;i\u003c10;i++) { v[i] = rand()%100; } vector\u003cint\u003e::iterator it; for(it=v.begin();it!=v.end();it++) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c endl; reverse(v.begin(),v.end()); for(it=v.begin();it!=v.end();it++) { cout \u003c\u003c *it \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 运行结果 94 66 52 71 33 43 91 59 78 69 69 78 59 91 43 33 71 52 66 94 Process returned 0 (0x0) execution time : 0.013 s Press any key to continue. string容器 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { string s; s = \"123456\"; reverse(s.begin(),s.end()); cout \u003c\u003c s; return 0; } ","date":"2020-12-28","objectID":"/posts/%E4%BD%BF%E7%94%A8reverse%E5%8F%8D%E5%90%91%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"使用reverse反向排列算法","uri":"/posts/%E4%BD%BF%E7%94%A8reverse%E5%8F%8D%E5%90%91%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"},{"categories":["书影记录"],"content":"今天和同学们看了电影《十二公民》，有感而发。 十二公民讲的主要是十二位职业，性格各不相同的成年人，受到老师的邀请在政法大学的教室里进行模拟陪审，讨论一起凶杀案的嫌疑人是有罪还是无罪的故事。影片的场景非常简单，绝大部分剧情都发生在那间教室里，但是剧情却一波三折，从最初的十一人投票认为有罪，一人认为无罪，到最后全部认为无罪通过，这样的剧情真是让我难忘。 这十二个人，他们的职业，性格都迥然不同。有出租车司机，有房地产商，有社会混混，有保安，有小卖部店长，有外科医生….还有一个厉害角色—检察官。每个人都来自不同的地区，有着不同的人生经历，让他们几个坐在一起讨论事情，真的非常有趣，吵得热闹的时候都快把桌子给掀了，还多次差点动手打起来。他们只有一个共同点，那就是，他们都是中国公民。 这部影片，道法课张会芸老师介绍过，它主要揭露的，就是中国的公民法治意识的不健全。和西方相比，中国人本来就是刚刚步入法治社会，又在文革时期，法律曾遭到严重践踏。不错，现在中国人的素质在提高，人们都知道，一个人犯了法，需要用法律来将他绳之以法。可关键是，有在法律之外的东西，它不是执行法律，而是审判一个嫌疑人是否触犯法律，它就是法治思维，这仍然是这个公民普遍缺少的。 小的时候我看过这部影片，当时我也搞不明白，为什么铁证如山，那个检察官还要硬说嫌疑人是无罪的？ 现在，我读过一些书，也上过思修课，我渐渐开始明白：我们评判一个事件，往往带有主观色彩，比如，嫌疑人是一个富二代，我们潜意识里就认为富二代就是坏孩子，就一定是凶手，就一定是他犯的罪。所以在听证人的证词时，我们潜意识里就觉得嫌疑人他就是凶手。 但是，如果我们转变思想，我们把潜意识删除，我们假设嫌疑人是无罪的，我们去推理证人的证词出了问题，结果我们还真找到了问题。这，就是那位检察官一直在引导另外十一个人做的事情。 以前的中国，忙着打仗，忙着发展经济，社会上出现了一些问题，我们需要快速的解决，不要产生过多社会舆论，所以我们按照人情世故去执法，给老百姓一个让他们觉得“合理”的结果，尽管这样的结果与真理违背。但是，现在不一样了，现在中国富起来了，强起来了，人民的素质在提高，社会在进步，我们需要正确的法治思维，我们要努力让真理存在，否则，社会也不会继续发展。 最后，我觉得一个电影的好坏可以从两个方面评析：一是可观看性，如果一部电影讲述的故事非常有趣，让人想看一直下去，那它符合可观看性。二是内涵性，如果一部电影，它不仅仅像是喜剧片那样人看完笑完就忘了，而是揭示出深刻的道理，甚至帮助改善一些社会问题，那么它是一部有内涵的电影。我认为，十二公民这部电影，符合这两点，电影的笑点很多，故事很有趣，且这部电影有内涵有深意，因此我认为它是一部好电影。 ","date":"2020-12-21","objectID":"/posts/%E5%8D%81%E4%BA%8C%E5%85%AC%E6%B0%91%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《十二公民》观后感","uri":"/posts/%E5%8D%81%E4%BA%8C%E5%85%AC%E6%B0%91%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["刷题"],"content":"题目描述 你需要开发一款文字处理软件。最开始时输入一个字符串（不超过 100 个字符）作为初始文档。可以认为文档开头是第 0 个字符。需要支持以下操作： 1 str：后接插入，在文档后面插入字符串 str，并输出文档的字符串。 2 a b：截取文档部分，只保留文档中从第 a 个字符起 b 个字符，并输出文档的字符串。 3 a str：插入片段，在文档中第 a 个字符前面插入字符串 str，并输出文档的字符串。 4 str：查找子串，查找字符串 str 在文档中最先的位置并输出；如果找不到输出 -1。 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int n,i; cin \u003e\u003e n; string s; cin \u003e\u003e s; for(i=0;i\u003cn;i++) { int menu; cin \u003e\u003e menu; if(menu==1) { string tmp; cin \u003e\u003e tmp; s = s + tmp; cout \u003c\u003c s \u003c\u003c endl; } if(menu==2) { int a,b; cin \u003e\u003e a \u003e\u003e b; s = s.substr(a,b); cout \u003c\u003c s \u003c\u003c endl; } if(menu==3) { int location; string tmp; cin \u003e\u003e location \u003e\u003e tmp; s.insert(location,tmp); cout \u003c\u003c s \u003c\u003c endl; } if(menu==4) { string tmp; cin \u003e\u003e tmp; if(s.find(tmp)\u003cs.size()) cout \u003c\u003c s.find(tmp) \u003c\u003c endl; else cout \u003c\u003c -1 \u003c\u003c endl; } } return 0; } ","date":"2020-12-17","objectID":"/posts/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6-substr-insert-find/:0:0","tags":null,"title":"字符处理软件-substr-insert-find","uri":"/posts/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6-substr-insert-find/"},{"categories":["刷题"],"content":"需要的库： !pip install lxml !pip install request !pip install pathlib 代码： import time #代码合集并修改为下载多页表情 import requests from bs4 import BeautifulSoup from pathlib import Path for i in range(1,4): url = f'https://www.fabiaoqing.com/biaoqing/lists/page/{i}.html' response = requests.get(url) time.sleep(3) soup = BeautifulSoup(response.content,'lxml') img_list = soup.find_all('img', class_=\"ui image lazy\") for index,img in enumerate(img_list): image = img.get('data-original') content = requests.get(image).content file = Path('d:/emotion') / f'{index}{Path(image).suffix}' file.write_bytes(content) ","date":"2020-12-13","objectID":"/posts/requests%E7%88%AC%E8%A1%A8%E6%83%85%E5%8C%85/:0:0","tags":null,"title":"requests爬表情包","uri":"/posts/requests%E7%88%AC%E8%A1%A8%E6%83%85%E5%8C%85/"},{"categories":["书影记录"],"content":"我把解放后中国的崛起分为两个阶段，一是1949年至改革开放前（1978年）发展重工业，二是1978年改革开放之后到现在的中国特色社会主义经济。  第一阶段，主要领导人是毛泽东主席，他的伟大之处就在于让中国人民团结起来，组建了强有力的政府，政府的动员能力十分了得，当时人民也非常热血积极，在政府的指挥下完成了不少辉煌的成就。1949年~1952年国民经济恢复时期，政府领导人民恢复生产发展经济，1953年~1957年完成一五计划，此外，还打赢了抗美援朝战争，赢得安全的国际环境。后期毛主席领导尽管出现了一些错误，如发动“大跃进”，但是也有好的作用。152万个乡镇企业（当时叫社队企业）是留给邓小平同志的重要遗产。  总的来说，第一阶段政府组织人民填补了中国没有重工业基础的空白，但是人民生活并不好。  第二阶段，主要领导人是邓小平同志，他在1978年提出改革开放，把工作重心从阶级斗争转变为经济建设，邓小平南方讲话后，各地政府的意识形态转向重商主义。中国从此走上了一个很特殊的经济体系-中国特色社会主义经济，按照《中国的官办经济》的作者陈经的说法，就叫做官办经济。  官办经济特殊在于政府是“经济人”，由各地政府领导当地人民发展本地经济，人民没什么自由度，但是政府自由度很大，什么赚钱就搞什么。中国在地方政府这一层次上引入市场竞争体系，发挥了市场在资源配置中的基础作用，而一般民众依附于各级政府的行动当中。  中国运行官办经济的优势如下： 毛泽东时期留下的152万个乡镇企业派上用场，它们是最初的国企，受政府控制。 政府十分强势，权力大，组织力强，效率很高，且能承担亏损。 地方政府又很听中央的话，有错误可以及时被纠正，这叫做宏观调控。 对于整个中国，也有很多机遇： 国际环境以和平为主。 经济全球化，使中国参与到世界贸易。 中央有很多厉害人物，比如邓小平，陈云，朱镕基，他们除了制定官办经济体系外，还对整个中国的经济进行了引导： 发展比较优势，最明显的就是发展棉纺织业，中国自古以来就是纺织大国，靠这个能稳定的赚到钱。 赚到钱后，再去引进外资，吸引外国商人来中国办厂（邓小平设立经济特区），生产物美价廉的商品，再卖给外国，走“开放，引进，出口，加工”的道路。所以中国的工厂越来越多，号称“世界工厂”，制造业首屈一指，世界也越来越依赖中国。 大搞基础设施建设，这不仅解决了很多民生问题（比如就业，防水防洪），还使国内有效需求真实地增长，更好发挥市场的作用。 用宏观调控稳定市场，中国深刻吸取了“大跃进”的教训，特别注重稳定，尊重客观规律发展。经济稍微过热或者过冷，中央都要进行干预。（比如朱镕基抓银行，控制银行的权利，将其收归中央，控制各地政府的资金流动） 转换企业经营机制，对国有企业进行改革，反对垄断（比如运营商有三大）；转成股份制（调动国企工作人员积极性）；见死不救，在市场竞争中淘汰一些垃圾国企。 另外，最近几年中国赶上了移动互联网的浪潮，电商平台，在线支付极大促进了消费。雷军与董明珠的十亿赌局，体现出了互联网行业相较于传统制造业发展速度之迅速。很多土生土长的中国企业，比如华为，海光等，掌握很多核心科技，这也是一个国家宝贵的财富。 ","date":"2020-12-12","objectID":"/posts/%E4%B8%AD%E5%9B%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/:0:0","tags":null,"title":"中国是如何富起来的？","uri":"/posts/%E4%B8%AD%E5%9B%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/"},{"categories":["刷题"],"content":"一开始我尝试自己写，需要用到把int类型转换成string类型，在Python里，这非常简单，一行代码就可以搞定。但是我惊奇的发现，在c++里把int类型转换成string类型真的好麻烦！在百度上查了很久，方法要么不对，要么就是太复杂。果然c++是不适合处理字符串的。 所以放弃那种做法，用这种： bool is_huiwen(int n) { unsigned i=n; unsigned m=0; while(i\u003e0) { m=m*10+i%10; i/=10; } return m==n; } 思路，比如判断121，把121倒过来还是121，判断与原数相等，所以是回文数。 ","date":"2020-12-04","objectID":"/posts/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/:0:0","tags":null,"title":"判断回文数","uri":"/posts/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["刷题"],"content":"比较字符串字典序的三种方法【C++】 - 知乎 (zhihu.com) #include \u003ciostream\u003e using namespace std; int main() { char s1[2] = \"a\"; char s2[2] = \"b\"; cout \u003c\u003c strcmp(s1, s2) \u003c\u003c endl; //-1 cout \u003c\u003c strcmp(s2, s1) \u003c\u003c endl; //1 cout \u003c\u003c strcmp(s1, s1) \u003c\u003c endl; //0 return 0; } #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main() { string s1 = \"a\"; string s2 = \"b\"; cout \u003c\u003c s1.compare(s2) \u003c\u003c endl; //-1 cout \u003c\u003c s2.compare(s1) \u003c\u003c endl; //1 cout \u003c\u003c s1.compare(s1) \u003c\u003c endl; //0 return 0; } #include \u003ciostream\u003e using namespace std; int main() { char s1[2] = \"a\"; char s2[2] = \"b\"; cout \u003c\u003c (s1 \u003c s2) \u003c\u003c endl; //0 cout \u003c\u003c \u0026s1 \u003c\u003c endl; //00BDFE74 cout \u003c\u003c \u0026s2 \u003c\u003c endl; //00BDFE68 cout \u003c\u003c (string(s1) \u003c string(s2)) \u003c\u003c endl; //1 cout \u003c\u003c (string(s2) \u003c string(s1)) \u003c\u003c endl; //0 cout \u003c\u003c (string(s1) == string(s1)) \u003c\u003c endl; //1 return 0; } ","date":"2020-12-04","objectID":"/posts/c++%E6%AF%94%E8%BE%83%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"c++比较字典序的三种方法","uri":"/posts/c++%E6%AF%94%E8%BE%83%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["刷题"],"content":"质数判断是最简单最基本的算法，虽然我能很快把代码写出来，但是总会有一些小错误，不妨把下面的经典代码记下来 #include \u003ciostream\u003e #include \u003ccmath\u003e using namespace std; bool sb(int x) { int i,flag=0; if(x==1) return 0; else { for(i=2; i\u003c=sqrt(x); i++) { if(x%i==0) { flag = 1; } } if(flag==1) { return false; } else { return true; } } } 如果是质数，函数sb()返回1，不是就返回0； ","date":"2020-12-03","objectID":"/posts/%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD/:0:0","tags":null,"title":"质数判断","uri":"/posts/%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD/"},{"categories":["刷题"],"content":"nmd，一道题做了一个小时没看出哪里有问题，居然是“等于”写错了！ 千万不要把“==”写成“=” 输出小数时函数用成了int Fun() 应该用double Fun() 习惯了使用int Fun() 也是看了半天，没有看出问题来 输入M和N 我只写了cin » N; 导致后面全错，查了半天也没查出来； 定义了数组a[9999]; 后面定义了变量a 报错invalid types ‘int[int]’ for array subscript 使用cnt变量进行计数时，没有赋初始值0； 算法是对的，一送进Oj就错 搞了半天，数组开小了 明天就程序设计考试了，我作为程序设计课代表（假课代表），不能考的太差呀！ 加油吧 ","date":"2020-12-02","objectID":"/posts/c++%E5%82%BB%E7%BC%BA%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/:0:0","tags":null,"title":"c++傻缺错误集锦","uri":"/posts/c++%E5%82%BB%E7%BC%BA%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/"},{"categories":["刷题"],"content":"from selenium import webdriver from bs4 import BeautifulSoup import csv out = open('d:/data.csv','w', newline='') csv_write = csv.writer(out,dialect='excel') for year in range(1960,2018): driver = webdriver.Chrome() url = \"https://www.kylc.com/stats/global/yearly/g_gdp/%d.html\"%year xpath = \"/html/body/div[2]/div[1]/div[5]/div[1]/div/div/div/table\" driver.get(url) table1 = driver.find_element_by_xpath(xpath).get_attribute(\"innerHTML\") out = open('d:/data.csv','w', newline='') csv_write = csv.writer(out,dialect='excel') soup = BeautifulSoup(table1,\"html.parser\") table = soup.find_all('tr') for row in table: cols = [col.text for col in row.find_all('td')] if len(cols)==0 or not cols[0].isdigit(): continue cols.append(year) csv_write.writerow(cols) print(cols) driver.close() ","date":"2020-12-01","objectID":"/posts/selenium%E7%88%ACgdp/:0:0","tags":null,"title":"selenium爬GDP","uri":"/posts/selenium%E7%88%ACgdp/"},{"categories":["刷题"],"content":"【题目描述】 某某国王（不是萨拉克门托！）有一个神奇的魔镜，它可以把东西变为原来的两倍(可惜是反的)。某日，他感到很无聊，于是把皇后的一串珠子变了不知道几次，皇后回来之后不是很高兴，她还是喜欢原来那串珠子，现在告诉你改变之后珠子的形状，请你告诉她，原来的珠子是什么样子的。 【输入】 输入有多组测试用例，每组一行，每行一串字符，表示现在的珠串，长度小于100。 【输出】 输出对应有多行，每行输出原来的珠串。 For example: Input Result 1232232112322321 121121 abba 1232 121 ab ","date":"2020-11-27","objectID":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/:0:0","tags":null,"title":"对称字符串处理","uri":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"categories":["刷题"],"content":"Answer:(penalty regime: 20 %) #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cstring\u003e using namespace std; bool myfun(string \u0026s) { int beg = 0; int end = s.size()-1; while(beg \u003c end) { if(s[beg] != s[end]) { return false; } beg++; end--; } return true; } int main() { string s; while(cin \u003e\u003e s) { while(myfun(s) \u0026\u0026 s.size()%2==0) s = s.substr(0,s.size()/2); cout \u003c\u003c s \u003c\u003c endl; } return 0; } 搞了老久了妈的 没想到，c++的string字符串中的单个字符也可以通过s[]的形式来访问，发现了新大陆，感觉还是蛮方便的； 这题的算法很巧妙，当然不是我想出来的，参考https://blog.csdn.net/jacketinsysu/article/details/38335453； t=s.substr(a,b)是将s中的从a开始的b个元素复制到t中； ","date":"2020-11-27","objectID":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/:1:0","tags":null,"title":"对称字符串处理","uri":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"categories":["刷题"],"content":"【题目描述】 某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分）是： 7 279 5 279 这两行数据的含义是：总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是279 （总分等于输入的语文、数学、英语三科成绩之和），但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是： 5 279 7 279 则按输出错误处理，不能得分。 【输入】 共n+l行：第1行为一个正整数n（6≤n≤300），表示该校参加评选的学生人数；第2到n+l行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1～n（恰好是输入数据的行号减1）。 【输出】 共有5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。 For example: Input Result 6 90 67 80 87 66 91 78 89 91 88 99 77 67 89 64 78 89 98 6 265 4 264 3 258 2 244 1 237 ","date":"2020-11-24","objectID":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/:0:0","tags":null,"title":"给学生成绩排序，总分相同看语文，语文相同看序号","uri":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/"},{"categories":["刷题"],"content":"Answer:(penalty regime: 20 %) 法一，不推荐 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; struct student_t_distribution { int yuwen; int shuxue; int yingyu; int sum; int code; }s[9999]; int main() { int n,i,j; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e s[i].yuwen \u003e\u003e s[i].shuxue \u003e\u003e s[i].yingyu ; } for(i=0;i\u003cn;i++) { s[i].sum = s[i].yuwen + s[i].shuxue + s[i].yingyu; s[i].code = i + 1 ; } for(i=0;i\u003cn;i++) { for(j=i+1;j\u003cn;j++) { if(s[j].sum\u003es[i].sum (s[j].sum==s[i].sum \u0026\u0026 s[j].yuwen\u003es[i].yuwen) (s[j].sum==s[i].sum \u0026\u0026 s[j].yuwen==s[i].yuwen \u0026\u0026 s[j].code\u003cs[i].code)) { swap(s[j],s[i]); } } } for(i=0;i\u003c5;i++) { cout \u003c\u003c s[i].code \u003c\u003c' '\u003c\u003c s[i].sum \u003c\u003c endl; } return 0; } 法二，用函数和sort，推荐 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; struct stu { int yuwen; int shuxue; int yingyu; int sum; int code; }s[9999]; bool cmp(stu \u0026a,stu \u0026b) { if(a.sum != b.sum) { return a.sum \u003e b.sum; } if(a.sum == b.sum \u0026\u0026 a.yuwen != b.yuwen) { return a.yuwen \u003e b.yuwen; } if(a.sum == b.sum \u0026\u0026 a.yuwen == b.yuwen) { return a.code \u003c b.code; } return 0; } int main() { int n,i; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e s[i].yuwen \u003e\u003e s[i].shuxue \u003e\u003e s[i].yingyu ; } for(i=0;i\u003cn;i++) { s[i].sum = s[i].yuwen + s[i].shuxue + s[i].yingyu; s[i].code = i + 1 ; } sort(s,s+n,cmp); for(i=0;i\u003c5;i++) { cout \u003c\u003c s[i].code \u003c\u003c' '\u003c\u003c s[i].sum \u003c\u003c endl; } return 0; } ","date":"2020-11-24","objectID":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/:0:1","tags":null,"title":"给学生成绩排序，总分相同看语文，语文相同看序号","uri":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/"},{"categories":["刷题"],"content":"【题目描述】 中超联赛拥有大量的现场观众和收视观众，球迷都渴望观看比赛，同时希望能有一个平台更深度的了解中超联赛，体验中超球队的辛苦和努力。每场足球比赛历时90分钟，分为上半场和下半场。 中超的积分规则如下：赢得一场比赛得3分，平一场得1分，输球不得分。例如一个球队的胜平负的场次分别为11,2和 2，那么积分就是11*3+2*1=35。9102年的中超联赛已经落下帷幕，请你帮忙计算出各球队的总积分并按照积分给出球队最终的排名吧！ 【输入】 有多行。第1行是球队数量n（1\u003cn≤16）。 接下来有n行，每行数据包含球队的名称（不含空格，长度不超过30个字符）和胜、平、负的场次，数据间以空格分开。 【输出】 各个球队按照积分的排名情况（保证所有球队的积分各不相同），每行输出球队的名次、名称和该队的积分，数据间用一个空格分开，每行末尾没有空格。 For example: Input Result 3 shanghaishanggang 11 2 2 beijingguoan 12 2 1 shandonglunengtaishan 10 1 4 1 beijingguoan 38 2 shanghaishanggang 35 3 shandonglunengtaishan 31 Answer:(penalty regime: 20 %) #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef struct footballteam //不懂 { char name[1000]; int win; int equals; int fail; int sum; }TEAM; int cmp(TEAM \u0026a,TEAM \u0026b) //不懂 { return a.sum \u003e b.sum; } int main() { TEAM a[20]; int n,i; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i].name \u003e\u003e a[i].win \u003e\u003e a[i].equals \u003e\u003e a[i].fail; a[i].sum = a[i].win*3 + a[i].equals; } sort(a,a+n,cmp); for(i=0;i\u003cn;i++) { cout \u003c\u003c i+1 \u003c\u003c' '\u003c\u003ca[i].name \u003c\u003c' '\u003c\u003ca[i].sum \u003c\u003c endl; } return 0; } ","date":"2020-11-21","objectID":"/posts/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F-sort-typedef/:0:0","tags":null,"title":"结构体排序-sort()-typedef","uri":"/posts/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F-sort-typedef/"},{"categories":["刷题"],"content":"【问题描述】 有n只猴子围成一圈，从1~n编号，大家决定从中选出一个大王。经过协商，决定选大王的规则为：从编号为1的猴子开始报数，报到k的猴子出圈，然后再从下一只开始继续报1到k，最后剩下来的那一只就是大王。 【输入】  一行，包含两个正整数n和k（2≤n≤1000,2≤k≤109）。 【输出】  一行，一个正整数，表示猴王的编号。 For example: Input Result 3 2 3 ","date":"2020-11-21","objectID":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","tags":null,"title":"猴子选大王-结构体","uri":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; struct MONKEY { int code; int next; }; int main() { MONKEY mons[1000]; int n; int k; cin \u003e\u003e n \u003e\u003e k; //init int i,j,index=1,pre; for(i=1;i\u003cn;i++) { mons[i].code = i; mons[i].next = i+1; } mons[n].code = n; mons[n].next = 1; //run for(i=1;i\u003cn;i++) { //do a roll for(j=1;j\u003ck;j++) { pre = index; index = mons[index].next; } //index will leave mons[pre].next = mons[index].next; pre = mons[pre].next; //这两句是加的 index = mons[index].next; } cout \u003c\u003c mons[index].code \u003c\u003c endl; return 0; } 分析： 这题比较难，老宫上课时写了一段代码，我把它记下来了，提交后发现不能通过全部测试数据。然后我就自己捣鼓。我知道问题是出在//index will leave 这个地方，但我不知道怎么改，最后我就打算放弃了，随便加了两句竟然瞎猫碰死耗子碰对了。 Input Expected Got 3 2 3 3 285 844 97 97 Passed all tests! ","date":"2020-11-21","objectID":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","tags":null,"title":"猴子选大王-结构体","uri":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["刷题"],"content":"【题目描述】 请编一个将浮点数四舍五入的函数Fun，其功能是使浮点数保留2位小数，并对第3位进行四舍五入（规定实型数为正数）。 例如：实型数为1234.567，则函数返回1234.57；实型数为1234.564，则函数返回1234.56。 【输入】 一个浮点数。 【输出】 精确到小数点后面2位的浮点数。 【函数声明】 double Fun(double a) For example: Input Result 1234.567 1234.57 1234.561 1234.56 ","date":"2020-11-18","objectID":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/:0:0","tags":null,"title":"四舍五入小数","uri":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"Answer: double Fun(double a) { //1.进行四舍五入 a = a + 0.005; //2.将要保留的数据挪到整数位，再取整 int temp = a*100; //一步到位 //int temp = (a+0.005)*100; //3.转为所需数字 a = temp/100.0; return a; } 点评：很有趣的写法！ ","date":"2020-11-18","objectID":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/:1:0","tags":null,"title":"四舍五入小数","uri":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"求m和n的最大公约数 int gcd(int m,int n) { if(m%n==0) { return n; } else { return gcd(n,m%n); } } ","date":"2020-11-17","objectID":"/posts/%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/:0:0","tags":null,"title":"递归法求最大公约数","uri":"/posts/%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"categories":["刷题"],"content":"from selenium import webdriver from bs4 import BeautifulSoup from selenium.webdriver import ActionChains import time from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC def wait(xpath,driver): WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH, xpath))) #登录： def login(driver): id_box = '//*[@id=\"userAccount\"]' wait(id_box,driver) driver.find_element_by_xpath(id_box).send_keys('2007010218') password_box = '//*[@id=\"userPassword\"]' driver.find_element_by_xpath(password_box).send_keys('2007010218') yan_zhen = '//*[@id=\"RANDOMCODE\"]' driver.find_element_by_xpath(yan_zhen).click() time.sleep(5) login_btn = '//*[@id=\"btnSubmit\"]' driver.find_element_by_xpath(login_btn).click() time.sleep(2) ke_biao = '/html/body/div[5]/a[2]/div' driver.find_element_by_xpath(ke_biao).click() time.sleep(2) #执行 driver = webdriver.Chrome() url = 'http://jwxt.upc.edu.cn/' driver.get(url) time.sleep(1) login(driver) driver.get_screenshot_as_file(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\kb.png\") driver.quit() 依次执行以上cell，1.打开chrome自动输入账号密码。2.有五秒钟的时间人工输入验证码。3.自动进入课表页面，自动截图，保存在桌面（保存文件夹在目录可能需要更改） ","date":"2020-11-16","objectID":"/posts/selenium%E7%88%AC%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E8%A1%A8/:0:0","tags":null,"title":"selenium爬教务处课表","uri":"/posts/selenium%E7%88%AC%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"seleniumrequest下载 ","date":"2020-11-16","objectID":"/posts/python%E7%88%AC%E8%99%AB-selenium-request/:0:0","tags":null,"title":"Python爬虫-selenium-request","uri":"/posts/python%E7%88%AC%E8%99%AB-selenium-request/"},{"categories":["随笔杂记"],"content":"九月，我成为了石油大学计算机学院的一名学生。秋高气爽，海风习习，我第一次远离家乡，独自留在一个陌生的城市，妈妈望着我远去的背影，掉下了眼泪，我的心里也很不是滋味。 但是，我很快就熟悉了校园，与身边的同学打成了一片，我们一起去食堂吃饭，一起寻找上课的教室，一起讨论不会的程序设计题目，一起参加各种活动。从高三压抑紧张的氛围解脱出来后，我终于可以进入大学，选择我最感兴趣的计算机专业，学习我喜欢的东西，认识我喜欢的人，我前所未有地感受到了自由的美好，青春的美好。 过度的自由，会让人迷失方向。太过于自由，就让我陷入了堕落，我开始睡懒觉，有时间就会刷手机，上课不想听课，也不注意锻炼身体。我和很多大一新生一样，没过多久，就陷入了人生的迷茫。晚上睡觉之前，我回忆我的一天，我问我自己，我今天做了什么？起初，我给自己定下很多很多目标，我要坚持每天练字，我要每天刷很多程序题，我还要学会ps,pr,ppt,excel等等很多软件，我还要读很多书… 当然，这些目标我都没有完成，我会觉得有些愧疚，我给自己找理由说自己每天琐事太多，时间不够用。可是有一天，我发现我手机屏幕的使用时间竟然达到了每天六个小时。简单计算一下，我每天早上六点起床，十二点睡觉，白天18个小时之中，三分之一的时间都浪费在了手机上，“时间不够”完全就是借口！ 我反思是什么阻碍了我的坚持？我一门心思想学习的那些技能，比如书法，程序设计，office软件，都遇到了小小的瓶颈，而我在遇到瓶颈时，并不是想着怎么去突破它，而是选择了放弃，转身去向其它活动。在参加其它活动的过程中很多我并不感兴趣，仅仅只是浅尝辄止，这是毫无用处的。我太“花心”了，想得到的太多，却没耐心解决难题。 第十周是我开学以来最迷茫的一周，我的人际关系面临挑战，由于班级不同课程时间不同，还有人生目标，价值观的不同，我和室友的矛盾渐渐凸显。还有三座大山压在我心里，一是周四的体测，二是周六的数学分析考试，三是周日的合唱比赛。尤其是这个合唱比赛，真的让我很难受。我本就不喜欢参加这种文艺活动，却在这次活动中承担了主角的压力。这真是错误地选择。 但是一切都会过去，我和室友沟通，我们达到了微妙的平衡，商量回归到正常作息。我尽量减少其它活动，只把精力投放在了“三座大山”上面，一有时间就呆在图书馆里，我甚至找回了一点高三的感觉，那时的我就是这样目标明确，有压力也有动力。功夫不负有心人，周四的体测我顺利合格了，周六的数学分析考试题目也基本都复习到了，合唱比赛我也在积极准备，与室友的关系也渐渐缓和，阳光又照进了我的生活。 堕落懒散的生活只会让人得到一时的欢愉，真正长久的快乐，是通过努力奋斗得到的。我想起《人民日报》上的一句话：“不能因现实复杂而放弃梦想，不能因理想遥远而放弃追求，因为，历史只会眷顾坚定者，奋进者，搏击者，而不会等待犹豫者，懈怠者，畏难者！” 我就像党在1978年召开的十一届三中全会一样，完成思想上的“拨乱反正”，我应该让自己知道我要做什么事，并且努力地把事情做好。正如习总书记所说“奋斗是青春最靓丽的底色。”我要用奋斗青春成就未来！ ， ","date":"2020-11-15","objectID":"/posts/%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E4%B8%8D%E8%BF%B7%E8%8C%AB%E5%A5%8B%E6%96%97%E9%9D%92%E6%98%A5%E6%88%90%E5%B0%B1%E6%9C%AA%E6%9D%A5-%E5%BE%81%E6%96%87%E6%B4%BB%E5%8A%A8/:0:0","tags":null,"title":"我的青春不迷茫，奋斗青春成就未来-征文活动","uri":"/posts/%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E4%B8%8D%E8%BF%B7%E8%8C%AB%E5%A5%8B%E6%96%97%E9%9D%92%E6%98%A5%E6%88%90%E5%B0%B1%E6%9C%AA%E6%9D%A5-%E5%BE%81%E6%96%87%E6%B4%BB%E5%8A%A8/"},{"categories":["刷题"],"content":" bitset\u003c16\u003e bint; // 16 bit 二进制数据，还有 bitset\u003c32\u003e cin \u003e\u003e bint; int a; a = bint.to_ulong(); cout \u003c\u003c a; ","date":"2020-11-10","objectID":"/posts/%E8%BE%93%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6/:0:0","tags":null,"title":"输入二进制转化为十进制","uri":"/posts/%E8%BE%93%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"},{"categories":["刷题"],"content":"【题目描述】 小明参加学校每年一度的大学生科技节活动的游戏，这次遇到的题目是字符接龙。主持人拿出2张卡片，每张卡片上都有一个顺序字符串，即字符串是按ASCII码顺序编排的。现在要求小明把2个字符串连接成一个字符串，而且连接以后的字符串内容还是按ASCII码顺序排列的。（假设每张卡片上的字符串都不包含空格）。 【输入格式】 有2行。分别为两个不包含空格的字符串，每个字符串长度不超过1000。 【输出格式】  连接后的顺序字符串（按ASCII码顺序排列）。 For example: Input Result acd br abcdr ","date":"2020-11-07","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/:0:0","tags":null,"title":"字符数组的拼接和排序-strcat()-sort()-strlen()","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e #include\u003cstring.h\u003e #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; int main() { char a[100]; char b[100]; int len; scanf(\"%s\",a); scanf(\"%s\",b); strcat(a,b); len = strlen(a); sort(a,a+len); cout \u003c\u003c a; return 0; } 头文件好像没有全部用到。这段代码写得我还是比较满意的，如果要造轮子的话，光是一个拼接就够我搞一节课了。 ","date":"2020-11-07","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/:1:0","tags":null,"title":"字符数组的拼接和排序-strcat()-sort()-strlen()","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/"},{"categories":["刷题"],"content":"【题目描述】 输入一个长度不超过 100 的字符串，删除串中的重复字符。例如：输入的字符串为abacaeedabcdcd， 删除重复字符串后为abced。 【输入格式】 一个长度不超过100个字符。 【输出格式】 删除重复字符后的字符串，保留原来的顺序。 For example: Input Result abacaeedabcd abced ","date":"2020-11-07","objectID":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/:0:0","tags":null,"title":"删除重复的字符并重新排列-这个题太jb烦人了","uri":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/"},{"categories":["刷题"],"content":"Answer #include \u003cstdio.h\u003e #define N 100 int main() { char a[N]; int i,j,m; scanf(\"%s\",a); for(i=0; a[i]!=0; i++) for(j=i+1; a[j]!=0; j++) if(a[i]==a[j]) { for(m=j; a[m]!=0; m++) { a[m]=a[m+1]; } j--; } puts(a); return 0; } 完全就是造轮子，没意思，明明知道有很好用的函数可以直接解决，但是我一个都不会！！ ","date":"2020-11-07","objectID":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/:1:0","tags":null,"title":"删除重复的字符并重新排列-这个题太jb烦人了","uri":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/"},{"categories":["刷题"],"content":"【题目描述】 If we define each of the upper case letters a number, that is, 1 for A, 2 for B, 3for C, … 25 for Y, 26 for Z, we can calculate a mark for any word or sentence. We believe that 100 points is the full mark, so for those word with a mark larger than 100, we should just ignore that, with a label “INVALID” .Then let’s see interesting results: What is the most important for your success? HARDWORK? H+A+R+D+W+O+R+K=8+1+18+4+23+15+18+11=98 KNOWLEDGE? K+N+O+W+L+E+D+G+E=11+14+15+23+12+5+4+7+5=96 MONEY? M+O+N+E+Y=13+15+14+5+25=72 LUCK? L+U+C+K=12+21+3+11=47 ATTITUDE! A+T+T+I+T+U+D+E=1+20+20+9+20+21+4+5=100 So just be with good attitude and you will be on your way to success. 【输入格式】 For each case of the input, it contains a single line. For each line, some characters will appear with maybe some of them being upper case letters. All characters are printable. Each line will have at most 127 characters. 【输出格式】 For each case, you should only pay attention to upper case letters and calculate the total points. If it is over 100, “INVALID” should be returned. Or you should print the exact point of that. For example: Input Result DELICIOUS FOOD YY, and YY again! did i lose anything? INVALID 100 0 ","date":"2020-11-05","objectID":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/:0:0","tags":null,"title":"每个字母代表一个数字，输出字符串代表的数字之和","uri":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; int main() { //输入1至26个字母 char a[9999]; int i,j,cnt,x=0; for(i=1;i\u003c=26;i++) { a[i] = 'A' + i - 1; } //输入字符 char b[9999]; while(cin.getline(b,9999)) //这个while是后来加上去的，没有while就不能多次输入 { cnt = 0; //逐个计数 for(i=0;b[i]!='\\0';i++) { for(j=1;j\u003c=26;j++) { if(b[i] == a[j]) { x = j; break; } else { x = 0; //这里本来是没有这个else和x的，但是如果不加这个else，会出bug } } cnt = cnt + x; } if(cnt \u003e 100) { cout \u003c\u003c \"INVALID\" \u003c\u003cendl; } else { cout \u003c\u003c cnt \u003c\u003c endl; } } return 0; } 这个吊题目不难，但是需要细心，写出算法用了十分钟，改bug用三十分钟。还问了恺毅同学，他是真的强。 ","date":"2020-11-05","objectID":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/:1:0","tags":null,"title":"每个字母代表一个数字，输出字符串代表的数字之和","uri":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"【题目描述】 从键盘输入一行文本，统计其中数字字符‘0’~‘9’出现的频率并输出。没出现的不需要输出。 【输入格式】 一行文本，长度不超过1000。 【输出格式】 按照从0到9顺序输出统计结果。每个数字的信息占一行，如“0:2”表示数字字符0出现了2次。 For example: Input Result Hello No 007. 0:2 7:1 ","date":"2020-11-05","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:0","tags":null,"title":"统计字符串中字符出现的个数-int与char类型的转换","uri":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; int main() { char a[9999]; int i,j,cnt; //输入部分 cin.getline(a,9999); //处理部分 for(i=0;i\u003c10;i++) { cnt = 0; char x; x = i + '0'; //这里将i的值从int类型变成char类型，存入x中，不能再存回i中，因为i的类型为int for(j=0;a[j]!='\\0';j++) { if(a[j] == x) { cnt++; } } //输出部分 if(cnt != 0) { cout \u003c\u003c x \u003c\u003c ':'\u003c\u003ccnt\u003c\u003cendl; } } return 0; } ","date":"2020-11-05","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:0","tags":null,"title":"统计字符串中字符出现的个数-int与char类型的转换","uri":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"【题目描述】 小明在录入一篇英文文献时由于键盘误操作，事先按下了CapsLock（大写锁定）键，然后又按照平时的录入习惯进行操作。结果录入的内容里面，原本应该是英文大写的地方都变成了小写，而原来应该是英文小写的地方都变成了大写。如果重新录入的话实在太可怕了！ 【输入格式】 任意一个字符串（长度小于等于80），以换行结束。 【输出格式】 转换后的字符串。 For example: Input Result i AM A STUDENT.i AM 19. I am a student.I am 19. ","date":"2020-11-02","objectID":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"大小写字母互换-输入与输出字符串","uri":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { char a[90]; int i=0; cin.getline(a,90); for(i=0;a[i]!='\\0';i++) { if(a[i]\u003e='a' \u0026\u0026 a[i]\u003c='z') { a[i] = a[i] - 32; } else if(a[i]\u003e='A' \u0026\u0026 a[i]\u003c='Z') { a[i] = a[i] + 32; } } puts(a); return 0; } 这题算法很简单，难的是输入与输出，试了很久，最终用这种输入方法可以实现。 发现了几个问题1.网上查的ascii码跟实际程序里的对不上，查ascii码可以用下面这个代码 #include \u003ciostream\u003e using namespace std; int main() { char a[20]; cin.getline(a,90); int i; cout \u003c\u003c a[0] - '0'; return 0; } 2.字符数组可以直接cin»a;和cout«a; ","date":"2020-11-02","objectID":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"大小写字母互换-输入与输出字符串","uri":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"https://blog.csdn.net/lost_in_jungle_/article/details/82716778 写得针不戳 cin » a; 可以直接输入字符串，但是这个输入貌似很操蛋。 puts这个还蛮好用的； gets在codeblocks里可以用，但是在网页编程上确实用不了；可以用cin.getline(数组名)代替。 ","date":"2020-11-02","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":null,"title":"字符数组的输入输出","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"sort函数的调用需要头文件#include 从小到大排： 例如：a[50]={2,3,5,1,-1},想让它按照从小到大的顺序排列，那么就可以这么写，sort(a,a+5),然后数组就会变成{-1,1,2,3,5}。 具体代码如下： #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; int main() { int i,a[50]={2,3,5,1,-1}; sort(a,a+5);//规定排序的范围 for(i=0;i\u003c5;i++) printf(\"%d \",a[i]); return 0; } 从大到小排： 例如：a[50]={2,3,5,1,-1},想让它按照从大到小的顺序排列，那么就可以这么写，sort(a,a+5,cmp),调用cmp函数,然后数组就会变成{5,3,2,1,-1}。 具体代码如下： #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; bool cmp(int x,int y) { return x\u003ey; } int main() { int i,a[50]={2,3,5,1,-1}; sort(a,a+5,cmp); for(i=0;i\u003c5;i++) printf(\"%d \",a[i]); return 0; } ","date":"2020-11-01","objectID":"/posts/%E7%94%A8sort%E5%87%BD%E6%95%B0%E7%BB%99%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"用sort函数给数组排序","uri":"/posts/%E7%94%A8sort%E5%87%BD%E6%95%B0%E7%BB%99%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"【题目描述】 给出两幅相同大小的黑白图像（用 0表示黑，1表示白）表示，求它们的相似度。说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。 【输入】 第一行包含两个整数 m 和 n，表示图像的行数和列数，中间用单个空格隔开。1≤ m≤ 100, 1≤ n≤ 100。 之后 m 行，每行 n 个整数，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 之后 m 行，每行 n 个整数，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 【输出】 两幅图像的相似度，结果保留小数点后两位。 For example: Input Result 3 3 1 0 1 0 0 1 1 1 0 1 1 0 0 0 1 0 0 1 44.44 ","date":"2020-11-01","objectID":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/:0:0","tags":null,"title":"cout输出精确到小数点后两位","uri":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003ciomanip\u003e using namespace std; int main() { int a[500][500]; int b[500][500]; int m,n,j,k; //输入部分 cin \u003e\u003e n \u003e\u003e m; for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { cin \u003e\u003e a[j][k]; } } for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { cin \u003e\u003e b[j][k]; } } //计算部分 float cnt=0; for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { if(a[j][k]==b[j][k]) cnt++; } } cnt = cnt * 100; //输出部分 cout \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c cnt/(m*n); return 0; } 输出精确的方式： #include cout « fixed « setprecision(2) « a; //其中fixed自动补0，setprecision(2)是精确到小数点后两位 ","date":"2020-11-01","objectID":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/:1:0","tags":null,"title":"cout输出精确到小数点后两位","uri":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/"},{"categories":["笔记"],"content":"工欲善其事，必先利其器。 看学校官网，关注讲座www.upc.edu.cn 看学院官网，看学术报告，黄岛讲堂，写记录册 computer.upc.edu.cn 关注微信公众号 “石光计E” EI，从图书馆进http://library.upc.edu.cn/html/ziyuan/wwsjk/2014/0620/147.html SCI，图书馆进http://library.upc.edu.cn/html/daohang/syzy/2019/0611/2232.html 中国计算机学会推荐国际学术会议和期刊目录https://www.ccf.org.cn/Academic_Evaluation/By_category/ A刊找综述性文章 A会找最新的文章 中文 雷锋网https://www.leiphone.com 机器之心 www.jiqizhixin.com 中国计算机学会推荐国际学术会议和期刊目录-2019下载 重要-2015-nature-深度学习三巨头写的综述-Deep-learning下载 重要-2017-深度学习的起源-On-the-Origin-of-Deep-Learning下载 ","date":"2020-10-28","objectID":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/:0:0","tags":null,"title":"工欲善其事，必先利其器。","uri":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"},{"categories":["笔记"],"content":"之前的文件 archivetempBN2017年日本演讲下载 2005-12-30-中国的官办经济下载 20201011-第一次组会下载 pythoncourse下载 伟大的中国工业革命——“发展政治经济学”一般原理批判纲要下载 五百年来谁著史：1500年以来的中国与世界 韩毓海下载 智能化设计研究报告v1下载 ","date":"2020-10-28","objectID":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/:1:0","tags":null,"title":"工欲善其事，必先利其器。","uri":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"},{"categories":["刷题"],"content":"【题目描述】 判断一个正整数 n 是否能被一个“幸运数”整除。幸运数是指一个只包含 4 或 7 的正整数，如 7、47、477 等都是幸运数，17、42 则不是幸运数。 【输入格式】 一行包含一个正整数 n(1≤n≤1000)。 【输出格式】 一行一个字符串，如果能被幸运数整除输出“YES”；否则，输出“NO”。 For example: Input Result 47 YES ","date":"2020-10-27","objectID":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/:0:0","tags":null,"title":"判断n能否被幸运数整除-do while循环应用","uri":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int n,i,j,flag; cin \u003e\u003e n; for(i=1;i\u003c=n;i++) { j = i; //这里不能直接用i来操作，因为i还要用于循环，不可以更改其值 do { if(j%10==4 j%10==7) { flag = 1; } else { flag = 0; break; } j = j / 10; } while(j); //当不符合条件时跳出循环 if(flag==1 \u0026\u0026 n%i==0) { cout \u003c\u003c \"YES\"; return 0; } } cout \u003c\u003c \"NO\"; return 0; } ","date":"2020-10-27","objectID":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/:1:0","tags":null,"title":"判断n能否被幸运数整除-do while循环应用","uri":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/"},{"categories":["刷题"],"content":"【题目描述】 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 【输入】 有2行。第1行为1个正整数N ，表示所生成的随机数的个数。第2行有N个用空格隔开的正整数，为所产生的随机数。 【输出】 共2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 For example: Input Result 10 20 40 32 67 40 20 89 300 400 15 8 15 20 32 40 67 89 300 400 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"分析 这题真的困扰了我好久妈了个逼的，一开始我用最基本的语法去写，结果我他妈直接写完报错，我以为是我的算法不够好，就发到唐老师群里求助，结果他说我上课不听课…我也想上他的课呀… 后来我去网上搜，有个人的博客里有这题，他用到了一个set，这个东西我不太清楚是啥，于是翻开我的c++primer去找，但是这本书实在是太专业了，我得把前面的看懂才能彻底搞懂这个东西，而且今天晚上我发现我要想搞懂这本书实在是太难了，我需要付出很多很多时间和精力。而我有更重要的任务去做，比如刷程序设计的题目，比如学习python，我真的不想再自己去碰一鼻子灰了，还是跟着导师的步子来吧。 所以今天晚上，我得明确我的学习线路：1.c++学习听老师的话，就以做题为主，不会的上百度搜，遇到一个点搞懂一个点就行了。2.python学习得跟上进度，提上日程。3.数学的学习也不能落下。4.在寝室里的时候就学学办公软件excel什么的。5.另外，多看看书，了解时局，和历史，最近对中国经济确实挺感兴趣。 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003cbits/stdc++.h\u003e //这玩意是万能头文件 using namespace std; int main() { int n; cin \u003e\u003e n; int x; set\u003cint\u003es; //set可以自动进行排序，默认是从小到大 for(int i=0; i\u003cn; i++) { cin \u003e\u003e x; s.insert(x); //这个有点像python的.append } cout\u003c\u003cs.size()\u003c\u003cendl; for(auto x:s) cout \u003c\u003c x \u003c\u003c' '; return 0; } 其它说明 for(auto i:v) cout«i; 遍历v里面的每一个元素。 begin(); // 返回指向第一个元素的迭代器 end(); // 返回指向迭代器的最末尾处（即最后一个元素的下一个位置） clear(); // 清除所有元素 count(); // 返回某个值元素的个数 empty(); // 如果集合为空，返回true equal_range(); //返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:2:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"【题目描述】 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 【输入】 有2行。第1行为1个正整数N ，表示所生成的随机数的个数。第2行有N个用空格隔开的正整数，为所产生的随机数。 【输出】 共2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 For example: Input 10 20 40 32 67 40 20 89 300 400 15 Result 8 15 20 32 40 67 89 300 400 ","date":"2020-10-24","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"每日一题-数组去重和排序","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int a[100]; int n,i,j,k; int cnt = 0; //输入数组 cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i]; } //去重 for(i = 0;i\u003cn;i++) { for(j=i+1;j\u003cn;j++) { if(a[i]==a[j]) { cnt++; //cnt为重复个数 //排序1 for(k=i;k\u003cn;k++) { a[k] = a[k+1]; } } } } //排序 int temp; for(i=0;i\u003cn-cnt;i++) { for(j=i+1;j\u003cn-cnt;j++) { if(a[j]\u003ca[i]) { temp = a[j]; a[j] = a[i]; a[i] = temp; } } } //输出数组 cout \u003c\u003c n - cnt - 1 \u003c\u003c endl; for(i=0;i\u003cn-cnt;i++) { cout \u003c\u003c a[i] \u003c\u003c \" \"; } return 0; } ","date":"2020-10-24","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"每日一题-数组去重和排序","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["书影记录"],"content":"本书的目录如下： （一）中国的官办经济–世界上最怪异的经济 （二）官办进出口：从“十个大庆”到八千亿美元外汇储备 （三）官办经济威力初级分析 （四）官办经济–不懂具体经济的老毛同志 （五）官办经济–中国苏联经济模式进阶分析 （六）官办经济–邓小平比拼戈尔巴乔夫 （七）官办经济–“猫摸”二论体现的实验方法与认识态度 （八）官办经济–中国政府的SWOT分析 （九）扯几句闲话，继续SWOT分析 （十）机会与危机 （十一）官办经济运行大法－－网中央的蜘蛛 （十二）“运行大法”的奇异之处 （十三）官办经济之前的改革时期 （十四）大气候，小气候 （十五）从“鸟笼经济”到“官办经济” （十六）邓小平的绝地反击 （十七）政府成了“经济人” （十八）崩溃危机 （十九）转型调控之路 （二十）企业效率问题 （二十一）穷政府 （二十二）气可鼓不可泄 （二十三）穷政府的几大主题 （二十四）毛泽东反全球化 （二十五）靠比较优势发家 （二十六）富政府的“超级现金牛” （二十七）“社会主义大事业”变成了“官办经济” （二十八）官办经济中的“官”与“民” （二十九）往下怎么搞 （三十）自主创新从哪里来 （三十一）从“出口导向”到“扩大内需” （三十二）微观的枷锁 （三十三）当经济增长不再解决问题 （三十四）五个世界 （三十五）邪恶轴心 （三十六）结束语 整体感知 这本书最有特色的地方就是他梳理了建国以来的经济发展历史，从最初的计划经济，到改革开放，中国政府一直把握着中国经济的命脉。中国政府摸爬滚打，自己都没想到自己搞出了这么牛逼的官办经济。中国从建国时的落后且挨打，到现在的富强且强硬，仅仅用了60多年。也介绍了不同时代的不少人物，按时间顺序，给我印象比较深刻的有老毛（毛主席），陈云，周恩来，邓小平，朱镕基，江泽民，胡景涛等等。作者的语言犀利有趣，除了历史课本，我真的很少有机会去了解新中国的野史，为了维护社会稳定，“文革”，“天安门事件”…等等这些事件很少被人们提起。但是作者大胆的叙述，让我大开眼界。现在的我也不再是叛逆的孩子了，看这些野史不是为了猎奇，而是为了更加透彻的洞察咱们社会的本质。到底中国政府是怎么一路走来的？到底我们要成为什么样的人才才是社会主义的可靠建设者和合格接班人？读了这本书，我填补了一部分知识盲区。所以，读这本书给我最大的收获，就是让我系统地了解了中国的经济模式到底是怎么一回事，社会的舆论都很极端和片面，有人在拼命地夸，有人在拼命地骂，我到底该相信谁？读了这本书后我的答案是谁也不相信，中国的经济有它巨大的优势，也有劣势，但总体上确实帮助中国富起来了，强起来了。并且我也了解中国是靠什么强起来的，我总结了两个字“出口”。怪不得中国被称为“世界工厂”，中国有政府作为经济人，劳动力廉价，效率还高，用外资来生产商品之后再卖给外国人，在这个过程中不断吞食产业，妙啊。读完书我才发现中国政府这么有钱，原来腐败是无法避免，且并不完全有害的，我才知道中国在国金经济上原来有这么重要的地位。中国现在提出要保护环境，解决三农问题，进行基础设施建设，改革教育医疗，原来都与经济有关！ 这是第一遍我读下来的感觉，我觉得我只读懂了40%，书中有很多经济术语，政治名词我是看不懂的，就像英语阅读里面有看不懂的单词一样，整体看下来，我大致知道它讲了啥，但是让我具体概括，我是很难用准确语言说出来的。尤其是该书的后半部分，介绍到现代世界部分，更加糊涂了。前面的历史，由于有初高中学过的政治历史作铺垫，容易理解，看起来也挺有意思。这让我不免又感叹，学政治和历史真不是没有用的，越要达到顶尖的高度，就越需要全面的知识。 ","date":"2020-10-19","objectID":"/posts/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AE%98%E5%8A%9E%E7%BB%8F%E6%B5%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《中国的官办经济》读后感","uri":"/posts/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AE%98%E5%8A%9E%E7%BB%8F%E6%B5%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["刷题"],"content":"【问题描述】一元二次方程：ax2+bx+c=0 （a ╪ 0） 【输入形式】输入a、b和c的值（有理数） 【输出形式】输出x的两个值，或者No（即没有有理数的解） 【样例输入】1 2.5 3 【样例输出】No 【样例输入】1 -2 1 【样例输出】1.00 1.00 【样例输出说明】输出的两个解保留两位小数，大的在前。 s = input() numLst = s.split(' ') resultLst = map(float,numLst) a,b,c = resultLst import math delta = b**2-4*a*c if delta \u003c 0: print('No') else: x1 = (-b+math.sqrt(delta))/(2*a) x2 = (-b-math.sqrt(delta))/(2*a) if x1 \u003e x2: print(\"%.2f\" % x1,\"%.2f\" % x2) else: print(\"%.2f\" % x2,\"%.2f\" % x1) ","date":"2020-10-19","objectID":"/posts/python-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/:0:0","tags":null,"title":"Python-一元二次方程，保留两位小数","uri":"/posts/python-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"【题目描述】 数学课上，楠楠学习了一个新的知识。 两数相除，如果得不到整数商，会有两种情况：一种是得到有限小数，另一种是得到无限小数。从小数点后某一位开始依次不断地重复出现前一个或一节数字的十进制无限小数，叫做循环小数，如2.9666…, (在数学中它读作“二点九六，六循环” ）， 定义循环小数的缩写法是将第一个循环节以后的数字全部略去，并将第一个循环节首末用括号括起来。 例如： 2.966666… 缩写为 2.9(6) 35.232323…缩写为 35.(23) 楠楠发现，根据循环小数的特征，很快能算出这个循环小数中小数点后第n位的数字，你能吗？ 【输入】 共2行。第一行，包含一个整数n(n≤100000)，表示求小数点后的第n位。第二行，一个字符串，用缩写法表示的一个循环小数。 【输出】  一行，包含一个整数，表示循环小数中小数点后第n位的数字。 For example: Input Result 10 352.19(7) 7 ","date":"2020-10-17","objectID":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/:0:0","tags":null,"title":"识别字符","uri":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { char a[100]; int weishu,buxunhuan,xunhuan,m,jieguo1; cin \u003e\u003e weishu ; //输入1 int n=0; cin \u003e\u003e a[0]; while((a[++n]=getchar())!='\\n'); //输入2 int i,left,right,dian; for(i=n;i\u003e0;i--) { if(a[i] == ')') right = i; if(a[i] == '(') left = i; if(a[i] == '.') dian = i; } buxunhuan = left - dian -1; xunhuan = right - left -1; if(weishu \u003c= buxunhuan) { jieguo1 = weishu + dian; cout \u003c\u003c a[jieguo1]; } else { m = (weishu - buxunhuan)%xunhuan; if(m==0) { cout \u003c\u003c a[left + xunhuan]; } else { cout \u003c\u003c a[m+left]; } } return 0; } ","date":"2020-10-17","objectID":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/:1:0","tags":null,"title":"识别字符","uri":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"原理在这https://www.bilibili.com/video/BV1k7411q7jo ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"倒序写法 import random def shuffle(lis): for i in range(len(lis) -1,0,-1): p = random.randrange(0,i+1) lis[i],lis[p] = lis[p],lis[i] return lis 这里在random库下定义了一个函数shuffle 之所以是i+1是因为random.randrange()是左闭右开的，不包括i+1 lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) 每次运行这段代码结果应该都是不一样的 ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"正序写法 import random def shuffle(lis): for i in range(0,len(lis) -1,1): p = random.randrange(i,len(lis)+1) lis[i],lis[p] = lis[p],lis[i] return lis lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"实际上在random库中本事提供了这样的函数 这样直接写也是可以的 import random lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目描述】  根据样例在屏幕上输出一个平行四边形，如果每行字母超过了z，则从a重新开始。 【输入】  一行，包含一个整数n（2\u003cn≤26）。 【输出】  见样例。 For example: ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/:0:0","tags":null,"title":"每日一题--a到z26个字母循环输出","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int i,j,k,n; char ch; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { for(k=0;k\u003ci;k++) { cout\u003c\u003c\" \"; } for(j = 0; j\u003cn;j++) { ch = 'a'+ (j + i)%26; cout \u003c\u003c ch; } cout \u003c\u003c endl; } return 0; } ch = ‘a’+ (j + i)%26; 这段代码很有味道，控制了首个字母，以及循环。 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/:1:0","tags":null,"title":"每日一题--a到z26个字母循环输出","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"【题目描述】 营业额我叫王大锤，昨天还是一名C++老师。万万没想到，我又失业了。昨天上课前我写的程序让整个学校的电脑中了病毒。为了生计，无可奈何，在学校旁边的唐师傅理发店找了一份兼职。 唐师傅理发店已经开张十年有余，生意红火。唐币是一种专门用来唐师傅营业额的，用int以至于long long int已经无法表示唐师傅的总营业额了。而唐师傅又想要计算自开业以来的总营业额。他给了我两个账本和我的第一个任务，能不能获得这份工作，在此一举！ 每个账本都已经在最后一页写上了这一时期的总营业额，设计一个程序，计算出它们的和。 【输入】 共2行，每行1个正整数(不超过100位)，分别表示每个账本上写着的总营业额（单位：唐币）。 【输出】  一行，包含一个整数，表示总的营业额。 For example: Input Result 1 9 10 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/:0:0","tags":null,"title":"每日一题--有进位的加法运算","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; int main() { int a[110]={0},b[110]={0},c[110]={0}; int i,j,lent,lens,len; char s[110],t[110]; cin \u003e\u003e s \u003e\u003e t; lens = strlen(s); lent = strlen(t); len = max(lens,lent); for(i=lens-1,j=0;i\u003e=0;i--,j++) //将s逆序存储到整型组a中 { a[j] = s[i] - '0'; } for(i=lent-1,j=0;i\u003e=0;i--,j++) //将s逆序存储到整型组a中 { b[j] = t[i] - '0'; } for(i=0;i\u003clen;i++) //进位运算 { c[i] = c[i] + a[i] + b[i]; if(c[i] \u003e 9) { c[i+1]++; c[i] = c[i] % 10; } } if(c[len]!=0) //判断最高位是否进位，即计算结果数据长度是否加1 { len++; } for(i=len-1;i\u003e=0;i--) //逆序输出 { cout \u003c\u003c c[i]; } cout \u003c\u003c endl; return 0; } q1为什么要倒序相加？ 因为两个相加的数字的位数可能不同，倒序之后可以对齐 q2为什么我看不懂一些参数的数值控制，比如len-1… 因为数组是从0开始的，a[0]是第一位，看不懂就自己拿笔写一遍 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/:1:0","tags":null,"title":"每日一题--有进位的加法运算","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"},{"categories":["刷题"],"content":"【题目描述】 给出n个同学的身高，请根据他们的身高升序排列并输出排序结果。 【输入格式】 第一行包含1个正整数 n（2\u003cn≤100），表示有 n 个同学的身高。 第二行包含 n 个正整数，之间用一个空格隔开，表示 n 个同学的身高。每个同学的身高都在 150~200 厘米之间。 【输出格式】 一行 n 个正整数，之间用一个空格隔开，表示 n 个同学根据身高升序排列的结果。 For example: Input Result 7 180 170 176 160 155 150 160 150 155 160 160 170 176 180 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"每日一题(2)--很多个数排序问题","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int i,j,k,n,a[100]; //输入部分 cin \u003e\u003e n; for(i=1;i\u003c=n;i++) { cin \u003e\u003e a[i]; } //输出部分 for(i=1;i\u003c=n;i++) //外层循环i,选出第i位小的数 { k = i; //a[k]是被比较的那个数 for(j=i+1;j\u003c=n;j++) //内层循环，选出第i位之后最小的数 { if(a[j]\u003ca[k]) { k = j; //遇到更小的数，替换a[k] } } if(k!=i) { swap(a[i],a[k]); //把最小数替换到前面 } } //输出部分 for(i=1;i\u003cn;i++) { cout \u003c\u003c a[i] \u003c\u003c \" \"; } cout \u003c\u003c a[n] \u003c\u003c endl; return 0; } 思路：“打擂台”：每一趟把最小的数挑出来放好 第一趟把n个数中最小的数放在第一个位置，第二趟把2到n这n-1个数中挑出最小的放在第二个位置，以此类推 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"每日一题(2)--很多个数排序问题","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["笔记"],"content":"【题目描述】 公司举办年会，为了活跃气氛，设置了摇奖环节。参加聚会的每位员工都有一张带有号码的抽奖券。现在，主持人从小到大依次公布 n 个不同的获奖号码，小唐看着自己抽奖券上的号码 win，无比紧张。 【输入格式】 第一行一个正整数n（2\u003cn≤100），表示有n个获奖号码。 第二行包含n个正整数，之间用一个空格隔开，表示依次公布的n个获奖号码。 第三行一个正整数 win，表示小唐抽奖券上的号码。1≤获奖号码，win\u003c10000。 【输出格式】 一行一个整数，如果小唐中奖了，表示中奖的是第几个号码；如果没有中奖，则为 0。 For example: Input Result 7 1 2 3 4 16 27 55 3 3 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/:0:0","tags":null,"title":"每日一题--二分法找数组中的数","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/"},{"categories":["笔记"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int n,i,win,a[100]; cin \u003e\u003e n; //输出部分 for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i]; } cin \u003e\u003e win; int left = 0,right = n-1; //left存放第一个元素下表,right存放最后一个元素的下标 int found = n; //found标记找到的位置，初始化为n,表示没有找到 //二分过程 while(left \u003c= right) { int mid = (left + right)/2; if(a[mid] == win) //找到了标记位置并退出循环 { found = mid; break; } if(win \u003c a[mid]) { right = mid-1; //win只能在左半部分 } else if(a[mid] \u003c win) { left = mid+1; } } //输出部分 if(found !=n) { cout \u003c\u003c found + 1 \u003c\u003c endl; //对应的下标加1输出第几个号码 } else { cout \u003c\u003c 0 \u003c\u003c endl; } return 0; } 注意该案例中数组是从0到n-1定义的，共有n个数 要在编程中考虑到0是第一个数 其实实际编程过程真的不想把0设为第一个数 怪麻烦的 不知道教程为啥要这样写 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/:1:0","tags":null,"title":"每日一题--二分法找数组中的数","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/"},{"categories":["笔记"],"content":"【题目描述】 输入一个正整数 n，求各位上的数字和。 【输入格式】 一行，包含一个正整数 n，n 最多 200 位。 【输出格式】 一行，一个整数，表示正整数 n 的各位数字之和。 #include \u003ciostream\u003e using namespace std; int main() { char a[200]; int i,sum=0; cin \u003e\u003e a ; for(i=0;a[i]!='\\0';i++) { sum = sum + (a[i] - '0'); } cout \u003c\u003c sum \u003c\u003c endl; return 0; } 利用字符数组储存这个超大数 如果a[]是一个字符数组的话，a[i]-‘0’就是a[i]这个字符和‘0’这个字符ASC码的差值,计算结果为整形 利用a[i]!='\\0’来判断字符串是否结束 ","date":"2020-10-07","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B1%82%E8%B6%85%E5%A4%A7%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C/:0:0","tags":null,"title":"每日一题--求超大数的各位数字和","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B1%82%E8%B6%85%E5%A4%A7%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C/"},{"categories":["刷题"],"content":"#include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cctime\u003e using namespace std; int main() { srand((int)time(0)); // 产生随机种子 把0换成NULL也行 int left,right,oper,result; char char_oper; //除了数字oper变量外，还有字符char_oper变量 left = rand() % 10; right = rand() % 10; oper = rand() % 4; //这是加减乘除符号，用0,1,2,3四个数表示 switch(oper) { case 0:char_oper = '+'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left + right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 1:char_oper = '-'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left - right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 2:char_oper = '*'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left * right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 3:char_oper = '/'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left / right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; } return 0; } 利用随机数实现非数字变量的随机 0表示+ 1表示- 2表示* 3表示/ 用switch语句实现 这段代码比较巧妙，稍微琢磨一下 ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%87%BA%E9%A2%98%E8%87%AA%E5%8A%A8%E6%89%B9%E6%94%B9/:0:0","tags":null,"title":"每日一题--给小朋友的自动出题自动批改","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%87%BA%E9%A2%98%E8%87%AA%E5%8A%A8%E6%89%B9%E6%94%B9/"},{"categories":["刷题"],"content":"【题目描述】 输入一个正整数 n，输出 n×n 的回型方阵。例如，n=5 时，输出： 1 1 1 1 1 1 2 2 2 1 1 2 3 2 1 1 2 2 2 1 1 1 1 1 1 【输入格式】 一行，包含一个正整数 n，2≤n≤9。 【输出格式】 共 n 行，每行包含 n 个正整数，之间用一个空格隔开。 ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:0:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"答案1 先给左上角负值，再通过下标的对称性复制到左下角，右上角，右下角 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int n,i,j,a[10][10]; cin \u003e\u003e n; for(i=1;i\u003c=(n+1)/2;i++) //只写入整个数组的四分之一，多出四分之一的部分无所谓 { for(j=1;j\u003c=(n+1)/2;j++) //i控制行数，j控制列数 { a[i][j] = min(i,j); //min函数引用了algorithm库,i和j中较小的那个值恰好是需要写入的值 a[i][n+1-j] = a[n+1-i][j] = a[n+1-i][n+1-j] = a[i][j]; //左右对称，上线对称，对角线对称 } } for(i=1;i\u003c=n;i++) //输出部分 { for(j=1;j\u003c=n-1;j++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \"; } cout \u003c\u003c a[i][n] \u003c\u003c endl; //最后一个输出单独写，因为空格 } return 0; } ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:1:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"答案2 通过“一圈一圈”赋值的方法做，先给a[1][1]到a[n][n]全部赋值1，然后给a[2][2]到a[n-1][n-1]全部赋值2，……共n/2圈（如果n是奇数，则最后一圈就是一个数） #include \u003ciostream\u003e using namespace std; int main() { int n,i,j,k,a[10][10]; cin \u003e\u003e n; for(k=1;k\u003c=(n+1)/2;k++) //输入部分，看不懂就另n=5,k=1,k=2,i=1,i=1,j=1,j=2演算一遍 { for(i=k;i\u003c=n+1-k;i++) { for(j=k;j\u003c=n+1-k;j++) { a[i][j] = k; } } } for(i=1;i\u003c=n;i++) //输出部分 { for(j=1;j\u003c=n-1;j++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \"; } cout \u003c\u003c a[i][n] \u003c\u003c endl; } return 0; } ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:2:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["笔记"],"content":"总体感受 这是我跟着b站昕哥的视频学习\"Python数据分析“的第二周，总体上感觉Python确实是比c++要简单不少，学c++就像是开手动挡汽车，虽然难学，但是学会之后可以享受操纵的乐趣。而学Python就像是开手动挡汽车，简单上手，也功能强大。 和以前在网上自学其它东西不一样的是，这次学习Python，我有一个团队陪我一起，虽然团队的成员不太听我的话，但是我乐在其中，有什么麻烦的问题被解决了，我会发自内心地想要分享出来，不管是否对别人有所帮助，我都要满足我装逼的心理。 ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:1","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["笔记"],"content":"已经学到的东西 在第一章里，大致了解了Python这门语言，知道了它是解释型语言，是一门高级语言(虽然这些我之前就知道)。解释型语言我之前也接触过类似的，比如超文本标记语言html5，虽然只是浅尝辄止，但是接触过和没接触过的区别就是1和0之间的区别。毕 竟 0 的 无 数 倍 都 比 不 上 1 。 第二章，就比较枯燥乏味了，学的是基本数据类型。要记忆的东西很多，我也开始做笔记了。我的学习方法是，先看一遍视频，把知识点都截图在笔记里，然后照着笔记把所有代码都打一遍，如果遇到看不懂的地方，就打开视频把那一块再看一遍。这样，我大部分知识点仍然是记不住，但是在我脑海里会有个印象，当我在做练习时，我想实现某个功能时，我就能想到那条语句，然后把笔记调出来，再看一遍笔记，把知识点用在实战中，一次两次就能记清楚了。 还学到了其它东西: 我还捯饬了半天搞了个博客，又弄了个域名 我还发信息有道云笔记贼好用 我还在想办法搞定Latex ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:2","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["笔记"],"content":"未来的目标 总感觉没做什么时间就不够了，时间够了精力又不够了，时间精力够时我又感觉很懒，想打game，想看动漫，想出去喝酒，不想敲代码，不想学习，不想动脑子，反正在这里也没人管我。 但是不行啊，放弃是最简单的事情，还是坚持下去吧。 ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:3","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["刷题"],"content":"修改pip源： https://jingyan.baidu.com/article/b24f6c8296b507c6bee5da4f.html 修改jupyter默认目录： 在jupyter中键入 !jupyter notebook –generate-config 这样会在c盘的用户文件中写入一个叫jupyter_notebook_config.py的配置文件 在c盘用户文件夹中找到.jupyter目录 找到刚写入的文件jupyter_notebook_config.py 可以用IDLE打开，上面菜单栏有edit\u003efind查找工具 （用其他编辑器如记事本啥的应该都行） 找到#c.NotebookApp.notebook_dir =’ ‘去掉注释后，在‘ ’中输入你想启动目录路径 注意目录的格式中的”\\”要改成”\\”否则jupyter无法运行。 以上步骤做完后，需要更改快捷方式的位置，找到Jupyter的快捷方式，右键打开属性，将快捷方式中“目标”中的”%USERPROFILE%”去掉。(引号也要去掉) 再启动服务器进入页面，就成功了 qwq搜索了好多教程，每个教程都是不能成功，综合在一起捯饬了半天才总结如上方法qwq ","date":"2020-09-30","objectID":"/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/:0:0","tags":null,"title":"第一章练习题","uri":"/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":null,"content":"关于我 2022年初寒假，使用hugo+Lovelt+github+jsdelivr打造此博客，用于学习和记录学习。 qq：1942956063，欢迎给我打钱。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"书影记录 ","date":"0001-01-01","objectID":"/bookshelf/:0:0","tags":null,"title":"","uri":"/bookshelf/"},{"categories":null,"content":"记录上大学后读过的书 以前没有写读书笔记的习惯，以后一定要养成写读书笔记的习惯！💪 书名 作者 简介 读书笔记 备注 罗生门 芥川龙之介 既然是为了生存，还有什么不可以的？ 大学前暑假看的 浮生六记 沈复 古人伉俪情深的生活记叙。 大学前暑假看的 阿Q正传 鲁迅 旧时代愚钝腐朽的中国人。 大学前暑假看的 老人与海 海明威 永不向命运低头的硬汉精神。 null 围城 钱钟书 旧知识分子，旧婚姻。 null 边城 沈从文 描绘湘西地区特有的风土人情。 null 动物农场 乔治·奥威尔 反乌托邦政治讽喻寓言。 null 中国的官办经济 陈经 看江湖派如何解说中国经济。 《中国的官办经济》读后感 他改变了中国 罗伯特·劳伦斯·库恩 西方人笔下的中国领导人。 一往无前 范海涛 小米的血泪奋斗史。 乖，摸摸头 大冰 爱与温暖的故事。 京华烟云 林语堂 超喜欢木兰。 《京华烟云》读后有感 王阳明传 梅韩 “此心光明，亦复何言。” 如何阅读一本书 莫提默·J·艾德勒/查尔斯·范多伦 教你学会读书的一本书。 《如何阅读一本书》读后感 小王子 圣埃克苏佩里 当我不开心的时候就会去读这本书。 消失的13级台阶 高野和明 很好看的日本推理小说。 《消失的13级台阶》读后感 盗墓笔记1、2 南派三叔 惊险刺激的冒险小说。 人类简史 尤瓦尔·赫拉利 从人类的角度去认识历史，书中观点很新颖很有趣，值得一看！ 《人类简史》读后有感 共产党宣言 马克思、恩格斯 全世界无产者，联合起来！ 堂吉诃德 塞万提斯 中二病始祖堂吉诃德的冒险故事。 房思琪的初恋乐园 林奕含 一本女性题材的著作，很露骨，很悲伤。 史蒂夫·乔布斯传 沃尔特·艾萨克 果粉必读，中立、客观。很多经典句子的出处。 《史蒂夫·乔布斯传》读书笔记 百年孤独 马尔克斯 把拉丁美洲的血泪史融入一个家族100年的兴亡当中。 撒哈拉的故事 三毛 前半段日常非常有趣，后半段主线剧情。三毛的文笔让人看了就爱❤️ 明天也是小春日和 津端英子/津端修一 讲了两位日本老人的田园生活。很治愈。 《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴 雪国 川端康成 感伤的东方美，以及男人的怪癖。 《雪国》读书笔记 2022.2.12 湖 川端康成 人生无常，万事皆空。 2022.2.15 学术研究你的成功之道 凌晓峰、杨强 读研或读博前看到这本书感觉很幸运。 2022.2.20 邓小平时代 傅高义 改革开放的总设计师。 《邓小平时代》——改革开放的总设计师 2022.3.18 秒速五厘米 新海诚 樱花🌸下落的速度是秒速五厘米，我该以什么速度才能靠近你? 2022.3.23 失乐园 渡边淳一 性教育启蒙。 《失乐园》读后有感 2022.4.13 无人生还 阿加莎·克里斯蒂 剧透：最后所有人都死了。 《无人生还》读后有感 2022.4.30 ","date":"0001-01-01","objectID":"/bookshelf/:1:0","tags":null,"title":"","uri":"/bookshelf/"},{"categories":null,"content":"记录看过的电影（部分） 影片名 简评 观后感 备注 87版红楼梦 王熙凤，林黛玉，贾宝玉…永恒的经典。 87《红楼梦》观之有感 大二军训时候看的 菊次郎的夏天 我觉得这个片子真的好好笑哈哈哈。 《菊次郎的夏天》观后感 null 新喜剧之王 星爷～ 《新喜剧之王》观后感 null 华尔街之狼 看看资本主义暴发户的腐烂生活。 《华尔街之狼》观后感 大一寒假 十二公民 讲述了当代中国一个由富二代“杀人案”引发了最为激烈的法庭智斗的故事。 《十二公民》观后感 唐人街探案1 很不错的电影，喜剧搞笑、悬疑够劲儿、演员颜值也能打。 怒火重案 陈木胜导演的绝唱，主演谢霆锋、甄子丹，经典剧情的警匪港片，特别爽特别帅，男人就该看这种片。 甲方乙方 “地主家也没有余粮呀～” 哈利·波特与魔法石 老少皆宜的童话故事。 who am i 室友推荐的德国黑客（指物理和心理黑客）电影。剧情反转回味十足。 入殓师 奥斯卡金像奖，08年在日本上映，21年在中国上映，可能中国也要正视老龄化问题了吧。 英雄联盟：双城之战 豆瓣9.1分，绝对不辜负撸友的期待。 速度与激情1 经典，不解释。 色，戒 汤唯真好看～ 小姐 아가씨 女同片，非常魔幻。 误杀2 我觉得很好看，不知道为什么评价这么低。 2022.1.20 误杀1 还是去看误杀2吧。 2022.1.21 半泽直树 最强打工人！很好看的日剧。 《半泽直树》观后有感 长津湖之水门桥 看吴京、易洋千玺打美国鬼子，有点血腥。 鬼灭之刃 立志篇 背着妹妹去杀鬼～ 大二下学期初 模仿游戏 天才总是孤独的。 2022.2.28 心灵奇旅 你找到你生命的“火花”了吗？ 2022.3.4 泰坦尼克号 杰克和露丝的爱情故事❤️，永远的经典～ 2022.3.12 蝙蝠侠 民风淳朴哥谭市。 2022.3.18 叶问 我要打十个！👊 2022.3.25 投名状 你以为是武打戏，其实是政治戏、感情戏！ 2022.4.4 师父 南蛮子闯天津 2022.4.24 ","date":"0001-01-01","objectID":"/bookshelf/:2:0","tags":null,"title":"","uri":"/bookshelf/"},{"categories":null,"content":"写给高若宇的话 我该怎么称呼你呢，亲爱的？太肉麻了吧。若宇，太平淡了。那就叫你的小名臭宝好了。臭宝，2022年寒假跟你出去玩了六次。第一次是跟你去猫咖，那天我刚好看完一本书，觉得很不错就送给了你。第二次是给你过生日，在海底捞吃了火锅，又去电玩店，跟你玩游戏非常非常开心。第三次见到了你妹妹，咱们先吃饭再逛街，吃的是肉蟹煲，还玩了抓娃娃机。第四次我们去了万达大玩家，这次抓到了两个娃娃，抓娃娃的技术又提高了！还去做了陶艺，然后去了百货大楼的小吃街，最后坐上那趟乘坐无数次的公交车，仿佛穿梭到了你的童年。从前的你是多么幸福啊，跟这么幸福的人在一起，我一定也会变得幸福吧。第四次我们去给陶艺上色，去张公山公园看雪景，我俩拉着你妹妹真像一家三口。天是蓝色的，雪是白色的，拍立得是粉红的，想和你在五彩缤纷的世界里白头到老。第五次我又送你回家了，路上我牵着你的手，就好像牵住了整个冬天，你给我买的冰糖雪梨我吃完就不咳嗽啦。第六次是寒假最后一次见面了，这一次我要把这封信递给你。 整个寒假，跟我出去玩的除了刘鑫宇就是你。一想到马上就要分别了，一分别就是整整一年，心里别提有多难过了。就好像丢了很重要的东西，特别怅然若失。 还记得我是什么时候表白的吗？是2021年5月23日，那天我买了一束花送给1330公里外的你。第一次表白，竟没有亲临现场，看不见你当时的表情，是个小遗憾。说真的，我是一个非常非常不合格的男友。我没能守在手机边秒回你的消息，没能趴在你耳边说几句情话，没能在周末牵着你的手跟你去看电影，没能在你来大姨妈时给你煮红糖水，没能在考试前陪你复习，也没能在你回家的时候亲自去接你。1330公里的距离，把你我分隔成两个世界。当你在大连清晨六点半起来跑操时，我可能还在被窝里梦见昨晚写的代码。毕业之后，你得去舰艇，我得去读研，不知道何时能共赴同一座城市。我对你的表白，不仅跨过了遥远的空间，还跨过了漫长的时间！ 我妈很喜欢你，我和你出去玩回来之后，我妈问我跟谁出去玩了。我说：“去给高若宇过生日了。”我妈竟然笑着说，“你俩还联系呀，高若宇这孩子我真喜欢，以后找媳妇就找高若宇这样的。”说到谈婚论嫁，说真的，我真希望陪我后半生的那个人是你。在我活着20年接触的所有女生当中，没有哪个女生像你一样能跟我相处那么久。如果不是你的话，我宁愿跟刘鑫宇过日子也不想搭理其他人。但是，世事难料，我对我的未来毫无把握，只能希望高中没缘分的我们能在毕业后多一点缘分吧！ 你在军校，那里最不缺的就是男孩子。肯定会有男孩子跟你献殷情，我觉得很正常，也不会吃醋。但你要知道，每个男生都在打自己的小算盘，他们有付出就会索取回报。如果你收受了他们的好处，就请一定找个机会还他们个人情。不要把他们对你的好当成他们心甘情愿，他们都不傻，不会轻易爱上一个女孩。就像做买卖一样，一直付出却得不到回报，很可能会撕破脸皮，让你受到伤害。当然了，我知道你和男生们做兄弟，相处的很好，不需要我担心。我只是多嘴提醒一下。 你是一个特别奇葩的女生。别人在玩洋娃娃的时候你在玩妹妹，别人花钱你赚钱，别人吃饭你做饭。你会解奥数题，也会玩飞行棋，会在北师大的楼梯口偷吃牛肉拉面，会在受到挫折的时候哭的稀里哗啦，拿到手机你喜欢追电视剧，上微博吃瓜，还喜欢打游戏，虽然那么菜。但跟你一比，我就跟土包子似的，啥都不知道，只会跟你讲我的偶像乔布斯，讲“苹果的哲学”，世上怎么会有如你这般可爱的人落到我这种大猪蹄子里？ 自从我对你表白后，我们之间的感情好像没有经过蜜月期的轰轰烈烈，而是直接跳到了老夫老妻似的平平淡淡。我研究过蜜月期是怎么产生的：往往是由于一对情侣刚刚相识，脑子里充满对甜美爱情的幻想，忽视了对方的缺点而把优点无限放大。可我们不一样，我们曾一起成长，彼此知根知底，我们很清楚对方的缺点和优点，所以用最低的能量也能适应对方。丢人的说，其实我的内心是非常渴望有一场干柴烈火的爱情的。幸运的是，我发现我们的感情不是没有蜜月期，是蜜月期还没有到来！你跟我提到多次，你的同学当中有的男生放假后直接奔赴女生所在的城市。我一开始听到这个蛮惊讶的，但后来转念一想，也许只要改变了生活的状态，我们就能重新认识对方。所以我现在郑重考虑找一个时间，可能是五一、可能是国庆，我去大连找你，或者我们一起去另一个城市旅游，肯定会有一段非常甜蜜的时光。 哎呀呀，说了一堆有的没的，还是改变不了即将分别的事实。虽远隔1330公里，但彼此把对方当作内心的支柱，积极分享彼此的生活。对于我来说，地方大学的生活太懒散了，我要向你学习，热爱生活，多锻炼，多吃美食，多穿好看的衣服。在下一次见到你之前，让自己变得更好吧！ 另外，有个小惊喜，请你访问https://sbllovegry.github.io/ 查看程序员的浪漫 ","date":"0001-01-01","objectID":"/hide/%E5%86%99%E7%BB%99%E9%AB%98%E8%8B%A5%E5%AE%87%E7%9A%84%E8%AF%9D/:0:0","tags":null,"title":"","uri":"/hide/%E5%86%99%E7%BB%99%E9%AB%98%E8%8B%A5%E5%AE%87%E7%9A%84%E8%AF%9D/"}]
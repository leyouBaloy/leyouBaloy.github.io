[{"categories":["笔记"],"content":"变量符号 第一次出现的变量符号需要解释，后面不需再解释。 文章中所有的变量符号要保持一致，不能前后歧义。解决这个问题最好的办法就是在写作时维护一个符号表。如果文章的公式变量较多，强烈建议这么做，否则后面改起来会很痛苦。 所有单字母变量，都要采用斜体。多字母变量和函数，采用正体。对于下标，若下标本身是说明性的文字，不管单字母还是多字母，采用正体。若下标本身是单字母变量，就采用斜体。加粗起强调作用，是否加粗由作者决定，一般都不用加粗。 如果变量的下标有意义，那么尽量不要使用单字母。比如宽哥论文中的Im中的m表示的是mask，那么最好使用Imask替换Im。这样更有助于读者明白含义。 变量的下标尽量不要太长，可以适当缩减，比如Icomplete可以改成Icomp。但是不要缩太短引起歧义，比如如果缩成Icom就会让读者误以为是Icommon。 表格设计 表格的设计要规整，不能把几种表达方式混在一起。比如下面的表格将方法和指标混在一起，使用了箭头和数字的表达形式，这是混乱的： 修改为： 表头要完整，不要省略。如下表第一列缺少表头Module： 修改为： 缩略语 缩略语在文中第一次出现时需要定义，后面统一使用缩略语。 比如gate residual unit (GRU)，在后面出现的时候统一使用GRU。 仅在文中出现一次的，不要使用缩略语。同时建议出现次数少于 3 次的，也不要使用缩略语。 这里的第一次，是摘要、正文中分别计算的。如果摘要和正文都符合上面所说使用缩写的规则，那么摘要中需要定义一次，正文中还需要定义一次。 对于图表中出现的缩略语，需要单独在图注或表注中定义。 对于一些行业共识术语，可以直接使用缩略语，不遵守以上规则。 比如说在人工智能期刊可以直接使用ReLU、 CNN 等。 少用 of 短语 少用of短语构成的修饰词，这样可以使句子变简单，简单的句子最有说服力。比如： As an important carrier of information preservation, quality of image directly affects the preservation of information. 修改为 As an important carrier of information preservation, image quality directly affects the preservation of information. 错用比较级 比较级修饰词或术语通常需要明确比较的对象。当无法提供比较基准时，采用词语的原级形式。这通常是中文思维导致的错误。比如： In addition, the positioning accuracy of the mask influences the image restoration quality, and an incorrect mask can lead to poorer results. 修改为 In addition, the positioning accuracy of the mask influences the image restoration quality, and an incorrect mask can lead to poor results. 再比如： Benefiting from the ringed residual structure to amplify representation differences and prediction category confidence-driven refinement of the prediction mask, the highlights are more accurately located and removed by our method 修改为 删去more 错用significant/significance/significantly “significant/significance/significantly”有特殊的用法，不能随意使用。 在科学、技术和医学领域中，当提到统计阈值和p值时，使用“significant/significance/significantly”。在没有p值的情况下，最好不要使用，可以使用“considerable/considerably”、“substantial/substantially”、“remarkable/remarkably”或其他类似的词语替代。 例如： The aforementioned phenomena can lead to a significant loss in the expression of image content. 修改为 The aforementioned phenomena can lead to a remarkable loss in the expression of image content. 注：这一点是编辑给出的意见，个人觉得有些啰嗦，实际上很多论文都没有遵守。不过严谨的论文确实会回避significant/significance/significantly，所以最好还是注意一下。 it指代不明 使用“it”可能会导致混淆。为了清晰明确，应在句子开头指明“it”所指代的内容。我们在写论文时难免会由于太过主观而导致出现这类问题，可以在写完之后多读几遍，找到歧义的地方。比如： The final RResBlk is structured in a ring by running the residual propagation twice and the residual feedback once, as shown in Fig. 3 (right). This ring structure effectively enhances the learning effect of CNN and avoids gradient degradation as the network deepens. It also notably distinguishes essential attribute features between different categories and further reinforces the discrimination between inconsistent patterns and backgrounds. 其中的it指代不清，到底是The final RResBlk还是This ring structure？修改为： The final RResBlk is structured in a ring by running the residual propagation twice and the residual feedback once, as shown in Fig. 3 (right). This ring structure effectively enhances the learning effect of CNN and avoids gradient degradation as the network deepens. The structure also notably distinguishes essential attribute features between different categories and further reinforces the discrimination between inconsistent patterns and backgrounds. 大小写混用 标题的实词的首字母需大写。例如，主语、谓语、宾语等实词的第一个字母都需要大写。虚词（如介词、连词）一般应使用小写字母。每一节的标题也应该用大写。 有的多词组成的名词不是专业名词，容易大小写误用。比如gate residual unit，不要写成Gate Residual Unit. 通用词保持一致 除了专业名词、符号变量要在全文保持一致之外，一些通用词也需要保持一致。比如表示方法的名词有“method”，“approach”，“technique”，选择一个使用即可，不要混用。名词的单复数也要保持一致。咱们都看过不少小说，小说是文学类作品，文学是博大精深的，讲究语言的丰富性，所以同一个事物会用很多种表达形式。而论文不是，论文的语言要简单、严谨、一致。在这一点上要尤其注意调整思维方式。 错用the the的语法比较复杂，有的时候会冗余，比如： Considering image quality, our results are comparable to those of SHDR[4], which are considerably similar to the ground truths. 修改为 删去the 还有的时候的时候缺少，比如下面这句的the表示特指上文提到的last RResBlk，少了the就表示任意last RResBlk 了 ： The main framework of IDN comprises seven RResBlk, which are independent of the human visual system and effectively reduce false predictions by","date":"2023-12-23","objectID":"/posts/sci%E8%AE%BA%E6%96%87%E6%B6%A6%E8%89%B2%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:0:0","tags":null,"title":"SCI论文润色经验分享","uri":"/posts/sci%E8%AE%BA%E6%96%87%E6%B6%A6%E8%89%B2%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["书影记录"],"content":"《置身事内》是复旦大学经济学院副教授兰小欢的科普读物。兰教授写这本书的目的是让更多的国人了解我国的经济政策。过去十年，我国的经济发展可以用“起飞”二字来形容。一提到中国经济，大家都非常自信且乐观的。但是到了疫情结束后的2023年，大家明显感到经济增速放缓了，生活和工作压力变大了。对于我们大学生来说，最关心的就是就业，最直观的感受就是今年的工作明显不好找了。除此之外，如果经常看新闻的话，会知道一件大事，就是恒大许家印被抓，这代表了我国房地产行业将进入凛冬。而房地产对我国经济有多重要，看了这本书你就会明白。 这本书的名字起的非常切题。看似宏大的经济政策其实与我们每个人都息息相关，而陌生的政府公文和经济学术语又让我们望而却步，所以这本书就是搭建起一个桥梁，将我国的经济现状通过较为通俗的语言表述出来，让大家切实感受到在国家的经济发展中置身事内。 作者的目的确实达到了，我阅读完之后，对我国当前的经济政策有了较为全面的了解。但是不得不说这本书并不是非常通俗易懂，作为非经济学专业的人，有许多论述还是不太理解，不过这无伤大雅。读完之后，整体上收获还是很大的。推荐阅读！ 另外，我在阅读书籍的过程中，常常会对书中一些句子产生共鸣。这样一些零散的想法，写在博客里不成逻辑，也没人愿意看，所以干脆不发表出来。但是最近我发现微博是一个很好的平台，我可以把它们不定期的发在微博里。这样，说不定还会有跟我志同道合的人看到，跟我一起讨论，扩大我的社交范围。 ","date":"2023-12-11","objectID":"/posts/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"《置身事内》读书笔记","uri":"/posts/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["技能分享"],"content":"安装Visual Studio 2017 先下载Visual Studio Installer https://learn.microsoft.com/en-us/visualstudio/python/installing-python-support-in-visual-studio?view=vs-2022 打开Visual Studio Installer-\u003e选择“工作负荷”-\u003e使用C++的桌面开发、Python开发。 另外，在“Python开发”里，选择Python本机开发工具。 然后开始安装这一套软件，默认装的是社区版，够用。 下载Python源代码 https://www.python.org/downloads/release/python-3913/ 下载完解压 开始编译 用命令行进入PCbuild目录，执行build.bat文件 编译完了之后，编译后文件会出现在PCbuild目录的amd64目录下 可以用命令行执行amd64目录下的python.exe 测试编译 参考这个文档，可以对源代码做一个小修改 https://flaggo.github.io/python3-source-code-analysis/preface/modify-code/ 然后进入PCbuild/amd64目录下的python.exe试试效果 可能还会有其它报错，我就遇到了 D:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\VC\\VCTargets\\Microsoft.Cpp.WindowsSDK.targets (46,5): error MSB8036: 找不到 Windows SDK 版本10.0.22621.0。请安装所需的版本的 Windows SDK 或者在项目属性页中或通过右键 单击解决方案并选择“重定解决方案目标”来更改 SDK 版本 。 [D:\\Python-3.9.13\\Python-3.9.13\\PCbuild\\pythoncore.vcxproj] 生成失败。 D:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\VC\\VCTargets\\Microsoft.Cpp.WindowsSDK.targets (46,5): error MSB8036: 找不到 Windows SDK 版本10.0.22621.0。请安装所需的版本的 Windows SDK 或者在项目属性页中或通过右键 单击解决方案并选择“重定解决方案目标”来更改 SDK 版本 。 [D:\\Python-3.9.13\\Python-3.9.13\\PCbuild\\pythoncore.vcxproj] 0 个警告 1 个错误 按照它的提示，把该项目的Windows SDK版本改了之后就好了。 具体问题具体对待吧 参考 PCbuild目录下有readme.txt，里面的流程和我的流程是一样的 ","date":"2023-12-10","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8windows%E4%B8%8A%E7%BC%96%E8%AF%91python39%E6%BA%90%E4%BB%A3%E7%A0%81/:0:0","tags":null,"title":"如何在Windows上编译Python39源代码","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8windows%E4%B8%8A%E7%BC%96%E8%AF%91python39%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["随笔杂记"],"content":"蚌埠简介 蚌埠，车牌皖C，是一个在历史上非常灿烂的城市。很久之前，蚌埠仅仅是一个小渔村，清朝时期津浦铁路修经蚌埠，这是我国南北交通的大动脉，给蚌埠带来了繁荣的机会。除此之外，蚌埠还有千里淮河第一大港——蚌埠港，水路交通也十分发达。铁路和水路奠定了蚌埠重要的交通地位。交通有了，人也渐渐多起来，商业也逐渐发达，蚌埠是中国最早设立的地级市之一，民国时期的二马路商贩云集，热闹非凡，那时的蚌埠有“小上海”之称，1955 年建成蚌埠百货大楼，是当之无愧的皖北 CBD，吸引着无数周边城市的居民来这里购物，一直到今天都在经营。 除此之外，蚌埠的工业发达，至1980年代，蚌埠市的工业发展一直在安徽省名列前茅，并以综合型加工业基地著称。教育资源发达，有一本院校安徽财经大学和蚌埠医学院。医疗条件优渥，三甲医院有3个（数量不确定，但至少有 2 个）。市区不大，资源比较集中，行政区划基本没什么调整，三个县加上凤阳的认同度也很高。 蚌埠还有一个别称叫“珠城”，是因为过去的蚌埠盛产珍珠。在张公山公园里有珍珠女的美丽雕像，热门电视剧中的神话故事《长月烬明》就取材于此。 蚌埠还有很多有趣的历史，比如曾经被称作“匪城”，因为火车站贼太多了，而且蚌埠人性格偏北方，比较凶猛彪悍，常在街上喝酒闹事，所以外地人对蚌埠人的印象一直不好。不过那是很久之前的事情啦，现在的蚌埠可是全国文明城市，好人之城～ 然而，蚌埠没有赶上改革开放的好机会，在长三角也属于一个边缘的存在，近些年还一直在被合肥“吸血”，铁路和产业被抢走了很多，建设速度明显放缓，GDP增速连年在安徽省倒数。不过好处就是房价物价真的很低，只要家在这里，月薪 3k 你也能过的很舒服。 正当过去的辉煌基本已经消失的无影无踪的时候，蚌埠在网络上又焕发了新的活力，一句热梗“蚌埠住了”，让大家又开始关注蚌埠。2023 年五一期间，蚌埠接待游客高达417.6万人次，据我在蚌埠的朋友说，当时的蚌埠感觉要被挤爆了，上一次这么热闹可能还是太平天国运动……游客们来这里吃美食，赏美景，受到了当地人热情的接待，还有政府的大力支持。被捧为“网红城市”，不仅仅是因为一句热梗，而是源自丰厚的底蕴～ 其实不光是皖 C 蚌埠，具有类似命运的还有鲁 C 淄博，苏 C 徐州，都是好吃好玩，便宜舒适的城市。如果没有很多钱，不想去太远的地方，也不知道假期该怎么过，来这样的城市玩一玩还是很值得的。这可能是新时代下，皖 C、鲁 C 和苏 C 的新的历史使命吧。 ","date":"2023-10-08","objectID":"/posts/%E8%9A%8C%E5%9F%A0%E7%BE%8E%E9%A3%9F%E4%B9%8B%E6%97%85/:1:0","tags":null,"title":"蚌埠美食之旅","uri":"/posts/%E8%9A%8C%E5%9F%A0%E7%BE%8E%E9%A3%9F%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记"],"content":"美食图集 在现代，虽然蚌埠享誉盛名的已经不多了，但是“美食之城”的名号是当之无愧的。淮河流经蚌埠，使蚌埠横跨了中国的南方和北方，便捷的交通也使得天南地北的人们在这里相聚，文化不停的融合，其中也包括美食文化。所以，蚌埠即有南方的米食，也有北方的面食。蚌埠人也很“好吃”，研究出了麻辣烫、干扣面、小龙虾、冰酒酿、烧饼夹里脊等绝佳美食。 ","date":"2023-10-08","objectID":"/posts/%E8%9A%8C%E5%9F%A0%E7%BE%8E%E9%A3%9F%E4%B9%8B%E6%97%85/:2:0","tags":null,"title":"蚌埠美食之旅","uri":"/posts/%E8%9A%8C%E5%9F%A0%E7%BE%8E%E9%A3%9F%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记"],"content":"“地表最强游戏公司” 大名鼎鼎的侠盗猎车手系列(GTA, Grand Theft Auto)在游戏界应该无人不知，无人不晓，而由原班人马（R星，Rockstar Games）打造的荒野大镖客系列（RD, Red Dead）的知名度稍差一些。这可能是因为荒野大镖客系列目前仅有3 部作品（GTA系列有 5 部以上），并且游戏的背景发生在19、20 世纪的美国西部，相比之下，大家更喜欢在GTA的城市里抢银行～ 但是，荒野大镖客 2 保持了 R 星作品的一贯的高水准。依我看，这不仅是一部惊世骇俗的旷世之作，还是一部电影般精致的艺术品。无论是剧情、配乐、游戏性、画面还是优化，都达到了游戏界的顶级水准。R 星不愧是“地表最强游戏公司”。（在我心目中就是最强，但是最近在写论文，为了严谨，还是打个引号。） ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:1:0","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"游戏特色 GTA系列的所有游戏我都玩过（包括 2D 时代的版本），RDR 2 也刚刚剧情通关，并且制作东部传说背包，总结一下这两部作品的一些共同特色（主要是 RDR2 的特色）： 以犯罪为主题。GTA 是知名的打砸抢游戏，RDR 其实也差不多，在游戏中你可以随意对大部分npc烧杀抢夺，破坏交通、扰乱秩序，还可以在任务中抢劫银行、火车等等，可谓是恣意妄为、无恶不作。在游戏中能够实现在现实中无法完成的事情，让人非常过瘾。这是这两部游戏好玩的重要原因之一。 开放世界。我心目中开放世界游戏的最佳作品除了塞尔达传说之外，就是 GTA 和 RDR2。开放世界的好处是高自由度和高沉浸感，就像一本内涵丰富的名著一样，可以说“有一千个玩家，就有一千个 RDR2”。在游戏中，你能自由安排主线任务进行的顺序，还有很多支线任务分布在地图的各个角落等着你去探索。除此之外，你能和任何npc聊天，可以在水里钓鱼，可以在山野打猎、可以在营地闲聊、可以在酒馆赌博…不是所有人都能做好开放游戏，这不仅需要极佳的游戏设计，还需要有足够的技术实力来支撑，这样的游戏真是不可多得。 细节狂魔。R 星是知名的细节狂魔。RDR2有最真实的天气系统，还有最真实的物理水，还有 178 种动物。除此之外，每一个npc都有不同的对白，雪地走过会留下脚印，每个动物剥皮时都有动画等等。细节过多，我就不一一列举了，知乎和b站都有专门的展示。 电影感。先进的画质和高超的美术渲染使得 RDR2 拥有电影一般的品质。在地图的不同区域，有不同的风格，例如污浊的工业城市圣丹尼斯，懒洋洋的北方小镇瓦伦丁，南方种植园的红土地，西部广阔的沙漠戈壁，水草丰沃的翡翠牧场，凛冽寒冷的雪山，有热带气息的爪哇岛等等。许多剧情也设计了电影般的流程，可以理解为添加了交互的电影。 游戏难度。相比于黑魂、老头环这种吃技术的游戏，GTA 和 RDR2 都非常容易通关。当然了，如果是技术党也能打出高上限的操作。B 站上有中年人为了更了解自己的孩子去玩 RDR2，这其实是一个非常好的选择，因为即使是从没玩过游戏也能过关，重点在于体验剧情。 优化极好。GTA 和 RDR2 发售的时候的画面质量在当时都是业界翘楚，然而从来没有人评价他们是“显卡杀手”。相同的画质下，R 星的游戏比其他游戏能更流畅的运行。 价格良心。GTA史低 40 左右，而且线上模式一直更新。RDR2 史低80 多，也有线上模式。难怪销量登顶。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:2:0","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"故事背景 荒野大镖客：救赎 2 是荒野大镖客：救赎 1 的前传。前者的故事发生在19世纪末期，那时美国的西部大开发刚刚开始，掀起了淘金热，涌入了各种各样的人，包括英国人、法国人、意大利人、德国人甚至中国广东人（他们还会在街上跟你用广东话打招呼）。那时的美国西部，正逐渐从野蛮社会过渡为文明社会，野蛮的帮派势力和文明的政府势力矛盾不断。除此之外，游戏中还反映了妇女解放运动，南北战争，美国南部种植园奴役黑人等历史事件。如果懂一点美国历史的话，玩起来会非常有代入感。而故事本身正如其名，荒野大镖客 ：救赎2讲述的是一个关于救赎的故事。为了防止剧透，这里就不细说了。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:3:0","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"游戏人物 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:4:0","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"亚瑟 下面说一下我对游戏中几个主要人物的理解（涉及剧透）。亚瑟是游戏中的主要人物，他年少丧父丧母，被达奇收养，后被培养为一个技术高超的枪手。年少时的他天不怕地不怕，凭借一身本领逍遥法外，常常惹得一手血腥。后来得了肺结核（在过去是一种绝症），从此改变了思维方式，他不再相信达奇，或者说达奇暴露了本性，与大反派迈卡battle，最终在死亡中完成了自己的救赎。亚瑟的行为和结局很大程度上是由玩家的所作所为决定的，但是我觉得，官方更希望后期的亚瑟做个好人。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:4:1","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"约翰 在那个从野蛮社会过渡为文明时代中，最大的赢家就是约翰，因为他适应了时代的改变。他和亚瑟一样，也是幼年时被达奇收养，培养为一个枪手，跟着达奇四处劫掠。但是帮派解散之后，他买下了牧场，与妻子和孩子过上了文明安逸的生活。约翰对孩子的教育方式比较粗鲁，就像我们的爷爷奶奶一辈对待我们的爸爸妈妈一样。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:4:2","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"达奇 达奇是一个浪客，是帮派的首领，喜欢用武力解决问题。有点像中国侠客小说中劫富济贫，行侠仗义的侠客。他自己曾概括过他的一生：“我的这一辈子都在对抗变化”，确实是这样，对抗变化的结果最终就是一无所有。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:4:3","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记"],"content":"游玩过程 我是从 2023 年年初就开始玩，过了序章之后就不想玩了，感觉节奏太慢欣赏不来。然后今年开学之后又开始玩了起来，这下便一发不可收拾，一旦习惯了之后真的很上瘾，连续玩了一个月，把主线剧情通关了，还天天打猎，拿到了东部传说背包。很多人都说玩不下去，我建议这些人不妨静下心来，多花一些时间去感受这个游戏的魅力。就像读一本名著，你不能急功近利的去读，而是要慢慢品味。 ","date":"2023-09-19","objectID":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/:5:0","tags":null,"title":"艺术品般的游戏—《荒野大镖客救赎2》","uri":"/posts/%E8%89%BA%E6%9C%AF%E5%93%81%E8%88%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A22%E6%95%91%E8%B5%8E/"},{"categories":["随笔杂记","笔记"],"content":"2023年8月3日-5日，我来苏州啦。一提到苏州，我首先想到的是美丽的江南水乡，然后又想到了昆山的各种现代化工厂，科技与人文是如何交织在这一座城市的呢？我非常好奇，终于有机会能一探究竟！ 从蚌埠坐绿皮火车仅需不到5小时就能到达苏州站（票价62.5），苏州站位于苏州的中心区域——姑苏区（听名字就觉得好有诗意），很多园林、古城都位于此，所以出了苏州站就可以开始玩啦。 ","date":"2023-08-12","objectID":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/:0:0","tags":null,"title":"苏州印象","uri":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/"},{"categories":["随笔杂记","笔记"],"content":"苏州园林 中国古代的园林艺术在苏州体现的淋漓尽致，苏州有很多大大小小的园林都值得参观。冲着苏东坡的一句“到苏州不游「虎丘」乃憾事也！”，我来到了虎丘。这里翠树成荫可以乘凉，既能登上小桥听流水、又能闲庭兴步管古物，好有诗情画意。到处都是古色古香的建筑和流传千古历史典故，还有一座中国版“比萨斜塔”——云岩寺塔。旁边文创店里卖的贴纸好好看，是自己印的，我花了10块钱印了一张。 ","date":"2023-08-12","objectID":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/:1:0","tags":null,"title":"苏州印象","uri":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/"},{"categories":["随笔杂记","笔记"],"content":"苏州古城 苏州古城应该是中国保护的最好的古城吧，和其它城市所谓的古城不一样，苏州古城占地面积非常大，而且还有很多原住民在这里生活，除了一部分改造成了商业街外，其它的部分都保留了最原始的江南水乡特色。我骑着电动车在里面穿梭，真有一种穿越回东吴的感觉。 （我觉得视频的表现力更强，所以我在古城里拍摄了很多视频，但可惜的是我的博客对视频的支持并不好，所以在这里就不展示了） ","date":"2023-08-12","objectID":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/:2:0","tags":null,"title":"苏州印象","uri":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/"},{"categories":["随笔杂记","笔记"],"content":"苏州高新产业园 因为主城区被保护起来了，所以苏州的工业、高新产业都分布在各个县区，如苏州工业园区、苏州昆山市等。这一次我去的是以苏州北站为中心的高兴区，我是晚上去的，看到这里高楼林立，灯火璀璨，单看建筑，感觉非常繁华，就是缺少一些人气（江苏人没有夜生活）。在这里我还体验到了无人驾驶的出租车，科技感爆棚！昨天还穿越在古城，今天就来到了高科技的大都市，苏州真的牛！ ","date":"2023-08-12","objectID":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/:3:0","tags":null,"title":"苏州印象","uri":"/posts/%E8%8B%8F%E5%B7%9E%E5%8D%B0%E8%B1%A1/"},{"categories":["随笔杂记","笔记"],"content":"ChinaVis大会于2023年7月21日-24日在重庆召开，老师带着我们可视化组一起参会，近距离聆听各位大佬的报告让我大开眼界，同时公费旅游也真是爽歪歪～ ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:0:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"出发！ 第一次坐飞机，飞机型号是波音737-800，起飞的时候感觉好神奇，在空中的景色也非常美。 ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:1:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"重庆火锅 到达重庆的第一顿饭当然是重庆火锅，重庆人真的很爱吃火锅，街头开了无数的火锅店，味道肯定不会差！（就是辣的有点hold不住） ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:2:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"解放碑、魁星楼、美食街、洪崖洞 重庆最热门的景点集中在渝中区解放碑附近，所以我们首先去了解放碑，这里是重庆的CBD，非常繁华。 接着步行来到了魁星楼，你以为是1楼？其实是22楼！在这里能感受到8D的重庆。 然后肚子也饿了，我们就来到解放碑步行街找吃的，这里的小吃街规模非常大，小吃的味道以辣味为主（甚至有辣味冰淇淋）。 我吃了脑花、虾滑土豆等等，吃的太辣了，来一碗冰粉解解辣。 最后我们去了洪崖洞，最震撼的是嘉陵江大桥上的美景，能看到壮阔的河道与两岸的高楼，这种景象真是无与伦比，我没有在其它地方见到过。 美丽的景色让人陶醉，回去的路上我都还在回味，还拍了其它很多好看的照片，篇幅原因，这里就不一一列出了。 ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:3:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"ChinaVis大会 参加ChinaVis大会是本次差旅的重心，第一次参加这种学术会议，感觉非常高级。会议在沙坪坝区的重庆丽笙大酒店里的各个会议厅进行，见到了袁晓茹、陈为等大佬，但是不敢上去和他们交流。近距离的和来自五湖四海的大佬接触后，感觉自己离大佬们并没有那么遥远。我想，或许有一天我也能站在台上进行汇报我的工作，与其它大佬谈笑风生～ 报告很多，时间安排的很紧，2天我一直在听，屁股都坐出毛囊炎了。不过还好有茶歇和酒店自助餐，让美味给我力量。 ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:4:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"重庆·1949大剧院 回家前一晚是本次会议的特色节目——重庆·1949舞台剧。我们来到了一个大剧院，这个剧院有可以旋转的巨型舞台，第一次看到这种表演，感觉效果非常震撼。 ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:5:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["随笔杂记","笔记"],"content":"回家 回家啦，再见重庆，再见ChinaVis。先坐飞机去南京，再坐高铁回蚌埠，路费报销真爽。下一站，去徐州找彤彤！ ","date":"2023-07-31","objectID":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/:6:0","tags":null,"title":"ChinaVis重庆之旅","uri":"/posts/chinavis%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"},{"categories":["技能分享"],"content":"Keynote是苹果电脑自带的幻灯片制作和播放工具，类似于Windows上的PowerPoint（PPT）。 在通用性上，Keynote明显没有PPT那么普及。但是我认为Keynote在动画制作上完胜PPT，如果有足够需求，一定要试一试Keynote。Keynote内置了丰富的动画效果，多试几个，你一定会被惊艳到。 Keynote的操作逻辑几乎和PPT一致，甚至比PPT更加清晰，更加简单，会用PPT的人一定能很快上手Keynote。最近搞竞赛需要提交一个项目介绍视频，我只用了一个晚上就从零基础上手了Keynote，并且完成了一个很炫酷的动画视频。 如果你想进一步学习，B站上有一些很好的教程，也可以观看一下。 ","date":"2023-07-01","objectID":"/posts/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7-keynote/:0:0","tags":null,"title":"好用的动画制作工具-Keynote","uri":"/posts/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7-keynote/"},{"categories":["笔记"],"content":"前言 Flask是我最喜欢用的后端，以为它实在是太简单了，拿来做小型项目速度嗖嗖的。最近做比赛需要将后端通过socket连接到硬件设备，socket是有状态的，有连接数量的限制，所以要格外注意它的状态，Flask的一些特性会改变状态，如果不注意的话会导致很多bug，我踩了很多坑，在这里总结一下。 ","date":"2023-07-01","objectID":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/:1:0","tags":null,"title":"Flask的一些关于线程的特性","uri":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/"},{"categories":["笔记"],"content":"Flask的多线程 Flask会默认开启多线程的模式，多线程有什么用呢？试想一下，你写了两个路由，第一个需要执行10s，第二个执行0.1s。那么如果A用户访问第一个路由，等待过程中，B用户访问第二个路由的请求就会被阻塞，为了0.1s而等待了10s，效率非常低。如果使用多线程并发，就不会被阻塞，提高了系统的吞吐量。 注意并发不是并行，并发是有利于解决IO问题的。当时我的socket程序出了问题，尝试在多线程这里去解决，是走了歪路。 ","date":"2023-07-01","objectID":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/:2:0","tags":null,"title":"Flask的一些关于线程的特性","uri":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/"},{"categories":["笔记"],"content":"Debug模式可能会导致代码重复执行 在 Debug 模式下，Flask 中的 Werkzeug WSGI 套件默认会启动一个额外的进程来监控文件变化，当我们修改文件时，自动帮我们重启项目 取消自动重启 在 Debug 模式下，为了方便调试，Flask 提供了当文件变化的时候自动重启实例的功能。关闭这个功能就可以避免初始化两次的情况，但同时也丧失了自动重启的功能 app.run(debug=True, use_reloader=False) 详情请见：https://blog.csdn.net/qq_36078992/article/details/109559713 ","date":"2023-07-01","objectID":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/:3:0","tags":null,"title":"Flask的一些关于线程的特性","uri":"/posts/flask%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7/"},{"categories":["书影记录"],"content":"1984的作者是英国社会评论家乔治奥威尔，这个人比较擅长写政治寓言，他的另一本《动物农场》我也读过。英国人在社会形态这个问题上的思考真是比较深入，16世纪文艺复兴时期，英国的莫尔就提出了空想社会主义（马克思的科学社会主义的前身）；后来19世纪英国人率先搞起了资产阶级革命，号称“自由、平等”；到了20世纪，资本主义社会开始不那么美好了，我们都从历史课本上学到过，贫富差距过大，大量的工人像奴隶一样被对待，资本家只想着赚钱，生产过剩的牛奶宁肯倒掉也不愿给穷人喝…真可谓“朱门酒肉臭，路有冻死骨”。所以这个时候就出现了一个问题：资本主义是不是人类社会的最终形态？如果不是，那么什么社会才是呢？为了回答这个问题，有人又把当年莫儿提出的空想社会主义搬出来了，他们说乌托邦是存在的，只要精心设计，所有人服从安排，大家都能过上幸福平等的生活～西方所谓的乌托邦，其实跟《桃花源记》中的桃花源，《挪威的森林》中的疗养院等等比较像，就是一种公有制社会，大家一起劳作，共享劳动成果，所有资源统一分配，人人平等。这种社会你觉得可能存在吗，或者说，可能大范围的存在吗？不用你回答，就已经有人开始批评了，那就是反乌托邦三部曲——《我们》、《美丽新世界》、《1984》 《我们》 （没写完，以后再写～） ","date":"2023-05-02","objectID":"/posts/1984%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"《1984》读书笔记","uri":"/posts/1984%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["技能分享"],"content":"背景 最近跟几位同学做一个物联网竞赛，需要在web端直播摄像头内容。做视频直播是非常复杂的，但我们的要求很低，只要能在局域网内实现直播摄像头就可以了。安全性、性能、带宽什么的统统不考虑。 由于我们买的摄像头（海康）只能推rtsp流，没有任何一个web播放器能够支持这种格式，所以rtsp需要转码之后才能推流，比如转成rtmp或webRTC等其它流，这样就能在网页上播放了。GitHub上能找到很多转码推流的代码，但又因为海康还对这个协议做了魔改（主要是加密），所以这些代码也不支持！ 最后我看到一个很nice的方法：在后端（flask）使用cv库读取视频流，不断截取每一帧的图片，发送给前端。前端只需要用一个\u003cimg\u003e标签就能渲染这个直播视频啦。 ","date":"2023-04-22","objectID":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/:1:0","tags":null,"title":"Vue+flask实现播放任何视频源（包括rtsp摄像头）","uri":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/"},{"categories":["技能分享"],"content":"代码 Flask # camera = cv2.VideoCapture(0) # 笔记本自带摄像头，支持macbook camera = cv2.VideoCapture(os.path.join(app.config['UPLOAD_FOLDER'], 'zdws.mp4')) # 本地视频 @app.route('/api/video_feed') def video_feed(): def generate(): while True: # time.sleep(0.0) ret, frame = camera.read() if not ret: break _, jpeg = cv2.imencode('.jpg', frame) yield (b'--frame\\r\\n' b'Content-Type: image/jpeg\\r\\n\\r\\n' + jpeg.tobytes() + b'\\r\\n') return Response(generate(), mimetype='multipart/x-mixed-replace; boundary=frame') Vue \u003c!-- 摄像头画面展示区域 --\u003e \u003cimg style=\"width: 100%\" src=\"api/video_feed\" /\u003e ","date":"2023-04-22","objectID":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/:2:0","tags":null,"title":"Vue+flask实现播放任何视频源（包括rtsp摄像头）","uri":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/"},{"categories":["技能分享"],"content":"总结 这个方法能够以最低的成本解决问题，但是每次都传整张图片，对网络质量的，所以它只适用于网络质量较高的局域网。 视频本身就是由一帧一帧的图像组成的，但是我们传送数据时不可能原封不动地传送每一帧，因为它太大了。我们需要对视频进行压缩，去除帧与帧之间的冗余信息之后再发送到客户端，之后进行解压和渲染。压缩和解压是需要时间的，所以我们观看网络直播时肯定会有一定的延时。4G时代的网速依然是不够的，期待下一代网络技术的更新。 ","date":"2023-04-22","objectID":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/:3:0","tags":null,"title":"Vue+flask实现播放任何视频源（包括rtsp摄像头）","uri":"/posts/vue+flask%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BE%E4%BB%BB%E4%BD%95%E8%A7%86%E9%A2%91%E6%BA%90%E5%8C%85%E6%8B%ACrtsp%E6%91%84%E5%83%8F%E5%A4%B4/"},{"categories":["技能分享","笔记"],"content":"为什么要搭建一个ChatGPT镜像站？ 用过ChatGPT的都知道，刚开始速度嗖嗖的，甚至不用挂代理就能用。但是后来速度越来越慢，还开始封国内IP，封梯子IP，封国内账号，搞得没法再国内使用，但是已经形成了依赖，不用不行呀。天下苦ChatGPT久矣～ 自从api接口开放之后，操作空间就大了。我们可以搭建一个国内的镜像站给身边的人使用，搭建得好的话，可以加快访问速度，让国内的用户不挂梯子就能访问，非常便捷。 搭建的难点之一是如何提供一个稳定的海外网络环境，这里我表哥提供了一个非常nice的解决方法：使用cloudflare提供的免费云函数做代理，一天10w请求量完全够用。 搭建的过程并不难，但需要懂一点运维的知识（域名、Linux）。以下是我总结的搭建流程： ","date":"2023-04-12","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/:0:1","tags":null,"title":"如何搭建一个ChatGPT镜像站","uri":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["技能分享","笔记"],"content":"1. 搭建前后端 用这个开源项目：https://github.com/Chanzhaoyu/chatgpt-web ","date":"2023-04-12","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/:0:2","tags":null,"title":"如何搭建一个ChatGPT镜像站","uri":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["技能分享","笔记"],"content":"2. 使用cloudflare作为代理 cloudflare有一个workers，就是海外版的腾讯云函数，亲测访问速度是不错的，可以绑定自己的域名整一个 ","date":"2023-04-12","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/:0:3","tags":null,"title":"如何搭建一个ChatGPT镜像站","uri":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["技能分享","笔记"],"content":"3. 提速 近期openai对免费接口又做了限速，绑定信用卡之后能提速（像极了资本家的丑恶嘴脸）。国内的信用卡是不行的，必须得是国外的，而且梯子的IP还得和信用卡所在地的IP对应，自己弄很麻烦，建议找人帮忙弄。 说下我的经历，我花80块钱申请了一张depay的虚拟信用卡，然后花10块钱找人帮忙绑的卡。depay这家小公司的可信度是存疑的，更何况我还把卡的信息给了别人，所以这套流程是非常不安全的。这张卡我只敢存点小钱用于openai消费。这套流程可以走通，但是不建议。 ","date":"2023-04-12","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/:0:4","tags":null,"title":"如何搭建一个ChatGPT镜像站","uri":"/posts/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["技能分享"],"content":"需求 还是之前的那个需求，我需要做一个静态网页用于展示电子版教材。网页的布局非常重要，我需要一个顶部横向的导航栏，一个能够显示大纲的侧边栏，侧边栏的右边是教材的内容，听起来很简单，不是吗？但我需要再加一个条件，就是这些布局得是响应式的，要能够适应不同尺寸的屏幕，这可就不简单了。举个例子，当屏幕变窄时，顶部导航栏要将选项折叠，侧边栏也应当消失。 该需求跟这个网站刚好吻合，可以抄些代码： 由于我并没有系统的学过css，也根本不了解CSS中布局的知识，导致我在解决这个问题的时候手忙脚乱，折腾了好长时间也没能做出一个满意的页面。不过在折腾的过程中，我也在不断的积累，一步步的逼近真相，当我意识到可以把这个问题描述为CSS的布局问题时，我觉得我已经离最终解决问题非常接近了。 ","date":"2023-03-20","objectID":"/posts/css%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"CSS布局基础知识","uri":"/posts/css%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["技能分享"],"content":"CSS布局基础知识 这个教程讲的非常棒：https://zh.learnlayout.com 大致的布局方法是：顶部的导航栏使用fix布局，下面的侧边栏和教材主体使用flex布局，再用css的媒体，设置当屏幕宽度小于768px的时候设置display属性为none 简单的代码： \u003cdiv class=\"page-header\"\u003e1111111111111\u003c/div\u003e \u003cdiv class=\"page-body\"\u003e \u003cdiv class=\"docs-nav\"\u003e1111111\u003c/div\u003e \u003cdiv class=\"docs-body\"\u003eIntroduction Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview The OpenAI API can be applied to virtually any task that involves understanding or generating natural language, code, or images. We offer a spectrum of models with different levels of power suitable for different tasks, as well as the ability to fine-tune your own custom models. These models can be used for everything from content generation to semantic search and classification. Key concepts We recommend completing our quickstart tutorial to get acquainted with key concepts through a hands-on, interactive example. Overview ","date":"2023-03-20","objectID":"/posts/css%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"CSS布局基础知识","uri":"/posts/css%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["技能分享"],"content":"highlight.js 实现代码高亮是很容易的，有很多库都支持，比较有名的是highlightjs，它的使用方法是： 先引入css文件和js文件 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css\"\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js\"\u003e\u003c/script\u003e 再将你的代码用\u003ccode\u003e包裹 \u003ccode\u003e{{ 你的代码 }}\u003c/code\u003e 再调用hljs的高亮函数，它的原理是找到所有的code标签，然后通过操作DOM，给你的代码设置高亮样式。 \u003cscript\u003e hljs.initHighlightingOnLoad(); \u003c/script\u003e ","date":"2023-03-16","objectID":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/:1:0","tags":null,"title":"在vue中使用highlightjs-line-numbersjs实现代码高亮并且增加行号","uri":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/"},{"categories":["技能分享"],"content":"highlightjs-line-numbers.js hilightjs-line-numbers.js在highlight.js的基础上，给代码增加了行号，项目地址👇： https://github.com/wcoder/highlightjs-line-numbers.js 它的原理是将highlight.js渲染结构改装成\u003ctable\u003e，第一列是行号，第二列才是代码。这种思路是非常棒的！ 它的使用方法是在highlight.js的使用方法上加了两步： 除了引用highlight.js之外，还要引用highlightjs-line-numbers.js \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css\"\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"../src/highlightjs-line-numbers.js\"\u003e\u003c/script\u003e 将你的代码用\u003cpre\u003e和\u003ccode\u003e包裹 \u003cpre\u003e\u003ccode\u003e{{ 你的代码 }}\u003c/code\u003e\u003c/pre\u003e 调用 \u003cscript\u003e hljs.initHighlightingOnLoad(); hljs.initLineNumbersOnLoad({ // singleLine:true, // startFrom: 5, }); \u003c/script\u003e ","date":"2023-03-16","objectID":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/:2:0","tags":null,"title":"在vue中使用highlightjs-line-numbersjs实现代码高亮并且增加行号","uri":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/"},{"categories":["技能分享"],"content":"在vue中使用 奶奶的，在vue的组件中引用这个库，发现总是不能正确调用。我试了好久，终于找到了一个很nice的方法，就是直接在public下的index.html中引用，然后在组件中调用。 效果差强人意，但总算是把功能实现了 ","date":"2023-03-16","objectID":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/:3:0","tags":null,"title":"在vue中使用highlightjs-line-numbersjs实现代码高亮并且增加行号","uri":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/"},{"categories":["技能分享"],"content":"其它实现方法 在网上搜索，会发现还有另一种实现原理：使用vue.directive，自动在代码前面加一个\u003cul\u003e，显示行号；这种方法也可以实现，但是样式很难调整，容易出现行号错位。 ","date":"2023-03-16","objectID":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/:4:0","tags":null,"title":"在vue中使用highlightjs-line-numbersjs实现代码高亮并且增加行号","uri":"/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8hilightjs-line-numbers%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%B9%B6%E4%B8%94%E5%A2%9E%E5%8A%A0%E8%A1%8C%E5%8F%B7/"},{"categories":["随笔杂记"],"content":"3月7日是女神节，3月8日是妇女节，3月9日是我妈妈生日，所以这几天对她来说是很重要的日子。 我妈妈记我和我姐的生日记得很清楚，但自己的生日却很少提到，一辈子都没过过几次生日，更没收到过什么礼物。 前段时间我二姨在家族群里发了一束花的图片，说是她儿子送的，我心想：“切，不就是一束花嘛，我也能送”。所以我就送了一束花给妈妈。 我故意不告诉我妈我的计划，想给她一个惊喜。3月7日上午，我先问了我嫂子（她跟我妈在一个单位），确认我妈是在单位的，然后在美团上下单买了11朵康乃馨和1朵百合组成的花束，里面夹了一张卡片：“祝妈妈女神节快乐。——儿子”。没过多久我妈就顺利收到了这束花，我妈高兴坏了，全单位的人都知道了这件事，我妈觉得特别有面子。 我妈的一句：“好久没有这么开心了”，有点扎心。近几年我家的情况不算很好，我爸工作不顺利，我姐也不听话，我妈自己面临着退休的问题，生活中全是烦恼，确实好久都没这么开心了。现在我家的希望全在我一个人身上，我家能否过的蒸蒸日上，就看我毕业后的情况了。 收到花之后，我妈找同事拍了好几张照片，除了发给我，还发到家族群里。家族群里，大家一起祝福我妈，说我做得对，长大了、懂事了，我也很骄傲自豪。 这半年来，我感觉自己真的有质的变化，比以前更加有责任感，考虑事情更加周到，也更知道孝顺家人了，这可能就是成长吧。 ","date":"2023-03-09","objectID":"/posts/%E5%A6%88%E5%A6%88%E8%AF%B4%E5%A5%BD%E4%B9%85%E9%83%BD%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E4%BA%86/:0:0","tags":null,"title":"妈妈说：好久都没这么开心了","uri":"/posts/%E5%A6%88%E5%A6%88%E8%AF%B4%E5%A5%BD%E4%B9%85%E9%83%BD%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E4%BA%86/"},{"categories":["技能分享"],"content":"需求 老师写了一本c++教材，这本教材的一大特色就是构建了一个有关c++的知识点网络。只有在电子版教材中，这种知识点网络才能真正发挥它的作用（比如点击超链接跳转到指定知识点），而出版社（清华大学出版社）不提供电子版教材的支持，因此我们需要自己搭建一个电子版教材网站。 刚好老师为了给本科生考试，让学长搭建了一个HUSTOJ。老师想了一个主意，把HUSTOJ修改一下，增加一些页面，把教材放进去，这样既有题目又有教材，而且貌似很方便就能实现。 作为组里唯一一个既懂一点前端，又懂一点后端，还懂一点运维的学生，这个任务自然落在我头上了。 ","date":"2023-03-09","objectID":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/:1:0","tags":null,"title":"HUSTOJ前端源代码解析（PHP）","uri":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/"},{"categories":["技能分享"],"content":"分析 语言： HUSTOJ是用php写的，我没有学习过，但是看了一会源代码，就发现跟Django的模板语言比较像，还是能看得懂的，所以上手修改不成问题。 还有一个神器就是ChatGPT，看不懂的地方直接把代码复制进去，让它给我解释一下，它给出的的答案真的很让我满意。 思路： 首先把教材转成html文件，放在/home/judge/src/web目录下，这是网站的根目录。实操过程中，我新建了一个文件夹book，把.html改成.php后放了进去。 然后在根目录下新建一个book.php文件，无参数访问该文件为教材的目录；点击目录可跳转到教材的指定章节（带参数访问，如book.php?ch=2表示访问第二章）。 修改导航栏，增加一栏“教材”，然后指向book.php。 文件： 这里列出一些重要的的文件的作用，这个在官方文档中是没有给出来的，自己探索花了很长时间。 /home/judge/src/web：网站的根目录，下面的都是该目录下的文件： index.php：首页，主要引用了模板里的index.php，所以对首页的修改不要在这里改，而要在模板里的index.php里改。 book.php：我自己加的教材页面，无参数访问该文件为教材的目录；点击目录可跳转到教材的指定章节（带参数访问，如book.php?ch=2表示访问第二章）。 book/*.php：教材的静态html代码 /template/syzoj使用了syzoj主题目录文件，里面放的都是模板，下面的都是该目录下的文件： book_contents.php：我自己创建的目录。 index.php：模板里的首页，在这里我又加了一个目录，引用book_contents.php。 hedaer.php：修改导航栏在这里改，不要在nav.php改！ ","date":"2023-03-09","objectID":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/:2:0","tags":null,"title":"HUSTOJ前端源代码解析（PHP）","uri":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/"},{"categories":["技能分享"],"content":"工具 工欲善其事，必先利其器，有哪些好用的工具可以用呢 Tabby：很好用的跨平台开源终端软件，帮你管理密钥，sftp也很好用。 macOS的文件搜索：不仅能搜文件名，还能搜文件内容，速度贼快（因为有建立索引），Windows可用everything这个软件 VS code的ssh remote插件：可以直接用VS code修改服务器上的代码，比vim舒服多了。 ","date":"2023-03-09","objectID":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/:3:0","tags":null,"title":"HUSTOJ前端源代码解析（PHP）","uri":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/"},{"categories":["技能分享"],"content":"部署 nginx+php的部署起来稍微有些麻烦，但是由于php的逻辑代码是嵌入在html文档中的（不像vue，每次修改完源码都需要编译），所以部署完再修改代码是很方便的。 ","date":"2023-03-09","objectID":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/:4:0","tags":null,"title":"HUSTOJ前端源代码解析（PHP）","uri":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/"},{"categories":["技能分享"],"content":"总结 又解锁了一个新的技术栈php，qwq。 ","date":"2023-03-09","objectID":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/:5:0","tags":null,"title":"HUSTOJ前端源代码解析（PHP）","uri":"/posts/hustoj%E5%89%8D%E7%AB%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90php/"},{"categories":["技能分享"],"content":"需求 语雀本身是用web端访问的，按理来说，导出为html文件应该是最接近原生文档的观感的，但是却不支持，反倒是可以导出为pdf、markdown、word等格式。 可以用爬虫把文档给爬下来，但是我很不喜欢用爬虫，因为大型网站总是会使用各种反爬技术，这些阻拦会使我爬出的结果不够优雅。 如果优雅的解决这个问题呢，思路是利用语雀的API，很轻松就能获取一个文档的各种信息（作者、页面的markdown内容，html内容等）。很多个人博客可以跟语雀相关联，也是通过API实现的。这是一个可玩性很高的功能。 ","date":"2023-03-09","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/:1:0","tags":null,"title":"如何将语雀文档导出为html（使用语雀API）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/"},{"categories":["技能分享"],"content":"解决方法 在语雀的账户设置-\u003eToken里新建一个token 问ChatGPT，如何使用语雀API拿到一个页面的内容（它真的能给你一个可运行的代码！） 这里记录一下我修改后，适用于我自己的需求的代码： import requests import os # 设置API访问令牌 token = 'YOUR_ACCESS_TOKEN' # 设置API请求URL url = 'https://www.yuque.com/api/v2/repos/upcxailixin/ua125n/docs/' chapters = ['rqwsfpzkh97ivvxm','hl788mwbbw2d82is','hcxgg7','afrstd','iz3dks','khnvy8','bhbw2z','qvzagc','dky80n','zzw6o7','qrg1f2eds2h8talq'] # 设置API请求头 headers = { 'User-Agent': 'Mozilla/5.0', 'X-Auth-Token': token } for i in range(len(chapters)): # 发送API请求 response = requests.get(os.path.join(url,chapters[i]), headers=headers) # 解析API响应 if response.status_code == 200: doc = response.json() # print(doc['data']['body_html']) print('标题:', doc['data']['title']) # print('内容:', doc['body']) else: print('请求失败:', response.status_code) # 写入 with open(f\"/Users/sunbaile/临时/语雀2html/{doc['data']['title'].replace('/','')}.html\",'w') as f: f.write(doc['data']['body_html']) # import json # with open('./raw.json','w',encoding='utf8') as f: # f.write(json.dumps(doc,ensure_ascii=False)) 这时候html文档已经搞出来了，但是文档中的图片、以及svg公式都指向语雀的cdn，这是不能直接放在服务器上的，因为会有跨域的问题。所以我们得再写个脚本把文档中的img都下载到本地的images目录下（这一步的代码仍然是通过问ChatGPT获得的），下面记录适用于我自己的需求的修改后的代码： import os import requests from bs4 import BeautifulSoup from urllib.parse import urljoin import time basepath = '/Users/sunbaile/临时/语雀2html/下载图片' # # 创建存储图片的文件夹 # if not os.path.exists('/Users/sunbaile/临时/语雀2html/下载图片/images'): # os.makedirs('/Users/sunbaile/临时/语雀2html/下载图片/images') for filename in os.listdir(basepath): if filename.endswith('.php'): # 读取HTML文件 with open(os.path.join(basepath,filename), 'r') as f: html = f.read() # 解析HTML文件 soup = BeautifulSoup(html, 'html.parser') # 获取所有图片链接 img_tags = soup.find_all('img') img_urls = [img['src'] for img in img_tags] print(filename) print(img_urls) # 下载图片 for url in img_urls: # img_url = urljoin('http://example.com', url) # 根据相对链接生成绝对链接 img_url = url response = requests.get(img_url) filename = os.path.join(os.path.join(basepath,'images'), os.path.basename(url)) # 使用图片链接的文件名作为下载的文件名 with open(filename, 'wb') as f: f.write(response.content) time.sleep(1) 最后，要将html文档中img标签的src内容修改一下，把绝对路径改成相对路径 from bs4 import BeautifulSoup import os basepath = '/Users/sunbaile/临时/语雀2html/下载图片' for fname in os.listdir(basepath): if fname.endswith('.php'): # 读取HTML文件 with open(os.path.join(basepath,fname), 'r') as f: html = f.read() # 解析HTML文件 soup = BeautifulSoup(html, 'html.parser') # 获取所有图片标签 img_tags = soup.find_all('img') # 替换所有图片链接 for img_tag in img_tags: img_url = img_tag['src'] if img_url.startswith('http'): # 判断是否为绝对链接 filename = os.path.basename(img_url) # 获取文件名 img_tag['src'] = 'book/images/{}'.format(filename) # 将修改后的HTML文档写回原始文件 with open(os.path.join(basepath,fname), 'w') as f: f.write(soup.prettify()) ","date":"2023-03-09","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/:2:0","tags":null,"title":"如何将语雀文档导出为html（使用语雀API）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/"},{"categories":["技能分享"],"content":"总结 ChatGPT真好用～以后就不用自己思考代码框架了，直接面向ChatGPT编程。 ","date":"2023-03-09","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/:3:0","tags":null,"title":"如何将语雀文档导出为html（使用语雀API）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BAhtml%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80api/"},{"categories":["随笔杂记","技能分享"],"content":"从Windows换到Mac，获得了很多东西： 又轻又薄，续航还长，背出去上课自习非常方便（隔壁背着游戏本的同学都羡慕哭了）； 一块素质极高的屏幕，看文献非常舒服； 优秀的软件生态，在Mac上可以使用很多优质软件，比如Mac版清爽的qq； 优秀的硬件生态，与我的iPhone互联，同步记事本，提醒事项等。 m1芯片的兼容性也是不错的，我上绝大对数课所用到的环境，Mac都能搞定，除了计算机图形学。计算机图形学所用到的openGL是我目前使用m芯片的mac时遇到的最难受的环境问题了： 首先，Mac是能够安装OpenGL的，也能跑一些简单的代码，但是一旦遇上shader（着色器），就会出现各种各样的问题。其次，我们上这门课，老师给的demo全是基于微软家的visual studio平台，这在我的Mac上根本无法运行，所以我没法完成作业！ 促使我组装一台新电脑的“最后一根稻草”，就是计算机图形学。除此之外还有其它原因，比如说我有工位了、我想打游戏了、我要发奖学金了、正好赶上双十一等等。 所以，赶在计算机图形学结课之前，我真的花3000块钱组装了一台高性价比，能打游戏，小巧玲珑，颜值又高的电脑。顺利完成了计算机图形学的作业之后，假期我还把它拎回了家～ ","date":"2023-03-01","objectID":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/:0:0","tags":null,"title":"组装一台新的电脑","uri":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/"},{"categories":["随笔杂记","技能分享"],"content":"配置 配置主要参考的是喵喵折的一期节目，他们的节目做的太好了，不仅给出了这么好的方案，还手把手教你怎么装机，下面是我的配置单： cpu i3 121000f 663 显卡 rx6500xt 800（二手） 电源 金河田 500w 218 主板 铭瑄 h610m 475 内存 金百达银爵16g 256 硬盘 西数sn570 500g 278 机箱 k88青春版 166 散热 乔思伯 66 网卡 COMFAST AX200 127 总计 3049 ","date":"2023-03-01","objectID":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/:1:0","tags":null,"title":"组装一台新的电脑","uri":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/"},{"categories":["随笔杂记","技能分享"],"content":"图片 ","date":"2023-03-01","objectID":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/:2:0","tags":null,"title":"组装一台新的电脑","uri":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/"},{"categories":["随笔杂记","技能分享"],"content":"感受 4个月过去了，我依然觉得台新电脑配得非常好，这就是为什么时隔4个月我仍然要补一篇blog。自己攒机的过程也是非常有趣的，这段时间我每天都密切关注各大平台的配件价格，以便宜的价格买到我想要的东西，非常开心。 ","date":"2023-03-01","objectID":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/:3:0","tags":null,"title":"组装一台新的电脑","uri":"/posts/%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91/"},{"categories":["随笔杂记"],"content":"明天就要返校啦，下学期课贼少（一周只有4节），而且疫情结束，再也不会被封在学校啦，可以多跟彤彤出去玩了，所以还是蛮期待的！回顾这个寒假，总体上来说是平平淡淡，但是有很多事情还是很值得记录的。整个假期可以分为三个阶段，年前、年中、年后，这三个阶段我所做的事情和心态是截然不同的。 ","date":"2023-02-15","objectID":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"2023年寒假总结","uri":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"年前 刚从学校回来，我还保持着在学校的那种不愿浪费时间，努力工作学习的状态。每天早上都能起床，吃个早饭，读读论文，做做工作。这个时候跟家庭的活动和跟朋友的活动也是比较多的，比如说跟彤彤聊聊天，看看电影，电视剧，跟刘鑫宇去网吧玩，跟家人去逛超市，家庭聚餐、逛街等等。而且，在学校因为太长时间没玩游戏憋坏了的我也开始疯狂的玩游戏，也很花时间。因此，年前的我，日子过得是蛮充实的。 ","date":"2023-02-15","objectID":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"2023年寒假总结","uri":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"年中 过年了，导师给咱放假了，那还学个屁的习，开启堕落模式～晚上玩到凌晨2点，早上睡到10点才醒，然后还不愿意起床，在床上磨蹭到12点，起来吃午饭，然后下午继续玩。过年期间的家庭活动就更多了，除了多次家庭聚餐之外，表哥从上海回来，还带我们去洗浴，逛街，玩主机游戏。家里会有亲戚来打麻将，热热闹闹的。晚上也不无聊，可以跟我妈一起去看电影…这一段日子过得也是很充实的。 ","date":"2023-02-15","objectID":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"2023年寒假总结","uri":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"年后 年后，大人们都去上班了，表哥也走了。家里面突然冷清了下来，与年中时的热闹氛围形成了强烈的反差。我也突然意识到漫长的寒假即将结束了，我该结束醉生梦死的生活，开始面对现实了。现实是：我不仅又要开组会，读论文，帮导师干活，而且还要迎接开学三场考试。此外，我自己定的寒假任务：写一篇专利，还没有开始做。这个任务从上学期拖到了寒假开始，又从寒假开始拖到了1月份，又从1月份拖到了年后（2月份）…这种突如其来的认清现实带来的压力，让我一下子很难接受，所以我emo了几天。 年后的我在家里实在学不下去，这几天我出门转了转，突然灵感大发，想到我可以去自习室学习哇！在手机上一搜，竟然在我家对面就有一个“积木自习室”，离我家非常近，它距离我家的距离甚至比从寝室到图书馆还近，真是妙哉～去了之后，果然没让我失望，有空调、热水、Wi-Fi，更重要的是，它提供了一个非常好的学习氛围，坐在里面，就像是坐在了大学图书馆里，周围人都在学习，我也能够静下心来。发现这个自习室，是我寒假的一个重要转折点，从第一次进入自习室的那天开始，我就不emo了，每天下午2点左右去自习，还可以在路上买杯奶茶，学3-4个小时，再回家吃晚饭，走在回家的路上，心里非常轻松愉快。在开学前的15天里，我几乎每天都去自习室，终于完成了我的寒假任务。 另外，还有一件重要的事，就是我对我家人的情感变化（尤其是对我妈妈）。在过去的日子里，我还很幼稚，不太把妈妈为我做的点滴小事放在眼里，也不太乐意主动跟她聊天。但是近几年，我越来越发现妈妈的伟大之处，开始理解体谅妈妈，主动帮妈妈做事，跟她聊天。有一次跟彤彤聊天，她说她的妈妈要走了，可能得明年才能相见，哭的不行，我很心疼她。我想到我的妈妈，也是如此爱我，而我也即将离开她，真是有点舍不得，忍不住我的眼泪也掉了下来。为了不让她操心，我得证明自己已经长大了，所以我和妈妈去徐州旅行，我认真做了攻略，合理安排了行程，确实让妈妈看到了我的厉害之处，我觉得这很有意义。 这张图是我在年初六（上班的前一天）用奖学金请我妈妈，我表哥，我姥姥和姥爷一起去泡温泉时拍摄的，他们都很开心，能为家里人做一些事情，我也很开心。 另外，值得一提的是，我的车技也在这个假期得到了极大的锻炼。以前只走过去奶奶家的路，现在可以去任何地方。以前家里人开车去别的地方都是我爸来开，现在都是我来开。我自己也单独开过两次。但目前还是比较缺乏经验的，有待加强。 ","date":"2023-02-15","objectID":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/:3:0","tags":null,"title":"2023年寒假总结","uri":"/posts/2023%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"徐州对我来说，是一个很神奇的城市，它是彤彤签约企业所在的城市，是包邮区里唯一一个有暖气的城市，是历史课本中的兵家必争之地，是全国重要的铁路枢纽，是离我家只有36分钟高铁的城市，是我多次上学路过的城市… 寒假漫长，特别想出去旅一次游。过年期间，表哥从上海回来，我们商量了几个方案都不太可行，主要是因为大家的旅游需求都不一样，很难调和。眼看着寒假快过去了，我心里觉得有一点遗憾，我没有说出来，可是我的心思被我妈看穿了，她听同事和朋友说起徐州有一些好玩的地方，所以坚持要在寒假结束之前跟我到徐州玩一次。我当然很开心，做了比较充分的攻略，跟我妈在徐州度过了愉快的一天。 游玩路线 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:0","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["随笔杂记"],"content":"坐地铁 早上7:40坐高铁，只花了36分钟就到了徐州东站，然后坐地铁，我妈妈几乎是第一次坐地铁，地铁又快又便宜，很让我妈妈喜欢，所以地铁站就算第一个景点啦。 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:1","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["随笔杂记"],"content":"龟山汉墓 坐地铁1号线到徐医附院下车，再坐公交车直接到达龟山汉墓，此时刚好是早上10:00。 为什么要来龟山汉墓呢？因为我爸来过两次徐州，说龟山汉墓很有意思，我在网上搜攻略的时候，也看到有徐州本地人说：“徐州没什么好玩的地方，就龟山汉墓值得一去”。 我和我妈发挥人少的优势，默默跟在一个旅行团后面听别人的导游的讲解，这样就不用自己花钱请讲解啦。个人感觉，墓室不是很大，里面好看的的东西不多。但是圣旨博物馆里收藏了很多圣旨，还有科举试卷，小抄等等文物，非常有意思，眼前一亮！ 另外，在坐公交车的过程中，我和我妈一直在观察徐州这个城市的外貌。我的感觉就是，像，真是太像皖北了！如果把徐州的老城区跟蚌埠的老城区接到一块，我根本看不出区别。但是徐州的交通更发达，城市更整洁，在路上跟当地人聊天时也发现，徐州的居民素质也高一些。 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:2","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["随笔杂记"],"content":"云龙湖 龟山汉墓游览完之后，正好到中午12:00了，我们打车去云龙湖边上的一家叫“粤季”的餐厅吃饭，饱餐一顿后，步行漫游云龙湖畔。 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:3","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["随笔杂记"],"content":"徐州乐园 散步是有目的的散步，我们穿过云龙湖，一边欣赏着美景，一边走到了徐州欢乐世界，也叫徐州乐园。这是一个“紧凑型”的游乐场，徐州乐园里有游乐场该有的一切，比如过山车（3个）、海盗船、旋转飞椅、跳楼机、鬼屋、漂流、4D影院、杂技表演、碰碰车等等，but，它的面积确实不大，游乐设施之间是比较紧凑的。夜场票价100，下午3点就可以进去游玩，几乎能把所有的项目游玩一遍，还是很划算的（最划算的还要属那次跟彤彤去的泰安太阳部落，门票只要29.9，简直太划算啦）。 我妈妈胆子还挺大的，啥都敢玩，除了最“恐怖”的那个过山车，我们几乎全都玩了一遍，很爽。 徐州乐园旁边还有一个杉杉奥特莱斯，里面有全国几乎所有的服装品牌的店铺，折扣力度一般都在5折、6折的样子（因为货物往往都是旧款、断码、清仓），在那里疯狂购物也是很不错的。但是我们啥也没买，转了一圈就去徐州乐园玩啦。 最后我们坐公交车+地铁又回到了徐州东站，坐高铁回家啦，这次旅行两个人大概花费750元。虽然在路上花了很多时间，但是我们母子两边聊天边坐车，既能省钱又能说很多话，一点也不无聊，真是充实的一天。 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:4","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["随笔杂记"],"content":"最开心的事 最后最开心的事情，是我问妈妈今天玩的满意吗，妈妈说她很满意，而且没想到会这么满意，她原本以为会跟我在路上吵架，但是一路上都很和谐。说我有成年人的样子，像我表哥一样，会做攻略，查资料，订票，点餐，导航，很有责任感，还细心体贴，很会照顾人，成熟了，长大了。 妈妈年龄比较大了，明年就退休了，我能在她退休之前，证明自己已经不是孩子，而是成长为一个大人，让妈妈放心，真是太开心了。 ","date":"2023-02-13","objectID":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/:0:5","tags":null,"title":"跟妈妈一起的徐州一日游","uri":"/posts/%E8%B7%9F%E5%A6%88%E5%A6%88%E4%B8%80%E8%B5%B7%E7%9A%84%E5%BE%90%E5%B7%9E%E4%B8%80%E6%97%A5%E6%B8%B8/"},{"categories":["技能分享","笔记"],"content":"前言 老师给了一个任务，仿照jupyter notebook中可以动态添加、删除的cell，用c++的qt做一个类似的界面。具体来说，一个cell中有一个输入框，一个输出框，还有四个按钮，分别是运行、添加、删除、清空。此外，为了突出正在编辑的cell，要实现点击到cell的空白部分时，将背景颜色高亮。实现的效果如下：虽然我压根就没学过qt，但是刚接到任务时，我觉得这玩意逻辑挺简单的，应该不难实现。但是后来发现我错了，要做这么一个小东西要用到很多知识。 ","date":"2023-02-02","objectID":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/:1:0","tags":null,"title":"Qt动态添加和删除布局（仿jupyter）","uri":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/"},{"categories":["技能分享","笔记"],"content":"实现 因为ui比较简单，所以用代码实现，没用designer。先整一个自定义组件叫cell（也就是一个类，继承自QWidget），cell里面包含了两个输入框和四个按钮，在public中定义这四个按钮，保证这四个按钮可以被外部访问到。 用一个QList把所有的cell存储起来，界面和这个QList一一对应，这样，添加和删除cell，就等于添加和删除QList。写一个渲染函数render，把已有的布局全删了，根据QList重新构建，每次进行一个操作之后都重新render。 怎么连接信号与槽呢？因为要实现的逻辑与全局有关，不能在cell内写connect，只能在外面的mainwindow里写，这就是为什么要保证四个按钮可以被外部访问到。因为按钮长得都一模一样，所以要区分按下的是哪一个cell的按钮，所以得用到传参的信号与槽，参数就是按钮的索引位置。这些都是写在render函数里的，别忘了在connect前先disconnect一下，清除原有的信号与槽。 最后，怎么点击背景改变颜色呢？先用groupbox把四个按钮和两个输入输出框包裹起来，然后想到直接用groupbox的click信号，但是我发现这玩意不生效（毕竟人家本来的作用不是拿来干这个的），所以换一种方法。我定义了一个myGroupBox类，继承自QGroupBox，然后重写了它的QMousePressEvent函数，点击就能发出bg_clicked信号（自定义信号），这个信号被mainwindow接收到就可以控制它的stylesheet啦。 代码： cell.h #ifndef CELL_H #define CELL_H #include \u003cQWidget\u003e#include \u003cQTextEdit\u003e#include \u003cQPushButton\u003e#include \u003cQVBoxLayout\u003e#include \u003cQTextEdit\u003e#include \"mygroupbox.h\" class Cell: public QWidget { Q_OBJECT public: explicit Cell(QWidget *parent = nullptr); ~Cell(); // 一些控件 myGroupBox *m_box; QPushButton *m_btnAdd; QPushButton *m_btnDelete; QPushButton *m_btnClear; QPushButton *m_btnRun; QTextEdit *m_input; QTextEdit *m_output; // 属性：是否被选中 bool is_clicked=false; private: void init(); // 初始化内部控件 signals: public slots: }; #endif // CELL_H mygroupbox.h #ifndef MYGROUPBOX_H #define MYGROUPBOX_H #include \u003cQGroupBox\u003e class myGroupBox : public QGroupBox { Q_OBJECT public: explicit myGroupBox(QWidget *parent = nullptr); // 鼠标点击 virtual void mousePressEvent(QMouseEvent *ev); signals: void bg_clicked(); // 背景（groupbox）被点击后变色 public slots: }; #endif // MYGROUPBOX_H mainwindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u003cQMainWindow\u003e#include \u003cQTextEdit\u003e#include \u003cQPushButton\u003e#include \u003cQVBoxLayout\u003e#include \u003cQTextEdit\u003e#include \"mygroupbox.h\"#include \"cell.h\" QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); // 设置一个主widget QWidget *widget; // 设置一个mainLayout QVBoxLayout *mainLayout; // 绘制 void render(); // 递归的清除所有布局以及控件 void deleteAllitemsOfLayout(QLayout* layout); // 设置一个list存储所有的cell QList\u003cCell*\u003e cells; // 按钮所触发的函数，传入按钮相对应的索引 void on_btnAdd_clicked(int i); void on_btnDelete_clicked(int i); void on_btnClear_clicked(int i); void on_btnRun_clicked(int i); void on_box_clicked(int i); private slots: private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H cell.cpp #include \"cell.h\"#include \u003cQDebug\u003e Cell::Cell(QWidget *parent) : QWidget(parent) { init(); } Cell::~Cell() { } void Cell::init() { m_box = new myGroupBox; QHBoxLayout *hlay = new QHBoxLayout; QVBoxLayout *vlay1 = new QVBoxLayout; QVBoxLayout *vlay2 = new QVBoxLayout; // 把按钮、文本框等控件添加进布局 m_input = new QTextEdit; m_output = new QTextEdit; m_output-\u003esetStyleSheet(\"background-color:rgb(230,230,230);\"); m_output-\u003esetReadOnly(true); vlay2-\u003eaddWidget(m_input); vlay2-\u003eaddWidget(m_output); m_btnRun = new QPushButton(\"Run\", this); vlay1-\u003eaddWidget(m_btnRun); m_btnAdd = new QPushButton(\"Add\", this); vlay1-\u003eaddWidget(m_btnAdd); m_btnDelete = new QPushButton(\"Delete\"); vlay1-\u003eaddWidget(m_btnDelete); m_btnClear = new QPushButton(\"Clear\"); vlay1-\u003eaddWidget(m_btnClear); vlay1-\u003eaddStretch(); hlay-\u003eaddLayout(vlay1); hlay-\u003eaddLayout(vlay2); m_box-\u003esetLayout(hlay); QHBoxLayout *out = new QHBoxLayout; out-\u003eaddWidget(m_box); setLayout(out); } mygroupbox.cpp #include \"mygroupbox.h\"#include \u003cQDebug\u003e myGroupBox::myGroupBox(QWidget *parent) : QGroupBox(parent) { } void myGroupBox::mousePressEvent(QMouseEvent *ev) { // // 新思路：发一个信号发出去给mainwindow，然后在外面处理这个 // qDebug() \u003c\u003c \"背景被点击\"; emit this-\u003ebg_clicked(); } mainwindow.cpp MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u003esetupUi(this); // 设置centralwidget和mainlayout widget = new QWidget(); this-\u003esetCentralWidget(widget); mainLayout = new QVBoxLayout; widget-\u003esetLayout(mainLayout); // 初始化一个界面 on_btnAdd_clicked(0); render(); } MainWindow::~MainWindow() { delete ui; } void MainWindow::render() { // 清除所有布局 deleteAllitemsOfLayout(mainLayout); delete m","date":"2023-02-02","objectID":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/:2:0","tags":null,"title":"Qt动态添加和删除布局（仿jupyter）","uri":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/"},{"categories":["技能分享","笔记"],"content":"学习历程 虽然我没有学过qt，但是我学过vue，前端的框架在设计理念上都是相通的，所以我对qt中的一些概念能很快理解，比如信号与槽，控件等等。但是web前端的编程环境跟c++大不一样，所以适应起来还是需要一段时间的。 刚开始学一门技术，并且立刻拿它来做项目确实是很头疼的，但这也是最锻炼人的方式。恭喜我，在堕落的寒假的尾声终于又点亮了一颗技能树。 ","date":"2023-02-02","objectID":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/:3:0","tags":null,"title":"Qt动态添加和删除布局（仿jupyter）","uri":"/posts/qt%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%83%E5%B1%80%E4%BB%BFjupyter/"},{"categories":["书影记录"],"content":"我是一个肠胃经常出毛病的人。最近闲逛豆瓣，发现了这本评分高达8.9分的有关肠子的医学科普书籍，赶紧买回来看看它能对我有什么帮助，看完之后果然受益匪浅。作者是德国的一名医学博士，她用幽默风趣的语言向我们揭示了很多藏在科研论文中的关于肠胃的知识，这些知识能够很好的指引我们的饮食、排泄、作息等日常生活习惯，而且通俗易懂，只需一点高中生物知识就能理解（吹个牛逼，我高中成绩最好的就是生物，经常考第一）。生活离不开吃喝拉撒，而肠子是跟吃喝拉撒最相关的器官，如果你在吃饭上有顾忌，在拉屎上有困难，那么推荐你阅读这本书。除此之外，肠子还有很多你意想不到的“小心思”，如果你没有前面说的这些毛病，但是有一颗探索人体奥秘的好奇心的话，也可以阅读一下这本书。 ","date":"2023-01-28","objectID":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"《肠子的小心思》——读书笔记","uri":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"迷人的肠子 本书一共有三章，第一章“迷人的肠子”主要介绍的是消化系统的基本结构和基本功能。作者先从“排便便”这一受人关注的话题切入，从上到下介绍了消化系统中的唾液腺、扁桃体、食道、胃囊、小肠、大肠等器官。另外，还介绍了我们的肠子需要什么样的食物，和高中生物课本上的知识大相径庭，不过作者的描述更容易让人接受。最后有一节“便便外刊”，教你通过便便的成分、颜色和形状来判断你的健康状态，配有简明有趣的插图，非常有意思。 读完第一章我就开始对这本书着迷了，知道了很多的“冷知识”，比如，马桶的设计是不利于人类排便的，当然你可以稍微改变一下马桶上的坐姿，让排便更通畅一些；为什么要早晚刷牙？跟唾液有关，唾液有杀菌的作用，晚上睡觉时口腔会停止分泌唾液，所以睡觉前要刷个牙保持口腔清洁，不让细菌滋生，早上也要刷个牙把晚上滋生的细菌给清理掉；因为胃是不对称的，开口向右，所以向左侧躺更有利于打嗝；随着年龄的增长，大多数人的生产乳糖酶的基因会慢慢失活，所以就变得喝牛奶不能消化啦… ","date":"2023-01-28","objectID":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《肠子的小心思》——读书笔记","uri":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"有趣的肠神经 说到神经，我们第一想到的是大脑中有复杂的神经系统，但其实肠子的神经系统也不比大脑简单，甚至被称作“肠脑”，很多时候它不受大脑控制，而是自己默默的维持着秩序，让消化等活动井井有条地进行。作者借一块蛋糕，介绍了它被你吃下去所在身体里经历的奇妙旅程，首先眼睛看到蛋糕，鼻子闻到气味，刺激视觉神经和嗅觉神经，信号传达到唾液腺分析唾液，然后经过口腔咀嚼、咽喉吞咽、食道蠕动、胃的搅拌、小肠、大肠的消化，最后肛门拉出。简单吃个蛋糕，竟然如此复杂，需要神经系统通力配合才能完成消化，我们的身体是如此精妙的机器，让人惊叹。 ","date":"2023-01-28","objectID":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《肠子的小心思》——读书笔记","uri":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"喧闹的微生物世界 这一章的篇幅最多，内容也最新颖，完全超出了我的认知。以前，肠道里的微生物总被忽视，没人觉得它们很重要。但其实肠道里的微生物总重量能够达到2千克，跟消化能力、免疫系统、胃口、体重甚至心情等要素都息息相关。现在，肠道微生物已经成了热门话题，比如在新冠期间很流行的益生菌，你知道它是怎么发挥作用的吗？吃下去的益生菌大部分都会死掉，但是死掉的益生菌并不是被浪费了，细菌的尸体也可以激发免疫系统工作，剩下来活的细菌可以参与到消化的进程中；还有近几年，抑郁症也被证明和肠道菌群有一定的关联…作者在这一章中介绍了很多最新的科研成果，极大满足了我的求知欲。 最后，我觉得像我这种20多岁的大学生，早已对行星宇宙，物理化学等经典科普题材不感兴趣，我想阅读的科普书籍的范围其实是很窄的。这本医学科普图书恰好戳中了我的点，希望以后能读到更多这样的书籍。 ","date":"2023-01-28","objectID":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"《肠子的小心思》——读书笔记","uri":"/posts/%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["技能分享"],"content":"对于游戏玩家来说，键盘鼠标可能不是最好的控制器（网游，fps玩家除外），拥有一个手柄，会让游戏体验更加舒适。尤其是对于一些需要慢慢品玩的3A大作，或者是需要各种微操的赛车游戏，手柄的体验绝对秒杀键鼠。 ","date":"2023-01-15","objectID":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/:0:0","tags":null,"title":"致动o手柄对比xbox原装手柄使用体验分享","uri":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"Xbox手柄 Xbox手柄是PC平台上最经典的手柄，由微软生产。它兼容性游戏多，做工精良，还很好看，但是价格昂贵（官方410），还很难买到。 甚至有人说，购买一个xbox手柄最好的方式，就是去买一个Xbox series 游戏主机，到手之后把附赠的Xbox手柄拿出来，然后把游戏主机放到闲鱼上卖掉… 我是找准了机会在拼多多百亿补贴买的白色Xbox手柄，350入手，感觉非常香。这个活动不常有，可以多关注一下，肯定能以便宜价格买到的，尽量选择百亿补贴，以防买到假货。拼多多，我心目中永远滴神！ 真的有必要花费那么高的成本买一个这样的手柄嘛？并不是，其实我们大多消费者都是一时心血来潮的“体验用户”罢了。我们需要的是一个既廉价又好买的平替手柄。 ","date":"2023-01-15","objectID":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/:1:0","tags":null,"title":"致动o手柄对比xbox原装手柄使用体验分享","uri":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"致动o手柄 致动o是来自广东的一个小厂（众所周知，广东的电子厂遍地开花，全国电子信息服务业数一数二），他们复刻了xbox精英手柄，仅需200块钱，你就能买到的xbox精英手柄的平替！ 看一眼淘宝，你会发现50块钱以内的比比皆是，它们看起来也有模有样，很像那么一回事，同样是仿xbox手柄，怎么价格也差别这么大呢？它们之间的区别是什么呢？ 差别主要在于遥感和板机这两个键的性能，好一点的手柄，稍微推动遥感也是能被检测到的，而便宜手柄肯定是无法做到精确识别，在游戏中自然也无法做到微操；同理，扳机键也存在同样的精确度问题，好的手柄，扳机键是线性的，你按下去多少，就能感应到多少，而垃圾手柄，可能只有当你完全按下去时才能有反馈。想象一下，当你玩赛车游戏时，车速很快，这时候是不能转大方向的，得轻轻调整方向，转弯时也不能把油门踩到底，否则车辆会失控，这就得用到遥感和板机键的精确控制了，如果是垃圾手柄，根本无从谈起，还不如用键盘玩。 那么200元的致动o跟400元的xbox手柄有什么区别呢？我觉得主要是手感。致动o毕竟是性价比选手，注重性能而不是外表，拿到手里塑料感严重，扳机键感觉很虚，按键也不牢固，轻轻摸会感觉晃晃的。而原版的Xbox手柄拿在手里沉甸甸的，表面也有不同的磨砂材质，摸起来很舒服，按键的质感也不错。 ","date":"2023-01-15","objectID":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/:2:0","tags":null,"title":"致动o手柄对比xbox原装手柄使用体验分享","uri":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"痛点and痒点 我们经常会有消费的冲动，有的时候消费是值得的，但有时是让人后悔的。如何判断一次消费是值得的还是令人后悔的呢？我的判断标准是，如果消费是为了解决“痛点”，那么这次消费就是值得的，如果是为了解决“痒点”，那么可能就并不那么值得。 比如，为了玩赛车游戏，我必须要一个手柄，因为用键盘根本没法玩，所以我的第一选择是购买一个致动o手柄，解决了我只能用键盘玩赛车游戏的痛点，这次消费是值得的。但是用了一段时间之后，我总是觉得这个手柄不舒服，看到拼多多上有便宜的Xbox手柄，心里痒痒的，于是下单买回家，它解决了我觉得致动o手柄手感不好的痒点。我也不是游戏的狂热爱好者，玩了一段时间就不怎么感兴趣了，现在两个手柄都不怎么用。第二次消费就比较令我后悔了。 ","date":"2023-01-15","objectID":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/:3:0","tags":null,"title":"致动o手柄对比xbox原装手柄使用体验分享","uri":"/posts/%E8%87%B4%E5%8A%A8o%E6%89%8B%E6%9F%84%E5%AF%B9%E6%AF%94xbox%E5%8E%9F%E8%A3%85%E6%89%8B%E6%9F%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享","笔记"],"content":"近期想跟女朋友一起异地看电影，试了几种方式都不够优雅， 方式一：用chrome插件，双方同时打开一个视频源，然后通过这个插件能控制两个人的进度条保持一致。 缺点：因为有的视频源是收费的，两个人想一起看得交两份钱，还有的不支持网页播放（需要下载软件），所以这种方式灵活性很差，不好用。 方式二：用腾讯会议，两个人进同一个会议，开共享屏幕看视频。 缺点：因为是共享屏幕所以啥都能看，灵活性比较高，腾讯会议的实时性也比较高，但是流畅度低，看起视频来卡卡的，不好用。 方式三：开直播，直播是拿延迟换流畅度（延迟大概也就5秒左右），需要一台设备串流。 缺点：成本比较高。 以上几种方式都试过了，我觉得还是第三种比较好。一番搜索之后，发现了一个好用的开源软件叫livego，在朋友的一个腾讯云的服务器闲置上跑个直播，跟对象两人一起啥都能看，效果还不错。服务器系统是ubuntu，配置2核4G，实测够用。 ","date":"2023-01-01","objectID":"/posts/livego%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%9B%B4%E6%92%AD%E4%B8%B2%E6%B5%81%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"LiveGo——小而美的直播串流软件","uri":"/posts/livego%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%9B%B4%E6%92%AD%E4%B8%B2%E6%B5%81%E8%BD%AF%E4%BB%B6/"},{"categories":["技能分享","笔记"],"content":"LiveGo LiveGo是go语言写的一个软件，go语言的性能确实不错，我的博客用的框架是Hugo，也是go语言写的，速度确实很快。 安装起来也很方便，用docker的话只需要打一行命令： docker run -p 1935:1935 -p 7001:7001 -p 7002:7002 -p 8090:8090 -d gwuhaolin/livego 我总觉得docker性能不好，所以选择在本地安装，也很方便： 下载源码：git clone https://github.com/gwuhaolin/livego.git 进入文件夹后编译：go build or make build 跑起来之后，打http://localhost:8090/control/get?room=movie获取直播key 用obs（一个常用的直播软件）通过rmtp协议串流：rtmp://localhost:1935/{appname}/{channelkey}，appname默认是live 最后拉取直播，支持三种协议，一般用第二种flv即可 RTMP:rtmp://localhost:1935/{appname}/movie FLV:http://127.0.0.1:7001/{appname}/movie.flv HLS:http://127.0.0.1:7002/{appname}/movie.m3u8 windows可以用potplayer这个软件，其它设备可以用VLC（安卓，iOS，macOS） 项目地址：https://github.com/gwuhaolin/livego 官方文档：https://github.com/gwuhaolin/livego/blob/master/README_cn.md 像LiveGo这种软件真的是太棒了，几行代码就能用起来，不整那些复杂的东西，我很喜欢。 ","date":"2023-01-01","objectID":"/posts/livego%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%9B%B4%E6%92%AD%E4%B8%B2%E6%B5%81%E8%BD%AF%E4%BB%B6/:1:0","tags":null,"title":"LiveGo——小而美的直播串流软件","uri":"/posts/livego%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%9B%B4%E6%92%AD%E4%B8%B2%E6%B5%81%E8%BD%AF%E4%BB%B6/"},{"categories":["笔记","技能分享"],"content":"前言 我是跟着李沐的动手学深度学习v2视频学习深度学习的，光看不做假把式，所以在学习完第七章-现代卷积神经网络之后，参加了一次李沐发布的Kaggle竞赛。自己动手，从组织数据集开始，到训练，再到推理，把整个流程走了一遍，收获颇丰，感觉学到了很多东西，（完整代码：https://www.kaggle.com/code/leyoubaloy/competition-classifyleaves/notebook?scriptVersionId=114980812 ）现总结如下： ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:1:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"组织数据集 我相信很多小伙伴跟我一样，学习深度学习不是为了在这个领域做出创新性的贡献，而是仅仅会用它解决实际问题即可，但是在用别人的模型的过程中卡在了第一步——组织数据集。 先搞明白两个类，Dataset和Dataloader（需要有python面向对象知识基础）。Dataset是对整体数据集的一个抽象，它定义了数据的读取方法等属性，而Dataloader是用于训练和、评估和测试的迭代器，它能控制batch_size，shuffle等属性。Dataset代码的编写是很灵活的，针对不同的数据集有不同的写法，想要会用深度学习一定先学会写Dataset类。 class MyDataset(Dataset): def __init__(self, mode='train', valid_ratio=0.2, resize_height=256, resize_width=256): self.resize_height = resize_height self.resize_width = resize_width self.mode = mode if mode == 'train': data = pd.read_csv('/kaggle/input/classify-leaves/train.csv') self.train_len = int(data.shape[0] * (1 - valid_ratio)) self.train_image = np.asarray(data.loc[:self.train_len, 'image']) self.train_label = np.asarray(data.loc[:self.train_len, 'label']) self.image_arr = self.train_image self.label_arr = self.train_label elif mode == 'valid': data = pd.read_csv('/kaggle/input/classify-leaves/train.csv') self.train_len = int(data.shape[0] * (1 - valid_ratio)) self.valid_image = np.asarray(data.loc[self.train_len:, 'image']) self.valid_label = np.asarray(data.loc[self.train_len:, 'label']) self.image_arr = self.valid_image self.label_arr = self.valid_label elif mode == 'test': data = pd.read_csv('/kaggle/input/classify-leaves/test.csv') self.test_image = np.asarray(data.loc[:, 'image']) self.image_arr = self.test_image self._len = len(self.image_arr) def __getitem__(self, index): image_path = self.image_arr[index] image = Image.open(os.path.join('/kaggle/input/classify-leaves/', image_path)) if self.mode == 'train': transform = transforms.Compose([transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) else: transform = transforms.Compose([transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) image = transform(image) if self.mode == 'test': return image label = self.label_arr[index] label_num = label2num[label] return image, label_num def __len__(self): return self._len 这次竞赛等数据集是一个树叶图像分类数据集，在我的代码中定义了一个MyDataset类，在init方法中，我用pandas读取图像列表为一个Series。在getitem方法中，传入一个参数index，用Image库读取第index个图像，再用transforms对它做一些预处理（包括resize、裁切、转化成tensor、标准化），使其能够被输入到神经网络。 有三种模式，训练、验证和测试。训练和验证模式的数据是从训练集中划分的，是有标签的，而测试集是没有标签的，需要我们训练完推理得到答案，上传答案。在训练模式下，随机裁切图像即可，但是验证和测试模式最好用中心裁切，使待测试的图像尽可能完整的输入到网络中。训练和验证模式的getitem返回的是tensor和label，而测试模式返回的是tensor。 然后就可以实例化，得到train_dataset，valid_dataset，test_dataset。 train_dataset = MyDataset(mode='train') valid_dataset = MyDataset(mode='valid') test_dataset = MyDataset(mode='test') 最后用dataset生成dataloader，这个就很简单了，传几个参数就可以。batch_size是每个batch的训练样本个数，shuffle是否打乱数据，num_worker是读取数据所用的进程数，因为读取数据通常比较花时间，所以有时候需要用不止一个进程来读取数据。对于训练和验证数据，需要打乱，对于测试数据就不需要打乱了。 train_loader = DataLoader(train_dataset, batch_size=10, shuffle=True, num_workers=2) valid_loader = DataLoader(valid_dataset, batch_size=10, shuffle=True, num_workers=2) test_loader = DataLoader(test_dataset, batch_size=10, shuffle=False, num_workers=2) ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:2:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"label的格式 这个问题困扰了我比较久。这是一个176类的分类问题，模型输出的是有176个元素的向量，可以理解为向量中的每个元素表示该样本属于此类的概率，所以我们选择最大的元素值的index即可，也就是argmax。 按理来说，我们的label的格式也应该是one-hot编码，然鹅这样太占内存了，所以，在pytorch中规定我们的label格式是index，即只有一个数字，表示所属类的下标。 现实中的label往往是字符串，要先对其编码，用两个字典就可以了，num2label和label2num。 labels = train['label'].unique() label2num = {} for idx,label in enumerate(labels): label2num[label] = idx print('label2num:',label2num) num2label = { a : b for b, a in label2num.items()} print('num2label:',num2label) ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:3:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"网络调整 网络需要改的地方是输入size和输出size，在d2l第七章的教学中mnist数据集是黑白的，输入只有一个通道，而我们的数据集是彩色的，有三个通道，所以要改一下。mnist的输出是10类，而我们的输出有176类，这个也要改一下。 ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:4:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"损失函数 训练过程是一个epoch一个epoch进行训练的，所以网络的输入输出都是是若干个样本，损失也是若干个样本一起计算一次损失。分类任务常用的是交叉熵损失，即nn.CronssEntropyLoss()，它的输入是y_hat和y_real，注意哟这两个格式是不一样的，y_hat是模型的输出，类似于one-hot编码，而y_real只是一个index。 关于这个损失函数，最好理解一下，上百度搜一下它是怎么计算类别的损失的。 ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:5:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"如何推理 验证精度和推理测试集的时候都需要用到推理，推理也是分epoch进行的，推理时要把自动梯度关掉。在训练的代码中有一个细节是torch.max()函数不仅返回的是最大值，还有它的index，我们所需要的主要是它的index。 net.load_state_dict(torch.load('./net.ckpt')) net.eval() test_labels = [] with torch.no_grad(): for test_x in test_loader: test_x = test_x.to(device) output = net(test_x) for label in torch.max(output, 1)[1]: # print('label:',) test_labels.append(num2label[label.item()]) ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:6:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["笔记","技能分享"],"content":"总结 很多看似简单的代码其实包含了很多理论知识，可以花个一两天的时间把这些代码好好理一理，观察一下每行代码的输出形式是什么样的。 ","date":"2022-12-29","objectID":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/:7:0","tags":null,"title":"Kaggle图像分类竞赛实战总结详细代码解读","uri":"/posts/kaggle%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%AB%9E%E8%B5%9B%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"categories":["随笔杂记"],"content":"最近放假回家，配了台新电脑，开始疯狂玩游戏。作为8年LOL老玩家，虽然玩到现在还是菜得一逼，但是有一颗从青铜打上白银的“野心”。最近出了一个新道具叫“心之钢”，这个道具不仅让肉装英雄变得更肉了，而且还让肉装英雄有了输出，我很喜欢玩。刚开始打排位，我玩石头人辅助，好不夸张的说，我把把carry，线上我又臭又硬，打不动还跑得快。打团的时候我更猛，一个势不可挡直接创到对面后排，再配合心之钢，平A就能秒adc，我再接一个地震碎片，敌人减速我加速，从人堆里都能跑出来。万军丛中取敌将首级，玩的比赵信还赵信。即使是逆风局，队友也积极沟通，做视野，发信号，打龙，打团，每个人都在发挥积极的游戏作用。刚开始打了15把，赢了10吧，轻轻松松从黑铁打到黄铜二。 打到黄铜二之后，这匹配机制就不对劲了，排到的队友一个比一个极品。中路一塔永远先被破，上路无限被丹砂，打野从来不控龙，不会抓人就算了，还老是送人头带节奏。前期对线路路崩，中期打团总缺人，莫名其妙在野区被包杀，后期…根本打不到后期。菜就算了，心态还不好。打十分钟就吵着要投降，还动不动就喜欢骂人。有一局刚进游戏辅助和中单就骂起来了，直接挂机送人头。还有一局我玩石头人买错了辅助装，没买圣物之盾，买的是多兰盾，那个adc打了一会儿发现了，开始不停的点我的装备，不停的用脏话骂我，还骂我们家的打野和上单，本来这一把玩的很顺风的，我5杠2，下路都打出很大的优势了，结果搞得我都不想玩了，他也开始挂机，最后大家都不想玩了，全票通过投降。还有一次我玩中单，对面亚索去下路支援，我发了中路miss和下路危险的信号，结果下路还是被双杀，辅助怪我没来支援，我真服了，给他发信号看不见，真是眼瞎。所以，最近几天玩排位老是输，而且输的很快，沟通？不存在的，唯一的沟通就辱骂和挂机，一点游戏体验都没有，我愿称之为“黄铜陷阱”。 最近几天打了15把，输了10把，心真的累。假期回家一共打了30把，刚好一半赢一半输，被这匹配机制拿捏的死死的。不想玩了，真的很没意思，我承认我输了，输给了这恶心的匹配机制。 （突然想起来配新电脑这件事竟然没发个blog说一下，可能是当时那段时间太忙了） 最近发现了有很多优秀的3a大作可以玩，比如地平线5、死亡搁浅、古墓丽影等等，真不如把时间花在这些游戏上面。 ","date":"2022-12-26","objectID":"/posts/%E5%86%8D%E8%A7%81%E6%81%B6%E5%BF%83%E7%9A%84%E6%8E%92%E4%BD%8D%E8%B5%9B/:0:0","tags":null,"title":"再见，恶心的排位赛","uri":"/posts/%E5%86%8D%E8%A7%81%E6%81%B6%E5%BF%83%E7%9A%84%E6%8E%92%E4%BD%8D%E8%B5%9B/"},{"categories":["随笔杂记"],"content":"又一个寒假开始啦，期盼了一学期，终于回家啦。随着年级的增长，每次回家的感觉都略有不同，环境还是那个环境，但是心态，跟最开始大不相同。 第一次放假回家的时候，是非常期待的。毕竟是第一次在外地呆那么久，感觉自己变化了许多，也遇到很多新鲜事，想和家里人分享，父母也从来没有跟我分别过那么长时间，对我十分想念。更重要的是，大学的寒假没有作业，也没有辅导班，父母也不再管我了，自己想做什么就做什么！我感受到了前所未有的自由，包括人身的自由，经济的自由，心灵的自由～ 宽裕的时间，宽松的氛围，让我拓宽了乐趣。除了整天躺在床上刷手机之外，我学会了跟刘鑫宇去网吧打游戏，学会了不想下楼的时候点外卖，学会了跟一帮朋友唱K，吃饭…几个假期下来都是这样，真是好不快活！我不禁感叹道：“长大之后的世界真美妙！” 现在回家就不一样了，带着作业，带着科研任务，还带着对未来的焦虑。别问我为什么这么容易焦虑，人跟人是不一样的。有的人有一口饭吃就不会想下一顿吃什么，而有的人专业第一还担心报不上研。一个人是否焦虑，跟一个人现在拥有的无关，而跟他想拥有的有很大关系。可惜的是，人拥有的越多，他想要的也就越多，即欲望会贪婪的扩大。 目前的我，取得了一些小小的成就，欲望和野心也进一步扩大了，我想发论文，想博览群书，想处理好人际关系，想练出好身体，但是这些事谈何容易，能力真的难以达到。这些作为对美好生活的期望，当然是可以的，但是如果成为了我的负担，就是跌入了欲望和贪婪的陷阱里了。 说了这么多，意思就是目标很宏大，但是目标并不是一定需要完成的，它更多时候只是指明一个方向，就像灯塔一样，你知道你要去那，但不一定到达。 这个假期的目标如下： 继续读论文，推进科研工作。 提升前端技能和深度学习技能。 读书1～2本。 写一篇专利。 ","date":"2022-12-17","objectID":"/posts/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87%E5%BC%80%E5%A7%8B%E5%95%A6/:0:0","tags":null,"title":"又一个寒假开始啦","uri":"/posts/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87%E5%BC%80%E5%A7%8B%E5%95%A6/"},{"categories":["随笔杂记"],"content":"我对我自己真的很栓Q，时隔一年半，我又一次因为急性肠胃炎被送进了校医院！ ","date":"2022-12-09","objectID":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/:0:0","tags":null,"title":"我再也不胡吃海喝了😭😭😭","uri":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/"},{"categories":["随笔杂记"],"content":"历史总是惊人的巧合 历史总是惊人的巧合，这一次我同样是在夜晚乱吃东西（这次吃的是便利店卖的寿司、橙子和其它小零食），当天晚上无事发生，然而第二天早上右疼又吐。苏文把我送到了校医院，先在屁股上来一针止痛针，再挂水。川桑和良王也来看我，最后彤彤陪挂完了水。 ","date":"2022-12-09","objectID":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/:0:1","tags":null,"title":"我再也不胡吃海喝了😭😭😭","uri":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/"},{"categories":["随笔杂记"],"content":"一定一定不要再胡吃海喝了 事不过三，我发毒誓，我以后再也不在睡觉前乱吃东西了。给自己定一个规矩，晚上10点过后，最多吃一点水果。每次都中招，太 tm 傻逼了。 ","date":"2022-12-09","objectID":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/:0:2","tags":null,"title":"我再也不胡吃海喝了😭😭😭","uri":"/posts/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%83%A1%E5%90%83%E6%B5%B7%E5%96%9D%E4%BA%86/"},{"categories":["随笔杂记"],"content":"这几周，可能是我大学三年最忙碌的时候。 这学期有20个学分，其中18个学分都在前半学期。 第11周之前，每周课程大于等于10节，平均每天3节课，作为本科生，我得天天上课，周末还有计组和计网实验，上课和做实验占据了我大部分的时间和精力。 除此之外还有很多的杂事（杂事仅代表事情比较小，比较琐碎，不代表我认为这些事不重要），比如说核酸（基本两天一次）、班会、医保、导师安排的任务、奖学金、竞赛等等… 作为本研班的学生，大三已经相当于是研0了，每周要参加两次组会，每次都能开到10点钟，有时还要准备论文汇报。 作为男朋友，我每天还花很长时间和彤彤相处（这倒是件比较幸福的事情）。 过去的一周，有一些课，终于结课了。但随之而来的就是两个大作业、两个考试、两个报告…都集中在这两周了。上课只会让我烦躁，而大作业，则会让我焦虑。 因为听课效率极低，作业也不好好写，复习比较痛苦，大作业我也不想摆烂，于是努力认真做，报告的内容也很多，需要花很多时间。考试前那一周，每天复习到晚上11点（我没有熬夜复习的习惯）。做大作业的那一周，每天晚上搞到12点，因为害怕成果出不来，焦虑让我失眠严重，睡眠严重不足，每天的精神都很差。除此之外，我还要处理好人际关系，尤其是跟导师的关系和跟彤彤的关系，所以这段时间真是忙碌到了emo，然后又边emo边做事，直到从emo中解脱出来。 还好有彤彤一直陪着我，陪我自习，陪我吃饭，还去机房给我送吃的。现在这段日子总算过去了，考试和大作业都取得了非常不错的结果（专业数一数二），心情终于愉悦起来了。回想起刚刚度过的那段煎熬时光，有一个感受：就是当我遇到困难时，当我焦虑，emo时，不要把重心放在品味你的负面情绪，而是要放在努力做事情上（哪怕事情进展缓慢），另外，即使是在最忙碌的时候，也要有休息的时间，稍微娱乐一下，打会游戏，读会书，睡个懒觉，也是完全可以接受的。 生活其实不会push我，真正push我的其实是我自己，是我那颗渴望上进的内心，我应该为此感到欣慰而不是徒增压力。 ","date":"2022-11-20","objectID":"/posts/%E8%BF%87%E5%8E%BB%E7%9A%84%E5%87%A0%E5%91%A8%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E7%86%AC%E8%BF%87%E6%9D%A5%E7%9A%84/:0:0","tags":null,"title":"过去的几周我是怎么熬过来的","uri":"/posts/%E8%BF%87%E5%8E%BB%E7%9A%84%E5%87%A0%E5%91%A8%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E7%86%AC%E8%BF%87%E6%9D%A5%E7%9A%84/"},{"categories":["广告"],"content":"蓝易云好不好? 蓝易云怎么样？香港服务器推荐。 蓝易云，2020年成立的国人商家，是成都天上云网络科技有限公司旗下的云计算服务品牌，专注为个人开发者用户、中小型企业用户、大型企业用户提供云服务器、云虚拟主机、云数据库、云存储、域名、CDN、SSL证书、服务器租用托管等服务。 该商家主要定位建站服务器，特点是香港CN2网络，国内速度优秀，区域内支持VPC内网互联、快照、备份等功能。 蓝易云持有IDC、ISP、CDN许可证，为正规商家。 机器特点：去程联通电信走CN2 回程 移动+联通+电信+教育网+广电+长城五网CN2-延迟超低！ CPU性能强劲，4核编译安装宝塔环境CPU只能占用到70%左右！ CPU单核GEEKBENCH跑分能到849分左右，lemonbench跑到能到942分左右。【优秀性能】 商家最新高防SCDN信息 蓝易云SCDN官网：点击前往 无感防护 告别传统HTTP验证【可防HTTPS】 AI 智能全方位立体防护 专业算法 国内外加速 支持定制 【防住付款】 【现提供1元公益防护】接一切扛不住的攻击定制防护 以下是蓝易云SCDN控制台展示： 使用蓝易云SCDN网站的打开速度测试结果： 以下是蓝易云香港服务器质量介绍： 香港九龙机房-双向CN2vCPU：1核E5-2678 v3 @ 2.50GHz内存：1G DDR4 硬盘：30G系统盘+20G数据盘流量：500G流量/月（10Mbps端口）价格：29元/月购买：点击直达 香港九龙机房-双向CN2vCPU：1核E5-2678 v3 @ 2.50GHz内存：2G DDR4 硬盘：30G系统盘+20G数据盘带宽：500G流量/月（10Mbps端口）价格：39元/月购买：点击直达 香港九龙机房-双向CN2 vCPU：2核E5-2678 v3 @ 2.50GHz内存：4G DDR4 硬盘：30G系统盘+20G数据盘带宽：500G流量/月（10Mbps端口）价格：59元/月购买：点击直达 香港九龙机房-双向CN2vCPU：4核E5-2678 v3 @ 2.50GHz内存：8G DDR4 硬盘：30G系统盘+20G数据盘带宽：500G流量/月（10Mbps端口）价格：109元/月购买：点击直达 如需更多规格配置，可以根据需要自行选择，价格以商家官网为准。 1H1G规格配置实际测试： 延迟 ：延迟方面可以看到基本都在40MS以内，直连线路延迟低。 性能 ：IO方面速度还不错，网络为上下对等10M CN2网络. CPU方面据商家描速进行了优化，GEEKBENCH跑分能到849分左右，lemonbench跑到能到942分左右。 根据商家描述香港云增强型性能 超越标准型30%，经实测达到商家描述！ 线路 ：使用测试脚本进行回程路由测试，可以看到三网回程均为CN2网络【其他线路的忘记截屏了，大家可以自测】 增强型网络得到进一步优化，相比标准型低10%左右延迟。 网络抖动 网络带宽充足，抖动较小，基本不丢包： ","date":"2022-11-17","objectID":"/posts/%E8%93%9D%E6%98%93%E4%BA%91%E5%95%86%E5%AE%B6%E6%9C%BA%E5%99%A8%E4%B8%BB%E6%89%93%E7%A8%B3%E5%AE%9A%E5%BB%BA%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A829%E5%85%83-%E6%9C%881%E6%A0%B8-1g%E5%86%85%E5%AD%98-10mbps-%E9%A6%99%E6%B8%AFcn2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E5%A4%A7%E5%B8%A6%E5%AE%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E8%8D%90/:0:0","tags":null,"title":"蓝易云商家机器主打稳定建站服务器！29元 月1核 1G内存 10Mbps 香港CN2服务器、香港大带宽服务器、香港服务器推荐","uri":"/posts/%E8%93%9D%E6%98%93%E4%BA%91%E5%95%86%E5%AE%B6%E6%9C%BA%E5%99%A8%E4%B8%BB%E6%89%93%E7%A8%B3%E5%AE%9A%E5%BB%BA%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A829%E5%85%83-%E6%9C%881%E6%A0%B8-1g%E5%86%85%E5%AD%98-10mbps-%E9%A6%99%E6%B8%AFcn2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E5%A4%A7%E5%B8%A6%E5%AE%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E8%8D%90/"},{"categories":["广告"],"content":"总结 机器线路稳定，适合稳定建站，大带宽类型适合突发带宽访问用户，比较不错，CPU性能足够。 商家售后服务态度也不错，这点不错，值得推荐！ ","date":"2022-11-17","objectID":"/posts/%E8%93%9D%E6%98%93%E4%BA%91%E5%95%86%E5%AE%B6%E6%9C%BA%E5%99%A8%E4%B8%BB%E6%89%93%E7%A8%B3%E5%AE%9A%E5%BB%BA%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A829%E5%85%83-%E6%9C%881%E6%A0%B8-1g%E5%86%85%E5%AD%98-10mbps-%E9%A6%99%E6%B8%AFcn2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E5%A4%A7%E5%B8%A6%E5%AE%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E8%8D%90/:1:0","tags":null,"title":"蓝易云商家机器主打稳定建站服务器！29元 月1核 1G内存 10Mbps 香港CN2服务器、香港大带宽服务器、香港服务器推荐","uri":"/posts/%E8%93%9D%E6%98%93%E4%BA%91%E5%95%86%E5%AE%B6%E6%9C%BA%E5%99%A8%E4%B8%BB%E6%89%93%E7%A8%B3%E5%AE%9A%E5%BB%BA%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A829%E5%85%83-%E6%9C%881%E6%A0%B8-1g%E5%86%85%E5%AD%98-10mbps-%E9%A6%99%E6%B8%AFcn2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E5%A4%A7%E5%B8%A6%E5%AE%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E8%8D%90/"},{"categories":["书影记录"],"content":"《悉达多》 故事的背景发生在印度，青年的悉达多是婆罗门（印度种姓制度中的最高等级）之子，他幼年时勤勉好学，聪慧非凡，长相俊美。大家都爱戴他，认为他一定能成为伟大的贤士。可是悉达多自己却感受不到喜悦，他认为父辈传授给他的知识还远远不够，无法盛满精神的容器，满足他焦渴的灵魂。他感到非常迷茫，灵魂悸动不安，他不了解自己的真正的内心是什么，所以渴望追寻自己的内心的阿特曼，即找寻真正的自我。 一日，三位沙门（即苦行僧）路过城邑。悉达多感受到了来自内心的阿特曼的召唤，决心同这三位沙门一道苦修。夜里，他久久站立着，以刚毅的身躯默然反抗父亲的不愿。悉达多的父亲从透光的窗户看到他一动不动的身影，一切的不舍、担忧都隐在了漆黑的夜里。他终于松了口。悉达多从此踏上了沙门的苦修路，与他同行的还有他儿时的好友乔文达，他是悉达多忠实的追随者。 悉达多从沙门处学会了斋戒、思索与等待。他不再视饥饿、疼痛为摧毁身体的利器，只是日复一日思考着。他的灵魂潜入过动物、石头，从中细细感受万物的成长与消逝，可他却无法避免每一次灵魂的回归。在他自以为用斋戒和忏悔便能扼杀“我”时，“我”却在他还未察觉到的地方盘踞生长着。他意识到他在沙门处学到的，仅仅是短暂的逃避，而非永恒的阿特曼。他又改变了方向。 告别沙门之后，他们遇到了世尊佛陀乔达摩。聆听了乔达摩的法义后，他们不禁为这超世拔俗、其自圆满的法义所叹服，于是乔文达决定留下来跟随佛陀。而悉达多是一个善于思考且有能力思考的人，于他而言，他人的法义本身并不能让人解脱，真正的自我解脱只能靠自己亲自修行、探索，经历一番彻悟后才能获得的。他与世尊佛陀辩论，佛陀承认法义的目的并非为求知好学之人阐释世界，而是解救苦难中的世人。自此，悉达多便孤身一人开始了旅程。此刻的悉达多恍然发觉，自己年少时曾苦苦修学，竟是从未了解过“我”是怎么样的，而“我”竟如此令人费解，充满神秘。悉达多继续沉思，他觉得要想找寻自己真正的内心，必须放纵自己的内心，让欲望肆意生长。 他来到城里，结识了一位名妓迦摩罗，为赢得她的欢心，他学会做生意，成为了一名富人。他的欲望比俗世之人还要强大，他和迦摩罗夜夜交欢，载歌载舞，挥霍钱财，豪赌不尽。时间一晃过去了很多年，中年时期的悉达多一次烂醉之后，回想起了自己的年轻时的志向，他感到自己在追寻阿特曼的路上越走越偏，他在虚度光阴，他已失去了所有曾拥有过的美好的品质，堕落到了极致，他的罪孽已无可挽回，莽撞之下，来到河边，一头扎进去想了结此生。 悉达多没有死掉，他被儿时的同伴乔文达救起，濒死又生还的感觉就像一次畅快的酣睡，使他又重获新生。他告别了乔文达，去寻找曾经载他渡河的船夫瓦酥迪瓦，与他一起劳动，过极致简朴的生活。他们像两个得道的僧人，但是没有法义，仅靠聆听河水得到正确的答案。这期间，他又遇到了自己曾不告而别的爱人迦摩罗，但她不幸被毒蛇咬死，留下了儿子小悉达多。悉达多十分爱儿子，可是小悉达多并不领父亲的情，叛逆离他而去，这竟与儿时的他如此相似，很难不让人想到无尽的轮回。 故事的最后，船夫隐去林中，儿时的伙伴乔文达再次与悉达多相遇。乔文达在悉达多的脸上看到千万种形象，千万张脸，千万种动物，汇成一条长长的奔腾的面孔之河。而幻像散去，悉达多的微笑平静、轻柔，一如佛陀的微笑。 ","date":"2022-11-12","objectID":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/:1:0","tags":null,"title":"《悉达多》——人生就是在不断的体验与感悟","uri":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/"},{"categories":["书影记录"],"content":"一些感悟 悉达多从一个贵族，到一个沙门，再到世俗之人，最后归于简朴宁静的生活，他的一生就是在不断体验不同的生活，而后从不同的体验中寻求最真实的自我。在阅读《悉达多》时，我不禁热泪盈眶，我们又何尝不是像悉达多一样的人呢？在成长的过程中，有时我们掩藏内心的欲望，有时又让欲望尽情发泄，我们常常迷失自己，对自己产生怀疑，但我们不必去追究这些问题，而是要承认“我”的多元性，要去多体验生活，去感悟生活。 生活就像奔流不息的河水，虽然在不停的流淌，但过去是这样，未来也是这样。不必为过去而懊悔，也不必为未来忧愁，我们所能做的仅仅是是活在当下，随自己的本心而为，伴日月潮汐而动。 ","date":"2022-11-12","objectID":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/:2:0","tags":null,"title":"《悉达多》——人生就是在不断的体验与感悟","uri":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/"},{"categories":["书影记录"],"content":"彤彤的想法 读完这本书后，不同于百乐，我的内心并没有强烈的触动感。究其原因，可能在于我心中的悉达多，他究其一生都在寻找真正的自我。而这样的悉达多，我曾在毛姆笔下的拉里和思特里克兰里身上见过，那时候的我也曾深深为思特里克兰德而触动。而寻找自我，什么又是真实的自我？好似自我从不客观存在，而是人们在追寻它的路上逐渐塑造的形象。那在这条路上，到底该肆意放纵欲望，还是该谨慎把控言行？若是两条路不可单走，那么中庸之道如何权衡？这其间除去自己的主观意愿，又有时代的文化和道德观念参杂其中，实是复杂。现今时代，物欲纵横，现实世界的生活与精神世界的探寻如何取舍也是很大的难题。无法，只得一步步走，一步步探寻。 ","date":"2022-11-12","objectID":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/:3:0","tags":null,"title":"《悉达多》——人生就是在不断的体验与感悟","uri":"/posts/%E6%82%89%E8%BE%BE%E5%A4%9A-%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%84%9F%E6%82%9F/"},{"categories":["笔记"],"content":"Logisim 这个软件还蛮好用的，用java写的，Windows直接按照老师的说明文档装就可以了，Mac从这里下载 https://github.com/laurensk/logisim-macos 学习资料： Mooc视频–计算机硬件系统设计 https://www.icourse163.org/course/HUST-1205809816?from=searchPage ","date":"2022-10-29","objectID":"/posts/%E8%AE%A1%E7%BB%84%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C-%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:1:0","tags":null,"title":"计组线上实验-运算器设计","uri":"/posts/%E8%AE%A1%E7%BB%84%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C-%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["笔记"],"content":"第1关：8位可控加减法电路设计 后面的答案看这个 https://blog.csdn.net/qq_53149358/article/details/124462989 ","date":"2022-10-29","objectID":"/posts/%E8%AE%A1%E7%BB%84%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C-%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:2:0","tags":null,"title":"计组线上实验-运算器设计","uri":"/posts/%E8%AE%A1%E7%BB%84%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C-%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["技能分享","笔记"],"content":"在Linux上如果你有一个定时任务需要执行，只需要在crontab中设置一个触发器就可以啦。 现在升级需求，比如说我想在6:00到9:00之间，随机找一个时间执行这个任务，怎么做呢？ 思路：我们不能在crontab里指定一个随机的时间（只能指定一个具体的时间），但是我们可以指定一个具体的时间运行shell脚本，再在shell脚本里设置一个延迟执行，这样就能解决问题啦！ ","date":"2022-10-23","objectID":"/posts/linux%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%97%B6%E9%97%B4%E7%82%B9%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/:0:0","tags":null,"title":"Linux在指定时间区间内的随机时间点执行任务","uri":"/posts/linux%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%97%B6%E9%97%B4%E7%82%B9%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/"},{"categories":["技能分享","笔记"],"content":"example 假如xxx.py是我们要执行的程序，我们需要它执行的时间是从6:00到9:00之间随机一个时间，那么， crontab中这样编辑： 0 6 * * * sh /home/ubuntu/xxxx.sh \u003e\u003e /home/ubuntu/xxxx.log 2\u003e\u00261 \u0026 xxxx.sh这样写: #!bin/bash # 随机等待0～180分钟 sleep $[( $RANDOM % 180 )*60] curtime = $(date \"+%Y-%m-%d %H:%M:%S\") # 输出当前时间 echo $curtime # 运行程序 /usr/bin/python3.8 /home/ubuntu/xxxx.py \u003e\u003e /home/ubuntu/xxxx.log 完成！ ","date":"2022-10-23","objectID":"/posts/linux%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%97%B6%E9%97%B4%E7%82%B9%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/:1:0","tags":null,"title":"Linux在指定时间区间内的随机时间点执行任务","uri":"/posts/linux%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%97%B6%E9%97%B4%E7%82%B9%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/"},{"categories":["笔记"],"content":"一提到字、字节、字长、位等概念我就做晕车，从来没弄懂过，现在总结如下 英文 特点 与其它关系 位 bit 0或1，最基本单位 字节 byte ASCII码中表示一个字符的单位 1字节=8位 字 word 它代表计算机处理指令或数据的二进制数位数，是计算机进行数据存储和数据处理的运算单位。通常称16位是一个字，32位是一个双字，64位是两个双字。 16个位为一个字（即两个字节是一个字） 字长 字的位数叫做字长。不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，它的1个字就由2个字节构成，字长为16位。 不固定 ","date":"2022-10-22","objectID":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/:0:0","tags":null,"title":"字、字节、字长、位等概念区分","uri":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/"},{"categories":["笔记"],"content":"字的另一种解释 按字编址与按字节编址 在计算机系统中，总线以固定大小的一块数据进行传输，这一块的数据也称为字(word)，如今的计算机一般是32位和64位的，这里的位数则是指总线进行数据传输时一块数据的内存大小，也就是前面字的大小。 32位的计算机中：32位(bit)=4字节(byte)=1字(word) 64位的计算机中：64位(bit)=8字节(byte)=1字(word) 由此可见，在不同位数的计算机中，一个字的大小也是不同的，所以一个字等于多少字节，是多少位，与计算机的系统硬件有关,不可以错误的对一个字是几字节下固定的判断。 版权声明：本文为CSDN博主「白芷加茯苓」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_43627631/article/details/106456371 ","date":"2022-10-22","objectID":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/:1:0","tags":null,"title":"字、字节、字长、位等概念区分","uri":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/"},{"categories":["笔记"],"content":"中/英文表示 一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。 ASCII 码中，一个英文字母(不分大小写)为一个字节，一个中文汉字为两个字节。 UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。 Unicode 编码中，一个英文为一个字节，一个中文为两个字节。 符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 **。**占2个字节的大小。 UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节(Unicode 扩展区的一些汉字存储需要 4 个字节)。 UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。 摘自 http://t.csdn.cn/OQaeG ","date":"2022-10-22","objectID":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/:2:0","tags":null,"title":"字、字节、字长、位等概念区分","uri":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/"},{"categories":["笔记"],"content":"单位换算 1 Byte = 8 bit 1 KB = 2^10 Byte 1 MB = 2^10 KB = 2^20 Byte 1 GB = 2^10 MB = 2^30 Byte 另外，Byte通常简写为B(大写)，而bit通常简写为b(小写)。可以这么记忆，大写的为大单位，实际数值小，小写的为小单位，实际数值较大，1B=8b。 摘自 http://t.csdn.cn/OQaeG ","date":"2022-10-22","objectID":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/:3:0","tags":null,"title":"字、字节、字长、位等概念区分","uri":"/posts/%E5%AD%97%E5%AD%97%E8%8A%82%E5%AD%97%E9%95%BF%E4%BD%8D%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/"},{"categories":["随笔杂记"],"content":"今天三节课，分别是早八、午二、晚七，苦不堪言。下午上机课，我一直坚持的想法还被组员给否了，不太开心。然后紧接着赶去听发展对象的答辩，我本来寻思着，这个答辩三点钟就开始了，我四点钟上完课过去应该很快就结束了，然后出门接彤彤，说不定还能在外面搓一顿好的，美滋滋哇～结果，到了那里，发现答辩竟然才刚刚开始，感觉不对劲，开溜！结果更没想到的是，王导竟然点名了，点到我不在，特地让我跟他说明一下情况。同学们给我发信息，打电话，我当时都骑车到玉兰了，又赶紧跑回来听答辩会，还得跟王导解释。这个会一直到六点钟才结束，这时候彤彤已经回来了，说我鸽了她，我突然想起来晚上上课作业还没写，又赶紧到隔壁教室去补作业，连饭都没时间吃，真的很狼狈。彤彤原谅了我，还给我带了鸡蛋灌饼和烤肠，但我觉得很难过，一个下午，得罪了王导，得罪了彤姐，还把自己搞得这么狼狈，什么原因？时间管理出了问题。 因为课多，课程把时间拆成了零碎的部分，很难集中时间去解决一个个毫不相干的大任务，这个时候就要学习CPU的多线程处理任务的方式，快速地切换大脑思维，雨露均沾地做事，尽量充分利用时间。 还有，越是忙碌越要做好计划，有了计划才能不慌不忙，还能适当劳逸结合，忙里偷闲。计划被打破也不可怕，那就快速建立一个新的计划。 ","date":"2022-10-21","objectID":"/posts/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%A7%E5%A4%B1%E8%AF%AF%E8%BE%93/:0:0","tags":null,"title":"时间管理出现重大失误，输！","uri":"/posts/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%A7%E5%A4%B1%E8%AF%AF%E8%BE%93/"},{"categories":["随笔杂记"],"content":"今天数学建模比赛结果出来了，有国奖和省奖，不幸的是，我们队伍啥奖都没获。 真是屋漏偏逢连夜雨，当时上着课我就听不下去了，中午连午觉都没睡着。 ","date":"2022-10-10","objectID":"/posts/%E6%95%B0%E6%A8%A1%E6%AF%94%E8%B5%9B%E5%A4%B1%E5%88%A9/:0:0","tags":null,"title":"数模比赛失利","uri":"/posts/%E6%95%B0%E6%A8%A1%E6%AF%94%E8%B5%9B%E5%A4%B1%E5%88%A9/"},{"categories":["随笔杂记"],"content":"去年本研班有一个国奖名额，满足专业成绩和综测成绩前百分之十就可以拿到，当时我的专业成绩是第一，综测因为二课学时不够，所以差了一点，与国奖失之交臂。 今年我努力提升了我的二课学时，拿到了专业成绩和综测成绩的双第一，终于可以站到国奖答辩的舞台上。我跟我的女朋友彤彤为了本次国奖的答辩准备了很多，花了两天时间做ppt，一天时间写答辩稿。我有丰富的荣誉和履历，彤姐有丰富的答辩经验，我们的准备非常充分，我觉得我拿到国奖（或者是省奖）是胜券在握。我在台上的答辩也非常精彩，答辩一结束就有人给我发来祝贺的消息，但是结果让我万万没想到，我落选了。 更让我觉得意外的是，我在两次选举中，都是以仅一票之差输给了一个转专业到我们班级的同学。客观的来说，这位同学的答辩确实也很不错，但是专业能力方面远不如我，甚至连她自己对胜出也感到很意外。 我的第一反应是晴天霹雳，非常非常的伤心，难过，想号啕大哭…… 好多支持我的同学们也都没想到是这个结果，他们都纷纷安慰我，我感到很感动 结束的时候，一位我素未相识的答辩者，竟然拍了拍我的肩膀，对我说：“兄弟，我觉得你才是最强的。” 得到了这么多人的支持，我的心里有一些宽慰了。 我回寝室换了身衣服，立刻去找彤彤，彤彤在刚刚的答辩中站在门口看完了我的答辩过程，她也觉得我答得非常好，对结果也是愤愤不平。之前她竞选保研辅导员，能力非常出众，但是由于缺少人脉和背景而落选，她非常能理解我的心情，她安慰我说：“你没有得到你想要的，但你会得到更好的。” 我和彤彤，是多么巧合呀，我们两共同经历了最困难、最黑暗的时刻，我们能够分享快乐，也能分担痛苦，共同经历了那么多，才能对彼此惺惺相惜，彤彤不仅是我的情人，也是我的红颜知己。 像我这样在温室成长的孩子，18岁以前，较少经历挫折，缺少韧性。第一次巨大的挫折是高三的至暗时刻，但是现在的我，明显感觉到自己已经成长了，拿得起，放得下，才是真正的英雄好汉！ ","date":"2022-10-09","objectID":"/posts/%E5%9B%BD%E5%A5%96%E7%AD%94%E8%BE%A9%E5%A4%B1%E5%88%A9/:0:0","tags":null,"title":"国奖答辩失利","uri":"/posts/%E5%9B%BD%E5%A5%96%E7%AD%94%E8%BE%A9%E5%A4%B1%E5%88%A9/"},{"categories":["随笔杂记"],"content":"9月15日晚拿到题目，那天正好赶上开组会，又正好赶上台风过境，下暴雨，搞到晚上10点回寝室的时候整个人都湿透了。 9月18日下午，终于把题目做完啦～真的很累，回寝室直接躺床上休息 ","date":"2022-09-18","objectID":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/:0:0","tags":null,"title":"数学建模参赛有感","uri":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"题目 题目是《古代玻璃制品的成分分析与鉴别》，重点在于分析，使用各种手段，如敏感性分析，关联分析等等，除此之外，还用了SVM，Kmeans等经典机器学习算法。这些算法、模型要么是简单调用现成的API，要么就是从来没听过，只好现学现用，生搬硬套，所以我们给出的题解肯定是漏洞百出，但好在最后我们在写论文圆了一个美满的故事，看上去还行。 ","date":"2022-09-18","objectID":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"数学建模参赛有感","uri":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"团队 我们的team三个人来自三个专业，都是业余玩家，但好在我们几个心态都很好，沟通愉快、合作愉快。我们三个人一起商量思路（自夸地说，思路主要是我提供的🐶），我负责写代码，她们两个查资料、写论文，最后早早提交了作品，大家都很开心。另外再说一句，写代码是我喜欢做的事情，好久都没这么专注的写代码了，很爽。 上大学前，我期待的大学生活的一个片段就是像这样，小组合作，男女搭配，一起忙活个三天，整个东西出来。你可能会说，课程大作业不也是这样吗？大作业还真不是，大作业常出现有人摆烂，推卸责任，敷衍了事的情况，而不是大家一起努力、一起奋斗，解决问题，克服困难。 总之，这次比赛让我找到了学习和工作的好状态，是一次珍贵的回忆～（如果得不了奖就不珍贵了doge ","date":"2022-09-18","objectID":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"数学建模参赛有感","uri":"/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%8F%82%E8%B5%9B%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"读书和锻炼是仍然是主要活动，读书是学习知识最快的途径，锻炼是保持高效率的前提。其中读书的范围要收敛，多读专业书籍，少读课外书（也不能不读，毕竟思维狭隘，需要开拓），另外还要多读论文。 专业书籍需要包括以下方向： 数据挖掘、数据可视化； 计算机组成原理、软件工程； 计算机网络； 论文包括： 可视化，每周一篇，有利于组会汇报； Ai相关的文章也可以多了解； 课外书包括： 名人传记； 社会科学、自然科学、心理学、人际交往； 思想、人生哲理、方向指导； 锻炼的主要方式是跑步，每次跑完之后都能释放压力，增强自信心。每周至少跑3次，每次3～5公里。 其它的事情，比较重要的有导师安排的任务、上课、以及我跟王彤的关系，不重要的有Linux社团和飞桨领航团的事务、竞赛等等。 我的终极目标很简单，就是研究生毕业之后找到一份不错的工作。相比于搞技术、我觉得我没有做科研的天赋，但是在时间不长的大学时光里，我需要培养我的科研能力（这种技能很重要，而且只能在大学里习得，以后进入社会就再也接触不到了）。既然选择了读研，就要以研究生的身份要求自己，当然也不要忘记我的最终目标，只是想找一个好的工作而已。 过去我觉得我自己很厉害，想过通过读博、创业改变自己的人生，改变自己的阶层。但是在任何时代，普通人想通过努力改变自己的阶层都是非常困难的，在互联网时代，我们听到了大量其他人成功的案例，这使我们产生了盲目的自信，但是现实的各种麻烦又让我们非常焦虑，互联网又加速了焦虑的传播。很多人老了之后回想起自己的年轻时，没有被现实击垮时的意气风发，颇有点可笑，最终还是回归了平平淡淡的生活。被生活击垮、为未来焦虑的滋味是很难受的，既然未来很难改变，那为何不降低目标，减少焦虑呢？ 我这样想，确实有点“胸无大志、只想过自己的小日子”的嫌疑，但是我也没办法，我的成长环境、我的父母、我的阶层决定了我的想法，也在一定程度上决定了我的未来。我也不是想当咸鱼，想摆烂的，我觉得年轻人不能摆烂，摆烂就一点希望都没有了。我还是很有上进心的，我的目标是过上比我父母更好一点的生活，为了这个目标，我仍然要努力。但是努力不是无休止的，努力是为了未来的美好生活，而努力之余，品味一下当下的美好生活也很值得，不是吗？ ","date":"2022-09-07","objectID":"/posts/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"大三上学期规划","uri":"/posts/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"星露谷物语 星露谷物语是一款农场模拟经营游戏，但除了种田之外，游戏还包括了钓鱼、挖矿、杀怪、结婚、剧情任务等丰富的游戏内容。初看游戏大小，只有600mb，画面是粗糙的像素，但当你深入品玩这个游戏后，你会被这个游戏庞大的世界观震惊，你真的很难相信，它的作者是个独立开发者。 ","date":"2022-08-28","objectID":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/:0:1","tags":null,"title":"星露谷物语为什么这么好玩？","uri":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/"},{"categories":["随笔杂记"],"content":"没有显式的游戏教程 游戏的背景故事非常简单，你扮演的是一个在joja公司的普通打工人，有一天你得知爷爷去世了，他写信告诉你他把家里的一大片农田和房屋继承给你，你一拍脑袋说：上个屁的班，回家种地！ 然后你来到了这个叫星露谷的小镇，开始农夫生活。游戏几乎没有任何显式的游戏教程，全凭玩家自己探索发现，比如说一些特殊地点、剧情、和操作，这一点跟塞尔达传说：旷野之息很像，制作人并没有丢给玩家一大段游戏指南，让玩家先去学习一遍再游玩，而是通过巧妙的剧情安排，一步一步推进，让玩家自己发现游戏玩法。 ","date":"2022-08-28","objectID":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/:0:2","tags":null,"title":"星露谷物语为什么这么好玩？","uri":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/"},{"categories":["随笔杂记"],"content":"自由度极高，但平衡性很好 查一查星露谷的wiki，你就会发现这个游戏的内容是有多么丰富。一些规则的设计是有多么巧妙，比如春夏秋冬四季，各个季节都有特色，不同的作物酿酒后售出的价格之间微妙的差别，npc的喜好物品与性格相映衬，有趣的剧情（比如镇长的短裤，绿帽事件…）等等。游戏的自由度很高，你既可以当成休闲养生游戏，随便种种田，钓钓鱼，看看风景，也可以把游戏当作赚钱模拟器，肝种地，肝养猪，肝酿酒。虽然游戏内容丰富，自由度也高，但是平衡性仍然不错，很难因为“用户奇怪的玩法”导致存档崩溃。 ","date":"2022-08-28","objectID":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/:0:3","tags":null,"title":"星露谷物语为什么这么好玩？","uri":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/"},{"categories":["随笔杂记"],"content":"全平台运行 这里的全平台指的是windows、mac（支持M1）、android、ios（谁会用Linux玩游戏😂）。windows和mac版本可以直接在steam里玩，而且都支持mod，安卓和ios貌似要折腾一下。 ","date":"2022-08-28","objectID":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/:0:4","tags":null,"title":"星露谷物语为什么这么好玩？","uri":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/"},{"categories":["随笔杂记"],"content":"联机 跟Minecraft不同的是，在星露谷物语中，你扮演的角色是和小镇上npc的地位平齐的，也就是说你并不孤单，有一群npc陪着你（而Minecraft中几乎你是独自一人，非常孤独）。Minecraft联机可以相互合作，使乐趣加倍，而在星露谷物语当中联机，可能会因为两个人的游戏节奏不同，而有种被带节奏的感觉。所以更推荐单人游戏，然后多浏览社区内容，与其他玩家交流。 ","date":"2022-08-28","objectID":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/:0:5","tags":null,"title":"星露谷物语为什么这么好玩？","uri":"/posts/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9/"},{"categories":["随笔杂记"],"content":"胡乱发表一点感想 暑假，在家里呆了一个半月，刚回来的时候是很兴奋的，兴奋到前一天晚上睡不着觉。每次回来呢，感觉都和上次差不多，房间里的物品还摆在之前的位置，爸爸妈妈还说着同样的话，还能继续和朋友们一起玩游戏。但是在某个夕阳落下的傍晚，我又突然感到一切并不像以前那样了，街道好像又旧了一点，家人又老了一点，朋友又陌生了一点。在家呆的时间长了，也觉得厌烦，但是离别之际，突然觉得很不舍，舍不得这个城市，舍不得家人，舍不得朋友。 想到一句话，人生就是不断的相识与别离，别离之后，有的人能重逢，有的人就再也见不到了。我和刘鑫宇属于是重逢，我们两初中关系不错，到了高中就基本没联系了，上大学后没想到放了寒暑假还能继续一起玩游戏，但是大学毕业以后呢？他工作，我读研，他在蚌埠，我在青岛， 我们各奔东西，恐怕不能再像现在这么愉快的玩耍了。 别离在所难免，重逢得看缘分，唯一能做的，就是珍惜眼前人。多对家人好一点，对朋友大方一点，对女朋友多用心一点。别留下太多遗憾。 下面对这个愉快的假期做一个回顾吧： ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:1","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"跟baby视频 我没有跟任何人视频的习惯，but假期见不到baby，只能通过视频交流啦，qq的特效真的超好玩～ ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:2","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"跟老妈一起打羽毛球 我不在家时老妈也比较清闲，没事儿就去打打球，球技练的不错，我跟着她打出一了一身的汗！ ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:3","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"老爸送的尤克里里 有一天老爸突然说，因为吉他太大了不好携带，要送我一把尤克里里，但是他挑不好（其实是懒），就给我转了钱让我自己买，我感到很惊喜 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:4","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"做核酸检测志愿者 这是我在这个假期做过最有意义的一件事！在老妈的居委会做了n多次（至少8次，每次5小时）核酸检测志愿者，从最开始的频频出错，到后来的轻车熟路，挺不容易的，感觉收获到了很多。结局非常满意，得到了心灵上的满足并且拿到了荣誉证书和补贴。另外值得一提的是，这条说说得到了导师的点赞，他还在大群里表扬我，真是又惊又喜😂 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:5","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"初次尝试找工作 当了半天的老师，教小孩子们学英语，哎哟我天累死我了 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:6","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"网吧yyds 愉快的假期怎么能少得了跟刘鑫宇去网吧呢？我们打了无数把终极魔典！ 上完网，再去吃顿好的，多是一件美事～ 羊腰子是真滴香，这味儿不是一般人能受的了的 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:7","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"与cbv和高若宇和哲哲的短暂相聚 cbv因为疫情被困在蚌埠，我去找他玩（他好骚 上网是少不了的，就这点爱好😂 高若宇难得回来一次，我请cbv和高若宇和哲哲吃了顿饭，然后我们一起去溜冰，最后吃了很nice的雪冰，暑假很长，但我们相聚时间很短 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:8","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"厨艺又长进 今年暑假，我做菜学会用油啦！煎烤肠、炸土豆、煎鸡蛋、炒腰果都不在话下，下图是我做的最成功的一道菜——酱油炒饭。 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:9","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"客制化键盘 从刘鑫宇那里了解到：键盘竟然可以客制化？我立刻来了兴趣，并动手搞了一把，结果非常满意，还特地写了一篇blog来说这个事情 ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:10","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"工作和学习 刚回到家：我要努力多学一点东西，不能松懈💪！ 一周后：组会好烦呀😭，每次开组会前都好emo（下图做完志愿者后边回家边开组会 半个月后：我不想努力了，我想摆烂了😂（天天出去玩 开学前：卧槽，我带回来的书一个字都没读！😅 这个假期只动手做了一个vue的小项目，读了一本《鞑靼人的沙漠》，学业基本上是处于荒废状态… ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:11","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"一个非常重要的人 在这个假期里有一个非常重要的人陪伴我始终，虽然我们不能相见，但是每天都在线上互道早安和晚安，分享开心的事和难过的事。我们也吵过几次架，但很快又会和好，并从中吸取教训，我们非常喜欢彼此，这个人就是我的girl friend，我叫她王彤、彤彤、大彤、猪妹，每一个称呼包含了爱意。这是一段前所未有的感情经历，我不打算在这里讲述，因为我们的故事远没有结束～ ","date":"2022-08-28","objectID":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/:0:12","tags":null,"title":"人生就是不断的相识与别离","uri":"/posts/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E7%9B%B8%E8%AF%86%E4%B8%8E%E5%88%AB%E7%A6%BB/"},{"categories":["技能分享","随笔杂记"],"content":"作为计算机专业的学生和游戏爱好者，每天做的最多的事情就是坐在电脑前面敲键盘，俗话说：“工欲善其事，必先利其器”，要追求更高效的工作方式和游戏体验，打造一把趁手的高端的机械键盘很有必要。 ","date":"2022-08-16","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/:0:0","tags":null,"title":"我的第一把客制化键盘","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/"},{"categories":["技能分享","随笔杂记"],"content":"机械键盘和薄膜键盘 不会有人现在还不知道机械键盘和薄膜键盘的区别吧？它们两个架构不同，薄膜键盘是指通过胶碗来完成键帽的按下与回弹的动作，当按键下压到薄膜上时候，触点接触产生电信号，完成整个按键过程的键盘。机械键盘的每一个键下面都是一个开关，每一次敲击都是按动了一个开关，所以虽然和薄膜键盘的效果是一样的，但是从触发的原理上讲是有本质的区别的。早期的打字机、电报机是机械键盘，按下去啪嗒啪嗒响声很大。后来人们发明了廉价、寿命高、还防水的薄膜键盘，快速取代了机械键盘的市场。到了现代，人们又为了追求更好的手感和更好听的按键音回归了机械键盘。机械键盘有“轴”的概念，不同的轴的按压重量、段落感、声音等等是不一样的。轴的名字一般以颜色命名，比如青轴声音大，段落感很好，适合打游戏，红轴声音小，没有段落感，适合打字。 ","date":"2022-08-16","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/:0:1","tags":null,"title":"我的第一把客制化键盘","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/"},{"categories":["技能分享","随笔杂记"],"content":"客制化键盘 客制化键盘是针对机械键盘而言的，起初我是不知道有这个圈子的，直到前几天我的挚友刘鑫宇跟我说他跟着网上的教程搞了一把客制化键盘，我一下来了兴趣。我平时用的键盘都是凑合用的，对高端键盘有需求，而且淘宝上的成品键盘鱼龙混杂，便宜的不入我眼，贵的买不起，而客制化键盘既便宜又能满足我的个性化要求，直接开冲！ 客制化键盘对新手来说还是蛮友好的，只需要买套件、轴体、键帽这三样配件，不到一个小时就能装出一把键盘，非常简单。下面是我选择的配件以及选择理由： 套件：黑吉蛇dk68，淘宝官方店购买，175元。最有性价比的三模套件（三模是指有蓝牙、Wi-Fi2.4g、有线三种连接方式），有RGB灯光。68键的配列比正常尺寸的键盘要小很多（移除了一些按键），好处是轴体用得少，省钱，而且很小巧精致，方便携带。不用担心按键缺失，缺失的按键都是不常用的按键，即使用到了也可以用组合按键代替。 轴体：ttc金粉轴v2，闲鱼购买，161元（2.3一颗，买70颗）。我的码字需求远高于游戏需求，所以选择了这个码字网红轴。确实很满意，打字很舒服，声音有点像麻将，很好听。轴体的选择见仁见智，适合自己的才是最好的， 键帽：藤花键帽，闲鱼购买，47元（包括8元运费）。这个键帽是别人买键盘送的，闲置了卖给我，我觉得很好看，很喜欢，也很划算。键帽没什么科技含量，选个好看的就行。 ","date":"2022-08-16","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/:0:2","tags":null,"title":"我的第一把客制化键盘","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/"},{"categories":["技能分享","随笔杂记"],"content":"效果 ","date":"2022-08-16","objectID":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/:0:3","tags":null,"title":"我的第一把客制化键盘","uri":"/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%8A%8A%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98/"},{"categories":["技能分享","笔记"],"content":"有一个python脚本，需要每天定时执行。我想使用crontab解决，但是无论怎样都不生效，最后问了专业人士（我表哥）才解决。下面分享一下踩过的坑： ","date":"2022-07-13","objectID":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/:0:0","tags":null,"title":"Linux输出重定向以及crontab的坑","uri":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/"},{"categories":["技能分享","笔记"],"content":"编辑crontab 首先执行 crontab -e 编辑cron表达式，注意：每个用户都有自己的crontab，如果想省事的话建议直接 sudo crontab -e 只使用root用户的就好了。 ","date":"2022-07-13","objectID":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/:1:0","tags":null,"title":"Linux输出重定向以及crontab的坑","uri":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/"},{"categories":["技能分享","笔记"],"content":"写cron表达式 一行一个。一般自己在执行脚本的时候在终端里打的是python 脚本.py，但是在cron里可能会有问题。最好把所有的路径都换成绝对路径，比如/usr/bin/python3.8 /home/ubuntu/脚本.py，前面加上时间（比如说每天23点执行），完整如下： 0 23 * * * /usr/bin/python3.8 /home/ubuntu/脚本.py 注意：有的时候python脚本里会打开其它文件（存在其它文件的相对路径），这个时候必须得cd到当前目录下才可以正确执行，改成如下： 0 23 * * * cd /home/ubuntu/ \u0026\u0026 /usr/bin/python3.8 /home/ubuntu/脚本.py ","date":"2022-07-13","objectID":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/:2:0","tags":null,"title":"Linux输出重定向以及crontab的坑","uri":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/"},{"categories":["技能分享","笔记"],"content":"输出重定向 有几个符号要认识一下： \u003e file // 标准输出重定向到文件-覆盖 \u003e\u003efile // 标准输出重定向到文件-追加 2\u003efile // 标准错误重定向到文件-覆盖 2\u003e\u003efile // 标准错误重定向到文件-追加 2\u003e/dev/null // 标准错误重定向到回收站 \u0026\u003efile // 标准输出和标准错误重定向到文件-覆盖 \u003e\u003efile 2\u003e\u00261 // 标准输出和标准错误重定向到文件-追加 偷懒的话，就用最后一个就可以啦。把所有的输出（包括报错）都输出到自己定义的日志文件里，这个很实用，因为你的脚本一旦出现问题，查日志是很好的追溯手段。所以表达式又复杂一点： 0 23 * * * cd /home/ubuntu/ \u0026\u0026 /usr/bin/python3.8 /home/ubuntu/脚本.py \u003e\u003e /home/ubuntu/out.log 2\u003e\u00261 最后还可以加一个\u0026，表示后台执行： 0 23 * * * cd /home/ubuntu/ \u0026\u0026 /usr/bin/python3.8 /home/ubuntu/脚本.py \u003e\u003e /home/ubuntu/out.log 2\u003e\u00261 \u0026 ","date":"2022-07-13","objectID":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/:3:0","tags":null,"title":"Linux输出重定向以及crontab的坑","uri":"/posts/linux%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5%E5%8F%8Acrontab%E7%9A%84%E5%9D%91/"},{"categories":["刷题","笔记"],"content":"7-1 Table Tennis 知识点：模拟，队列 思路：把所有玩家按到达顺序排序，逐个处理，分如下情况： 找到所有桌子中最早结束当前服务的桌子。判断：如果这个桌子当前服务的结束时间超过9点，那剩下的玩家都不用处理了，不可能被服务。否则再继续下面的过程。 如果这个桌子是为vip预留的： 这个人是普通人，除非他后面没有vip到来，桌子才给他用 如果这个人是vip，这个桌子分配给他。 处理下一个人 如果这个桌子是普通桌子： 如果这个人是普通人，那么这个桌子分配给他。处理下一个人 如果这个人是vip，首先去看在他来之前有没有空下来的vip桌子，如果有，就让他去那个vip桌子，如果没有，就把这个普通桌子给他用。处理下一个人。 细节： 时间以从0点经过的秒数存储 结构体数组customers[10005]储存顾客，字段有：到达时间arriveTime，开始被服务时间 startTime，玩耍时间 playTime ，是否VIPisVip，是否被服务过 isServed 结构体数组table[105]储存桌子，字段有：结束服务的时间endTime，服务顾客数serveCount，是否VIPisVip 排序 —\u003e 借用第一阶段第五题的堆排序，将cmp函数作为参数传进去 这题细节太多了，看代码注释 #include\u003ciostream\u003e const int intMAX = 0x3f3f3f3f; using namespace std; // 俱乐部开门时间，以 s 为单位 const int club_open_time = 3600 * 8; // 俱乐部关门时间，以 s 为单位 const int club_close_time = 3600 * 21; struct Customers { int arriveTime, startTime, playTime; // 到达时间，开始时间，玩耍时间 bool isVip, isServed = false; // 是否是 vip，是否被服务过了 }customer[10005]; struct Table { // 刚开始全是8:00开始服务 int endTime = club_open_time, serveCount = 0; // 当前服务结束时间，已服务玩家个数 bool isVip = false; // 是否是为vip预留的桌子 }table[105]; // 按到达的先后顺序排队 bool cmp_by_arrive(Customers a, Customers b) { return a.arriveTime \u003c b.arriveTime; } // 输出时，按被服务时间排序 bool cmp_by_starttime(Customers a, Customers b) { return a.startTime \u003c b.startTime; } void Heapify(Customers arr[], int n, int i, bool (*cmp)(Customers a, Customers b)){ // arr 存储堆的数组，n 数组长度， i 维护节点的下标 int largest = i; // 假设最大节点 int lson = 2 * i + 1; int rson = 2 * i + 2; if (lson \u003c n \u0026\u0026 cmp(arr[largest], arr[lson])){ largest = lson; } if (rson \u003c n \u0026\u0026 cmp(arr[largest], arr[rson])){ largest = rson; } if(largest != i){ Customers tmp; tmp = arr[largest]; arr[largest] = arr[i]; arr[i] = tmp; Heapify(arr, n, largest, cmp); } } // 堆排序入口 void HeapSort(Customers arr[], int n, bool (*cmp)(Customers a, Customers b)){ // 建堆，从底往上构建 int i; for(i = n / 2 - 1; i \u003e= 0; i--){ // 从最后一个元素的父节点开始 Heapify(arr, n, i, cmp); } // 排序 for(i = n - 1; i \u003e 0; i--){ Customers tmp; tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; Heapify(arr, i, 0, cmp); } } // 将某个桌子提供给某个顾客 void AssignTable( int tab_id, int cus_id ) { // cout \u003c\u003c \"tab_id \" \u003c\u003c tab_id \u003c\u003c \" cus_id \" \u003c\u003c cus_id \u003c\u003c endl; // 玩家来的时候，这个桌子已空闲，玩家可以直接开始玩 if (table[tab_id].endTime \u003c= customer[cus_id].arriveTime) { customer[cus_id].startTime = customer[cus_id].arriveTime; } else { // 玩家来的时候这个桌子还在服务上一个人，需要等它当前服务结束 // 所以玩家开始玩的时间应该是这个桌子当前服务结束的时间 customer[cus_id].startTime = table[tab_id].endTime; } // 开始新的服务，更新这个桌子当前服务的结束时间 table[tab_id].endTime = customer[cus_id].startTime + customer[cus_id].playTime; // 这个桌子的服务人数增加 table[tab_id].serveCount++; } // 找到这个人后面第一个会员未被服务的会员 // N,总顾客数 int FindNextVip(int cus_id, int N) { cus_id += 1; while ( cus_id \u003c N ) { // 是会员！且未被服务！ if ( customer[cus_id].isVip \u0026\u0026 !customer[cus_id].isServed ) return cus_id; cus_id++; } return -1; } // 找到第一个结束服务的桌子，K为桌子数 int GetMinEndTable(int cus_id, int K){ int index = -1, min_end = intMAX; for (int i = 1; i \u003c= K; i++) { if (customer[cus_id].arriveTime \u003e table[i].endTime ){ index = i; break; } else if (table[i].endTime \u003c min_end) { index = i; min_end = table[i].endTime; } } return index; } // 为会员找桌子，K 为桌子总数 int FindTableForVIP( int K ){ // 先看所有给会员预留的桌子是否有空闲，有就给他，没有就把这个普通桌子给他 // 找到所有会员桌中最早结束的那个 int t_vip = -1, t_vip_min_end = intMAX; for (int i = 1; i \u003c= K; ++i) { if (table[i].isVip \u0026\u0026 table[i].endTime \u003c t_vip_min_end) { t_vip = i; t_vip_min_end = table[i].endTime; } } return t_vip; } // 自己写的round，四舍五入求整数 double round(double x) { return (int)(x+0.5); } int main() { // 输入玩家 int N; cin \u003e\u003e N; int hh,mm,ss,t,vip; int cus_cnt = 0; // 在营业时间内的顾客数量，跟 N 不一样！ while( N-- ){ scanf(\"%d:%d:%d %d %d\", \u0026hh, \u0026mm, \u0026ss, \u0026t, \u0026vip); int arrive = hh * 3600 + mm * 60 + ss; if (arrive \u003e= club_close_time) continue; // 玩家来的时候俱乐部关门 customer[cus_cnt].arriveTime = arrive; // 玩家到达时间，以秒记 t = t * 60; if (t \u003e 7200) t = 7200; customer[cus_cnt].playTime = t; // 一个玩家最多玩2小时 customer[cus_cnt].isVip = vip == 1 ? true : false; // 是否是vip // 把玩家被服务时间初始化为俱乐部关门时间，便于最后输出时淘汰掉哪些未被服务的玩家 customer[cus_cnt].startTime = club_close_time; cus_cnt ++ ; } // 输入桌子 int K, M; cin \u003e\u003e K \u003e\u003e M;","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:1:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-2 分而治之 知识点：图论 思路： 思路一：记录邻接矩阵，输入时记录每个节点的度数。被摧毁的城市的度置为0，和它相邻的点度也-1。最后检查是否有度大于0的点，有就说明有城市相连通，输出NO，否则输出YES； 思路二：记录所有的边(u, v)，和被攻陷城池lost[i]。遍历边(u, v)，如果存在u或v没有被攻陷（即不在lost里面），说明有城市连通，输出NO，否则YES； 因为这题最多有10005个点，使用邻接矩阵会超内存，所以采用第二种思路； 细节： 记录边可以使用两个数组u[10005]和v[10005]，第i条边的两个节点是u[i]和v[i] 判断边中是否包含没被攻陷的城池if( !lost[u[i]] \u0026\u0026 !lost[v[i]] ) 代码： #include \u003ciostream\u003e;using namespace std; class Citys { public: int N, M; int u[10005]={0}; int v[10005]={0}; // 第 i 条边为 (u[i], v[i]) void insertPath(); // 输入路径 bool isValid(); // 输入一个方案，判断是否有效 Citys(); // 构造函数，输入N, M }; Citys::Citys() { cin \u003e\u003e N \u003e\u003e M; } void Citys::insertPath() { for(int i=0; i\u003cM; i++){ cin \u003e\u003e u[i] \u003e\u003e v[i]; } } bool Citys::isValid() { // 输入攻破的城池 int Np; cin \u003e\u003e Np; int lost[10005] = {0}; for( int i=0; i\u003cNp; i++ ){ int city; cin \u003e\u003e city; lost[city] = 1; } // 判断 for( int i=0; i\u003cM; i++ ){ if( !lost[u[i]] \u0026\u0026 !lost[v[i]] ){ // 如果都不是被攻陷的城池 return false; } } return true; } int main() { // 输入数据 Citys citys = Citys(); citys.insertPath(); int K; cin \u003e\u003e K; for( int i=0; i\u003cK; i++ ){ if( citys.isValid() ) cout \u003c\u003c \"YES\" \u003c\u003c endl; else cout \u003c\u003c \"NO\" \u003c\u003c endl; } return 0; } ","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:2:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-3 那就别担心了 知识点：dfs、时间复杂度 思路：抽象一下：给定一个有向无环图（DAG），并且给出起点A和终点B，问从A出发的所有路径是否都能到达B，并且求出从A出发到达B的不同路径有多少条。 第一个问题非常好解，只要从A开始DFS，如果搜到某个出度为0的点，并且这个点不是题面给出的B点，就说明并不是所有从A出发的路径都能到达B。 对于第二个问题，虽然这道题数据比较小，最多只有500个点，但是这题的时间限制是400ms，对于求解不同路径的问题，如果暴力搜索的话是一定会超时的。 考察输入样例（自己编的）: 7 8 7 6 8 5 6 5 5 2 5 3 2 1 3 1 7 1 很明显，从7到1有如下路径： 7 -\u003e 6 -\u003e 5 —\u003e 2 -\u003e 1 7 -\u003e 6 -\u003e 5 -\u003e 3 -\u003e 1 7 -\u003e 8 -\u003e 5 -\u003e 2 -\u003e 1 7 -\u003e 8 -\u003e 5 -\u003e 3 -\u003e 1 发现，从5到1有两条路径。在搜索时，经过7，6，5，会把这两条路径都搜索一遍；经过7，8，5，又会把这两条路径搜索一遍。这样就造成了时间的浪费。我们考虑，如果在经过6号节点到达5号节点，再到达终点1号节点的所有路径全部搜索完时，5号节点能够储存下“经过该节点有2条路径到达目标节点”这个信息，这样在从8号节点搜索到5号时，就不需要再重复地将接下来的路径全部搜索一遍了，直接从5号节点读到“接下来有2条不同的路径”这个信息。正好，DFS的“走到底再返回”的性质可以做到从尾到头，也就是从终点到起点记录信息，因此我们可以在DFS的过程中进行记忆化操作。 我们定义step[i]为“从i号节点到达目标节点的路径条数“，求解的目标是step[A]，定义step[B] = 1，并且标记𝐵B节点已经被访问过。在DFS的过程中，如果将要搜索的节点没有被访问过，就搜索，并记录下路径条数，当前节点直接加上待搜索（其实这时候已经搜索完了）的节点的路径条数。以上图为例，DFS的过程如下： 初始化step[]数组为0，初始化vis[]数组为false，赋值step[1]=1, vis[1]=true; 从起点7开始DFS，赋值vis[7]=true。接下来想搜索6，vis[6]==false，进入； 从6节点开始DFS，赋值vis[6]=true。接下来想搜索5，vis[5]==false，进入； 从5节点开始DFS，赋值vis[5]=true。接下来想搜索2，vis[2]==false，进入； 从2节点开始DFS，赋值vis[2]=true。接下来想搜索1，vis[1]==true，不进入；累加路径条数step[2]=step[2]+step[1]，这时step[2]=1。2节点没有其他的路径，返回，step[5]=step[5]+step[2],此时step[5]=1 接下来想搜索3，赋值vis[1]==true，不进入；累加路径条数step[3]=step[3]+step[1]，这时step[3]=1。3节点没有其他的路径，返回,step[5]=step[5]+step[3],此时step[5]=2 5节点没有其他的路径，返回，step[6]=step[6]+step[5]，此时step[6]=2. 6没有其它节点了，返回7，step[7]=step[7]+step[6]，此时step[7]=2。继续搜索8。 从8开始DFS，赋值vis[8]=true，接下来又想搜索5，vis[5]=true，不进入，step[8]=step[8]+step[5]，此时step[8]=2； 没有其它路径了，返回7，step[7]=step[7]+step[8]，此时step[7]=4。没有其它节点了，递归结束。 细节： 路径使用邻接矩阵存储（邻接表更节省空间，但因为不能使用vector，所以邻接表实现起来会麻烦一点） 判断能否“逻辑自洽”：出度为0且该节点不是终点，令全局变量isLogic dfs的过程用代码实现： void Propositions::dfs(int node) { vis[node] = true; // 标记访问 // 如果出度为0，且该节点不是终点，说明不是逻辑自洽的 if ( getOutdegree(node) == 0 \u0026\u0026 node != end ){ isLogic = false; } // 继续dfs没有被访问过的节点，并且记录step for( int i=0; i\u003cN+1; i++ ){ if( path[node][i] ){ if( !vis[i] ) dfs(i); step[node] = step[node] + step[i]; } } } 所有代码： #include \u003ciostream\u003eusing namespace std; class Propositions { public: int N, M; int start, end; // 起点和终点 int isLogic = true; // 是否逻辑自洽 int path[505][505]; // 邻接矩阵，在构建函数中初始化为0； long long step[505] = {0}; // step[i] : 第 i 个点到终点的路径的个数 bool vis[505] = {0}; // 是否访问过 Propositions(); void insertPath(); // 输入路径 int getOutdegree(int node); // 计算一个节点的出度 void dfs(int node); // 深度优先搜索 void detect(); // 入口，初始化，dfs和输出 }; Propositions::Propositions() { for( int i=0; i\u003cN+1; i++ ){ for( int j=0; j\u003cN+1; j++ ){ path[i][j] = 0; } } } void Propositions::insertPath() { cin \u003e\u003e N \u003e\u003e M; for( int i=0; i\u003cM; i++ ){ int from, to; cin \u003e\u003e from \u003e\u003e to; path[from][to] = 1; } } int Propositions::getOutdegree(int node) { int sum = 0; for( int i=0; i\u003cN+1; i++ ){ sum += path[node][i]; } return sum; } void Propositions::dfs(int node) { vis[node] = true; if ( getOutdegree(node) == 0 \u0026\u0026 node != end ){ isLogic = false; } for( int i=0; i\u003cN+1; i++ ){ if( path[node][i] ){ if( !vis[i] ) dfs(i); step[node] = step[node] + step[i]; } } } void Propositions::detect() { cin \u003e\u003e start \u003e\u003e end; step[end] = 1; // 重要初始化 vis[end] = true; // 重要初始化 dfs(start); cout \u003c\u003c step[start] \u003c\u003c \" \" ; if( isLogic ) cout \u003c\u003c \"Yes\"; else cout \u003c\u003c \"No\"; } int main() { Propositions p; p.insertPath(); p.detect(); return 0; } ","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:3:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-4 森森旅游 知识点：最短路径、邻接表 思路：用Dijskra最短路算法分别求出 1.使用现金从城市1出发，到达所有城市的最小花费（储存在oneToOthers内） 2.使用旅游金从城市n出发，到达所有城市的最小花费（储存在othersToN内） 在第i个城市将现金换成旅游金的情况下所需要的现金总额为 all_cash = oneToOthers[i] + othersToN[i]/a[i]（a[i]是汇率，注意除不尽要+1） （即从城市1到达第i个城市所需要的最小现金数 + 从第i个城市到城市n所需要的最小旅游金数所转换成的现金数量） 然后再通过枚举中转点i的方式，得到全局最优解。为了让Dijkstra算法更有效率，可以存储反向路径。 细节： 路径的存储。 使用邻接表，而不是邻接矩阵，因为1w*1w的二维数组会超内存。 存储路径的数据结构为：myvector\u003cMypair\u003e path[100005], rpath[100005]，其中myvector是自己定义的类，实现类似vector的功能，其最大的特点是长度可变；Mypair是自己定义的结构体，实现类似pair的功能。 path存储的是一个城市到另一个城市所需要现金。rpath存储的是相反路径所需要的旅游金。 举个例子，对于输入u v c d，path[u].push_back(Mypair(v, c))，rpath[v].push_back(Mypair(u,d)) Dijkstra有枚举写法，时间复杂度为O(n*2)，n是节点个数。还有基于优先队列的写法，时间复杂度为O(ElogV)。这里使用后者。 本题的最后一步是更新汇率，也有两种操作： 每次更新汇率后都枚举一次中转点，找到最少花费，然后输出。时间复杂度高，3个点过不去，只能得21分。 枚举中转点，用一个multiset（其特点是有序，能够快速插入和删除）维护。每次更新汇率都删除旧的，插入新的。时间复杂度低，但是很难实现（红黑树）。 21分代码（三个测试点超时）： #include \u003ciostream\u003e#define int long long const int N = 100005; // 最大节点数 using namespace std; // 实现Mypair struct Mypair { int first; int second; // 默认构造函数 Mypair() :first(0),second(0) {} //用0,0初始化 //构造函数 Mypair(const int\u0026a,const int\u0026b) :first(a),second(b) {} }; // 为了加入优先队列，对操作符重载 bool operator==(const Mypair\u0026s1,const Mypair\u0026s2) { return s1.first==s2.first\u0026\u0026s1.second==s2.second; } bool operator\u003e(const Mypair\u0026s1,const Mypair\u0026s2) { return (s1.first\u003es2.first)||(!(s1.first\u003cs2.first)\u0026\u0026s1.second\u003es2.second); } bool operator\u003c(const Mypair\u0026s1, const Mypair\u0026s2) { return (s1.first\u003cs2.first)||(!(s1.first\u003es2.first)\u0026\u0026s1.second\u003cs2.second); } // 实现优先队列（大顶堆） class PriorityQueue { private: Mypair* pArray; int m_length; public: PriorityQueue(int N) { // 为后续根节点直接从1开始作准备 pArray = new Mypair[N]; m_length = 0; } // 返回堆顶 Mypair Top(){ return pArray[1]; } // 删除堆顶 Mypair delMax() { // 大根堆第一个元素为最大 Mypair max = pArray[1]; // 将第一个元素和最后一个元素交换,并使长度减一，即删除最大的元素 swap(pArray[1], pArray[m_length--]); // 防止对象游离 pArray[m_length + 1] = Mypair(); // 下沉恢复堆的有序性 sink(1); // 返回最大的节点值 return max; } // 插入元素 void insert(Mypair v) { // 将值v插入到pArray[1]位置处，所以这里用的前置++ pArray[++m_length] = v; // 新加入的元素上浮 swim(m_length); } // 判断是否为空 bool isEmpty() { return m_length == 0; } // 队列元素个数 int size() { return m_length; } // 向上浮 void swim(int k) { // 判断最下层的叶子节点值如果大于其父节点则进入循环上浮 while (k \u003e 1 \u0026\u0026 pArray[k] \u003e pArray[k / 2]) { // 交换父节点和子节点 swap(pArray[k / 2], pArray[k]); // k数值减小继续向上浮 k /= 2; } } // 向下沉 void sink(int k) { while (2 * k \u003c= m_length) { // 由于堆的性质父节点为k则其左子树为2*k即j int j = 2 * k; // 这里先比较左子树和右子树的大小，将最大的那个键记录下来再和父节点比较 if (j \u003c m_length \u0026\u0026 (pArray[j] \u003c pArray[j + 1])) j++; // 和父节点比较如果父节点比最大的子节点还要大，则直接退出循环 if (pArray[k] \u003e pArray[j]) break; // 如果父节点比子节点小则交换 swap(pArray[k], pArray[j]); // k值变大继续下沉 k = j; } } }; // 实现myvector template\u003ctypename T\u003e class myvector{ public: typedef T value_type; typedef T* iterator; private: value_type* _data; size_t _size; size_t _capacity; public: myvector():_data(NULL),_size(0),_capacity(0){} ~myvector(){ delete [] _data; _data = NULL; _size = 0; _capacity = 0; } myvector(const myvector\u0026 vec){ _size = vec._size; _capacity = vec._capacity; _data = new value_type[_capacity]; for(int i=0;i\u003c_size;++i){ _data[i] = vec._data[i]; } } myvector\u0026 operator=(const myvector\u0026 vec){ if(this == \u0026vec) return *this; value_type* temp = new value_type[vec._capacity]; for(int i=0;i\u003cvec._size;++i){ temp[i] = vec._data[i]; } delete [] _data; _data = temp; _size = vec._size; _capacity = vec._capacity; return *this; } void push_back(value_type val){ if(0 == _capacity){ _capacity = 1; _data = new value_type[1]; }else if(_size+1 \u003e _capacity){ _capacity *= 2; value_type* temp = new value_type[_capacity]; for(int i=0;i\u003c_size;++i){ temp[i] = _data[i]; } delete [] _data; _data = temp; } _data[_size] = val; ++_size; } size_t size()const{ return _size;} == 0;} value_type\u0026 operator[](size_t index){ return _data[index]; } void erase(iterator it){ size_t index = it - _data; for(int i=index;i\u003c_size-1;++i){ _data[i] = _data[i+1]; } --_size; } iterator begin(){ return _data; } iterator end(){ return _data + _size; } }; // 找到最短路 void dijkstra( int from, bool v","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:4:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-5 Hand-made Cream 知识点：动态规划 思路：考察从第1个面包bread[1]，选到第i个面包bread[i]和从cream[1]到cream[j]，乘积最大的搭配dp[i][j]，有如下情况： 如果将第i个面包和第j个面包搭配，那么dp[i][j] = dp[i-1][j-1] + bread[i]*cream[j]； 如果不搭配，那么等于前一个面包，或者前一个冰淇淋的结论，即dp[i][j] = dp[i-1][j]或者dp[i][j] = dp[i][j-1] 因为要求最大的值，所以综合一下：dp[i][j] = max(dp[i-1][j-1]+bread[i]*cream[j],dp[i-1][j],dp[i][j-1]) 初始化dp[0][0]=0,dp[1][0]=0,dp[0][1]=0，用两个循环，动态更新一下dp表就可以啦，下面是题目样例最终得到的dp表： bread\\cream 10 8 11 9 -1 0 0 0 0 10 100 100 110 110 8 100 164 188 188 代码： #include \u003ciostream\u003eusing namespace std; int max(int a, int b, int c){ if(a \u003e= b \u0026\u0026 a \u003e= c) return a; else{ if(b \u003e= c)return b; else return c; } } int max(int a, int b){ if(a \u003e= b) return a; else return b; } int main() { int N, M; cin \u003e\u003e N \u003e\u003e M; int a[1005], b[1005]; for( int i=0; i\u003cN; i++ ) cin \u003e\u003e a[i+1]; for( int i=0; i\u003cM; i++ ) cin \u003e\u003e b[i+1]; int dp[1005][1005], res = 0; for( int i=1; i\u003c=N; i++ ){ for( int j=1; j\u003c=M; j++ ){ dp[i][j] = max(dp[i-1][j-1]+a[i]*b[j], dp[i-1][j], dp[i][j-1]); cout \u003c\u003c dp[i][j] \u003c\u003c \" \" ; res = max(res, dp[i][j]); } cout \u003c\u003c endl; } cout \u003c\u003c res; return 0; } ","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:5:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"工欲善其事 必先利其器 有一说一，Clion真的很好用，非常智能的代码提示和代码补全是应付语法复杂的c++语言的有力工具。 ","date":"2022-07-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/:6:0","tags":null,"title":"数据结构与算法实习第二阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"},{"categories":["书影记录"],"content":"《乡土中国》由费孝通先生的14篇论文组成，其内容是对中国社会基本结构的深入剖析。其中《差序格局》一篇最让我印象深刻。该书并不难读，但若要想全部理解还需花点功夫。在这里我是浅读后浅记一下笔记，防止读完后一无所获。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"乡土本色 总体介绍乡土中国 土气（指泥土，我们的民族从泥土里长出来光荣的历史，当然也要受到土的束缚） 不流动 聚村而居 熟人社会\u003c-\u003e陌生人社会 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"文字下乡 文盲 != 愚蠢：乡下人不知道怎么应付汽车，这是知识问题，不是智力问题。 面对面的社群交流不需要文字。 但还是应当推行文字下乡。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"再论文字下乡 文字的发生是在人和人传情达意的过程中受到空间和时间的阻隔。前文说了空间的阻隔，这篇说时间的阻隔。 个人的今昔之隔 社会的世代之隔：历世不移 只有乡土性的基层发生了变化后，文字才能下乡。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"差序格局 公与私 差序格局与团体格局 以“己”为中心，像石子一般投入水中，像水的波纹一般一圈圈推出去，愈推愈远，也愈推愈薄。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"系维着私人的道德 继续分析团体格局和差序格局的区别。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"家族 家庭的结构：亲子，家庭的功能：生育 事业社群，主轴在父与子、婆媳之间，是纵向的。夫妇是配角。=\u003e 夫妇之间会有矜持和保留。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"男女有别 乡土社会和现代社会在感情定向上的差别 亚普罗式（Apollonian） —\u003e 接受 —\u003e 乡土社会 浮士德式（Faustian）—\u003e 创造 —\u003e 现代社会 为了秩序的维持，一切足以引起破坏秩序的要素都被遏制着。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"礼治秩序 所谓人治和法治之别，不在“人”和“法“这两个字上，而是在维持秩序时所用的力量，和所根据的规范的性质 乡土社会主要是礼治，礼并不是靠一个外在的权力来推行的，而是从教化中养成了个人的敬畏之感，使人服膺； ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:8:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"无讼 因为乡土社会是一个礼治社会而不是法治社会，认为打官司是一种可羞之事，表示教化不够。 现行的司法制度在乡间发生了很特殊的副作用，它破坏了原有的礼治秩序，但并不能有效地建立起法治程序。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"无为政治 偏重于社会冲突：横暴权力 偏重于社会合作：同意权力 乡土社会是皇权的发祥地。为了皇权自身的维持，在历史的经验中，找到了“无为”的生存价值，确立了无为政治的理想。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:10:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"长老统治 文化和政治的区别是在这里：凡是被社会不成问题地加以接受的规范，是文化性的; 当一个社会还没有共同接受一套规范，各种意见纷呈，求取临时解决办法的活动是政治。 文化的基础必须是同意的，但文化对于社会的新分子是强制的，是一种教化过程。 乡土社会相互对待的态度是根据长幼之序。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"血缘与地缘 血缘社会就是想用生物上的新陈代谢作用——生育，去维持社会结构的稳定。 在稳定的社会中，地缘不过是血缘的投影。 地缘是从商业里发展出来的社会关系。 血缘是身份社会的基础，而地缘却是契约社会的基础。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:12:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"名实的分离 在中国旧式家庭中生长的人都明白家长的意志怎样在表面的无违下，事实上被歪曲的。虚伪在这种情境中不但是无可避免而且是必需的。 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:13:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"从欲望到需要 乡土社会 =\u003e 经验 =\u003e 欲望 现代社会 =\u003e 知识 =\u003e 需要 ","date":"2022-07-01","objectID":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:14:0","tags":null,"title":"《乡土中国》读书笔记","uri":"/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["刷题","笔记"],"content":"7-1 符号配对 知识点：栈 思路：先输入数据，将所有的符号保存下来，其它的可以丢掉。然后遍历，用tmp保留当前的符号，遇到左符号，压栈，当遇到右括号，把它跟栈顶元素做比较，有如下情况： 如 [ { ] ，右符号]与最近左符号{不匹配，说明{缺少正确右符号。 如 ]{，右符号]左边没有符号，说明缺少正确左符号[。 如{]，第一不匹配的是{ ，右符号]与左符号{不匹配，说明{缺少右符号} 所以如果遇到不匹配的情况，设置flag=1，退出遍历。接下来判断： 如果栈是空的，且flag==0，那我们输出yes 如果栈为空，但是flag标记了1，那我们输出tmp 如果栈不是空的，输出栈顶即可 代码： #include\u003ciostream\u003eusing namespace std; class MyStack { private: char *stk; //起始地址 int top; //始终指向栈顶元素 int MAXN;//栈的最大存储容量 public: MyStack(int size) ; //构造函数，初始化一个栈时需要指定初始大小 ~MyStack() ;//析构函数 int push(char x); int pop(); char getTop(); int isEmpty ()const; }; MyStack::MyStack(int size) { MAXN = size; stk = new char[MAXN]; top = -1; } MyStack::~MyStack() { delete stk; } int MyStack::push(char x) { if (top \u003e= MAXN - 1)return -1; stk[++top] = x; return 0; } int MyStack::pop() { if (top == -1)return 0; // *x = stk[top--]; top--; return 1; } char MyStack::getTop() { if (top == -1)return NULL;//null要大写 return stk[top]; } int MyStack::isEmpty()const { return top == -1; } int main() { // 保存符号 char str[300]; char signs[300]; int signsPos = -1; while(cin.getline(str,300)){ if(str[0]=='.' \u0026\u0026 !str[1]){ break; } for(int i=0; str[i]; i++) { if(str[i]=='(' || str[i]== '[' || str[i]=='{' || str[i]==')' || str[i]=='}' || str[i]==']'){ signs[++signsPos] = str[i]; } else if(str[i]=='/' \u0026\u0026 str[i+1]=='*') { signs[++signsPos] = 'l';// 将/*替换为l i++; } else if(str[i]=='*' \u0026\u0026 str[i+1]=='/') { signs[++signsPos] = 'r'; i++; } } } // 判断 MyStack myStack(300); int flag=0; char tmp; for(int i=0; i\u003c=signsPos; i++) { if(signs[i]=='(' || signs[i]=='{' || signs[i]=='[' || signs[i]=='l') { myStack.push(signs[i]); } else if(signs[i]==')') { char top = myStack.getTop(); if(top=='('){ myStack.pop(); } else { tmp=signs[i]; flag = 1; break; } } else if(signs[i]=='}') { char top = myStack.getTop(); if(top == '{'){ myStack.pop(); } else { tmp = signs[i]; flag = 1; break; } } else if(signs[i]==']') { char top = myStack.getTop(); if(top=='['){ myStack.pop(); } else { tmp = signs[i]; flag = 1; break; } } else if(signs[i] == 'r') { char top = myStack.getTop(); if(top == 'l') { myStack.pop(); } else { tmp = signs[i]; flag = 1; break; } } } if(!flag \u0026\u0026 myStack.isEmpty()) printf(\"YES\\n\"); else { printf(\"NO\\n\"); if(!myStack.isEmpty()) { char top = myStack.getTop(); if(top == '['){ printf(\"[-?\\n\"); } else if(top == '('){ printf(\"(-?\\n\"); } else if(top == '{'){ printf(\"{-?\\n\"); } else if(top == 'l'){ printf(\"/*-?\\n\"); } } else { if(tmp ==']'){ printf(\"?-]\"); } else if(tmp == ')'){ printf(\"?-)\"); } else if(tmp == 'r'){ printf(\"?-*/\"); } else if(tmp == '}'){ printf(\"?-}\"); } putchar('\\n'); } } return 0; } ","date":"2022-06-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/:1:0","tags":null,"title":"数据结构与算法实习第一阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-2 网红点打卡攻略 类型：模拟 思路：按照题目要求来就行了。 细节： 使用邻接矩阵存储路径。 路费使用long long储存。 用数组vis[105]记录已搜索的节点。 代码： // // Created by 孙百乐 on 2022/6/25. // #include\u003ciostream\u003eusing namespace std; class HotSpots { public: int N; int M; int **path; HotSpots(int N, int M); ~HotSpots(); void insertPath(int a, int b, int cost); int getCost(int a, int b); // 不存在路径，返回-1 long long isValid(int *a, int n); // 无效返回0，有效，返回所有花费 }; HotSpots::HotSpots(int n, int m) { N = n; M = m; path = new int*[205]; for(int i=0;i\u003c205;i++){ path[i] = new int[205]; } } HotSpots::~HotSpots() { delete path; } void HotSpots::insertPath(int a, int b, int cost) { if(a \u003c b){ path[a][b] = cost; }else{ path[b][a] = cost; } } int HotSpots::getCost(int a, int b) { if(a \u003c b){ return path[a][b]; }else{ return path[b][a]; } } long long HotSpots::isValid(int *arr, int n) { // cout \u003c\u003c \"arr[i]\"; // for(int i=0;i\u003cn;i++){ // cout \u003c\u003c arr[i] \u003c\u003c ' '; // } // cout \u003c\u003c endl; if(n!=N)return 0; bool vis[205] = {false}; int pre = 0; long long sum = 0; bool flag = true; for(int i=0; i\u003cn; i++){ if(this-\u003egetCost(pre, arr[i]) \u0026\u0026 !vis[arr[i]]){ sum += this-\u003egetCost(pre, arr[i]); pre = arr[i]; vis[arr[i]] = true; } else { flag = false; } } if(this-\u003egetCost(arr[n-1],0) \u0026\u0026 flag){ sum += this-\u003egetCost(arr[n-1], 0); } else { // cout \u003c\u003c \"NO\"; return 0; } return sum; } int main(){ int N, M; cin \u003e\u003e N \u003e\u003e M; HotSpots hotSpots(N, M); // 输入路径 for(int i=0; i\u003cM; i++){ int a, b, cost; cin \u003e\u003e a \u003e\u003e b \u003e\u003e cost; hotSpots.insertPath(a, b, cost); } // 开始判断 int minIndex, validCnt=0; long long minCost = 1e9 + 1; int lines; cin \u003e\u003e lines; for (int i=0; i\u003clines; i++){ int n; cin \u003e\u003e n; int *arr = new int[n]; for(int j=0;j\u003cn;j++){ cin \u003e\u003e arr[j]; } long long curCost = hotSpots.isValid(arr, n); if(curCost \u003e 0){ validCnt++; if(curCost \u003c minCost){ minIndex = i; minCost = curCost; } } } cout \u003c\u003c validCnt \u003c\u003c endl; cout \u003c\u003c minIndex+1 \u003c\u003c \" \" \u003c\u003c minCost; return 0; } ","date":"2022-06-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/:2:0","tags":null,"title":"数据结构与算法实习第一阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-3 树的同构 知识点：二叉树及其遍历、递归 思路：对于输入数据，先构建树，找到其根节点（入度为0）。 树的存储结构： struct TreeNode { char Element; int Left; int Right; } T1[10], T2[10]; 递归地判断是否同构，输入两树的根节点，有如下情况： 两颗树都是空，返回true 一棵为空，另一棵不为空，返回false 根节点不同，返回false 左子树同时为空，递归判断右子树 左子树不为空且左边元素相同，递归判断左子树\u0026右子树 左子树不为空且左边元素不同，递归判断左子树\u0026右子树（交换顺序） 代码： #include \u003cstdio.h\u003e// 参考数据结构-浙江大学https://www.bilibili.com/video/BV1JW411i731?p=39\u0026vd_source=e483d09b4b274b0564d9461541870776 #define Null -1 struct TreeNode { char Element; int Left; int Right; } T1[10], T2[10]; int BuildTree(struct TreeNode T[]){ int N, Root = Null; int *check = new int[N]; for(int i=0;i\u003cN;i++) check[i]=0; scanf(\"%d\\n\", \u0026N); if(N){ int cl,cr; for(int i=0; i\u003cN; i++){ scanf(\"%c %c %c\", \u0026T[i].Element, \u0026cl, \u0026cr); getchar(); if(cl != '-'){ T[i].Left = cl - '0'; check[T[i].Left] = 1; } else T[i].Left = Null; if(cr != '-'){ T[i].Right = cr - '0'; check[T[i].Right] = 1; } else T[i].Right = Null; } for(Root=0; Root\u003cN; Root++) if (!check[Root]) break; } return Root; } bool Isomorphic(int R1, int R2){ if (R1 == Null \u0026\u0026 R2 == Null){ // 两颗树都是空 return true; } if (((R1 == Null)\u0026\u0026(R2 != Null ) || ((R1 != Null)\u0026\u0026(R2 == Null)))){ // 一棵为空，另一棵不为空 return false; } if (T1[R1].Element != T2[R2].Element) // 根节点不同 return false; if (T1[R1].Left == Null \u0026\u0026 T2[R2].Left == Null) // 左子树同时为空 return Isomorphic(T1[R1].Right, T2[R2].Right); if ((T1[R1].Left!=Null \u0026\u0026 T2[R2].Left!=Null) \u0026\u0026 (T1[T1[R1].Left].Element == T2[T2[R2].Left].Element)) // 左子树不为空且左边元素相同 return Isomorphic(T1[R1].Left, T2[R2].Left) \u0026\u0026 Isomorphic(T1[R1].Right,T2[R2].Right); else return Isomorphic(T1[R1].Right, T2[R2].Left) \u0026\u0026 Isomorphic(T1[R1].Left, T2[R2].Right); } int main() { int R1, R2; R1 = BuildTree(T1); R2 = BuildTree(T2); if(Isomorphic(R1, R2)) printf(\"Yes\\n\"); else printf(\"No\\n\"); return 0; } ","date":"2022-06-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/:3:0","tags":null,"title":"数据结构与算法实习第一阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-4 最短工期 知识点：拓扑排序 思路： 用邻接矩阵储存路径，用degrees[105]记录节点的入度。 以下是拓扑排序的过程：不断找出入度为0的点，记录个数cnt，然后标记为-1（不重复访问），直到没有入度为0的点为止。 在这个过程中，用f[105]记录从初始节点到当前节点的最长路径，比如f[i]表示从初始节点到第i个节点的最长路径。（动态规划的思想） 最后判断，如果cnt == N，即所有任务都能被完成，输出最长路径，否则输出impossible 细节: 因为存在值为0的边，所以邻接矩阵的初始值赋值为-1，表示不能到达 f[105]赋初始值为0 已搜索过的入度为0的点，标记为-1，防止重复搜索 代码： #include \u003ciostream\u003e#include \u003cstdio.h\u003eusing namespace std; class Project { public: int N, M; int path[105][105]; int degrees[105]; Project(int N, int M); ~Project(); void insertPath(int from, int to, int weight); int findFarthest(); // 如果有任务不能完成，返回0，否则返回最长路径 }; Project::Project(int n, int m) { N = n; M = m; for(int i=0; i\u003c105; i++){ for(int j=0; j\u003c105; j++){ path[i][j] = -1; // 不能等于0，因为存在两节点连通但是距离为0 } } for(int i=0; i\u003c105; i++) degrees[i]=0; } Project::~Project() { } void Project::insertPath(int from, int to, int weight) { path[from][to] = weight; degrees[to]++; } int Project::findFarthest() { // cout \u003c\u003c \"degress\" \u003c\u003c endl; // for(int i=0;i\u003c105;i++){ // cout \u003c\u003c degrees[i] \u003c\u003c ' '; // } // cout \u003c\u003c endl; // cout \u003c\u003c \"N \" \u003c\u003c N \u003c\u003c endl; int cnt=0, res=0; int f[105]; for(int i=0;i\u003c105;i++)f[i]=0; while(1) { int flag = 0; for(int i=0; i\u003cN; i++) { if(degrees[i] == 0) { degrees[i] = -1; //防止重复计算 flag = 1; //是否存在新的入度为0的点 // cout \u003c\u003c \"rudu\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c endl; cnt++; //入度为0点也就是加入拓扑序列的总个数 for(int j=0; j\u003cN; j++) if(path[i][j] != -1) { degrees[j]--; //入度减一 f[j] = max(f[j], f[i] + path[i][j]); res = max(res, f[j]); } } } // cout \u003c\u003c \"flag\" \u003c\u003c flag \u003c\u003c endl; if(flag == 0) break; } if(cnt != N) return 0; else return res; } int main() { int N, M; cin \u003e\u003e N \u003e\u003e M; Project p(N, M); for(int i=0; i\u003cM; i++){ int from, to, weight; cin \u003e\u003e from \u003e\u003e to \u003e\u003e weight; p.insertPath(from, to, weight); } int res = p.findFarthest(); // cout \u003c\u003c \"res\" \u003c\u003c res \u003c\u003c endl; if (res) { cout \u003c\u003c res; } else { cout \u003c\u003c \"Impossible\" \u003c\u003c endl; } // cout \u003c\u003c \"wanshierle\"; return 0; } ","date":"2022-06-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/:4:0","tags":null,"title":"数据结构与算法实习第一阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"},{"categories":["刷题","笔记"],"content":"7-5 三足鼎立 知识点：快速排序/堆排序、二分法 思路：输入数组arr[]，先将数组排序，遍历每个元素，对于arr[i]：已知三角形的两边有P和arr[i]，则第三边的范围是P-arr[i] \u003c 第三条边 \u003c P+arr[i]。用二分法搜索，从左到右第一个比P-arr[i]大的点的位置left，和从右到左第一个比P+arr[i]小的点的位置right，如果right - left \u003e= 0，那么符合要求的节点的个数就是right - left + 1，累计一下这个值。 细节： left = myUpperBound(P-arr[i]\u003e=0?P-arr[i]:arr[i]-P, arr, i+1, n-1); // 从左向右，第一个大于左边界的数 right = myLowerBound(P+arr[i], arr, i+1, n-1) - 1; // 从右向左，第一个小于右边界的数 如果P-arr[i] \u003c 0，则换成arr[i] - P 排序使用堆排序，时间复杂度O(nlogn) 代码： #include \u003ciostream\u003eusing namespace std; long long myLowerBound(long long target, long long *arr, long long start, long long last){ last+=1; while (start \u003c last) { long long mid = (start + last) / 2; if (arr[mid] \u003e= target) { last = mid; } else { start = mid + 1; } } return start; } long long myUpperBound(long long target, long long *arr, long long start, long long last){ last += 1; while (start \u003c last) { long long mid = (start + last) / 2; if (arr[mid] \u003c= target) { start = mid + 1; } else { last = mid; } } return start; } // 下浮 void Heapify(long long arr[], int n, int i){ // arr 存储堆的数组，n 数组长度， i 维护节点的下标 int largest = i; // 假设最大节点 int lson = 2 * i + 1; int rson = 2 * i + 2; if (lson \u003c n \u0026\u0026 arr[largest] \u003c arr[lson]){ largest = lson; } if (rson \u003c n \u0026\u0026 arr[largest] \u003c arr[rson]){ largest = rson; } if(largest != i){ long long tmp; tmp = arr[largest]; arr[largest] = arr[i]; arr[i] = tmp; Heapify(arr, n, largest); } } // 堆排序入口 void HeapSort(long long arr[], int n){ // 建堆，从底往上构建 int i; for(i = n / 2 - 1; i \u003e= 0; i--){ // 从最后一个元素的父节点开始 Heapify(arr, n, i); } // 排序 for(i = n - 1; i \u003e 0; i--){ long long tmp; tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; Heapify(arr, i, 0); } } int main() { long long n, cnt = 0; long long P; cin \u003e\u003e n \u003e\u003e P; long long arr[100005]; for(long long i=0; i\u003cn; i++){ cin \u003e\u003e arr[i]; } HeapSort(arr, n); // qsort(arr, n, sizeof(arr[0]), cmpfunc); // cout \u003c\u003c \"test\" \u003c\u003c myLowerBound(0, arr, 0, n-1) \u003c\u003c endl; for( long long i=0; i\u003cn-1; i++ ){ // cout \u003c\u003c i \u003c\u003c \" \"; long long left = myUpperBound(P-arr[i]\u003e=0?P-arr[i]:arr[i]-P, arr, i+1, n-1); // 从左向右，第一个大于左边界的数 long long right = myLowerBound(P+arr[i], arr, i+1, n-1) - 1; // 从右向左，第一个小于右边界的数 if(right \u003e= left) cnt += right-left+1; // cout \u003c\u003c arr[i]\u003c\u003c\" \"\u003c\u003cP-arr[i] \u003c\u003c \"left\"\u003c\u003c left \u003c\u003c \" \" \u003c\u003c P+arr[i]\u003c\u003c \"right\" \u003c\u003c right \u003c\u003c \" \"\u003c\u003c right-left \u003c\u003c endl; } cout \u003c\u003c cnt; return 0; } ","date":"2022-06-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/:5:0","tags":null,"title":"数据结构与算法实习第一阶段","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"},{"categories":["技能分享","笔记"],"content":"需求 从网上down了一个《飞鸟集》的txt文件，其内容是这样的 Stray Birds 飞鸟集 1 Stray birds of summer come to my window to sing and fly away. And yellow leaves of autumn, which have no songs, flutter and fall there with a sigh. 夏天的飞鸟，飞到我窗前唱歌，又飞去了。 秋天的黄叶，它们没有什么可唱，只叹息一声，飞落在那里。 2 O troupe of little vagrants of the world, leave your footprints in my words. 世界上的一队小小的漂泊者呀，请留下你们的足印在我的文字里。 3 The world puts off its mask of vastness to its lover. It becomes small as one song, as one kiss of the eternal. 世界对着它的爱人，把它浩瀚的面具揭下了。 它变小了，小如一首歌，小如一回永恒的接吻。 4 It is the tears of the earth that keep her smiles in bloom. 是“地”的泪点，使她的微笑保持着青春不谢。 5 The mighty desert is burning for the love of a blade of grass who shakes her head and laughs and flies away. 广漠无垠的沙漠热烈地追求着一叶绿草的爱，但她摇摇头，笑起来，飞了开去。 6 If you shed tears when you miss the sun, you also miss the stars. 如果错过了太阳时你流了泪，那么你也要错过群星了。 7 The sands in your way beg for your song and your movement, dancing water. Will you carry the burden of their lameness? 跳舞着的流水呀，在你途中的泥沙，要求你的歌声，你的流动呢。你肯挟跛足的泥沙而俱下么？ 8 Her wistful face haunts my dreams like the rain at night. 她的热切的脸，如夜雨似的，搅扰着我的梦魂。 9 Once we dreamt that we were strangers. We wake up to find that we were dear to each other. 有一次，我们梦见大家都是不相识的。 我们醒了，却知道我们原是相亲爱的。 总共325段（上面只截取了9段），每天要给女朋友发一段，用邮件的形式。因为是重复性操作，所以诉诸于代码实现。 所以做一个数据处理，用正则表达式把每一段提取出来，写成json文件，格式如下： { \"1\": \"Stray birds of summer come to my window to sing and fly away. And yellow leaves of autumn, which have no songs, flutter and fall there with a sigh.\\n\\n\\n\\n夏天的飞鸟，飞到我窗前唱歌，又飞去了。\\n\\n秋天的黄叶，它们没有什么可唱，只叹息一声，飞落在那里。\", \"2\": \"O troupe of little vagrants of the world, leave your footprints in my words.\\n\\n\\n\\n世界上的一队小小的漂泊者呀，请留下你们的足印在我的文字里。\", \"3\": \"The world puts off its mask of vastness to its lover. It becomes small as one song, as one kiss of the eternal.\\n\\n\\n\\n世界对着它的爱人，把它浩瀚的面具揭下了。\\n\\n它变小了，小如一首歌，小如一回永恒的接吻。\", \"4\": \"It is the tears of the earth that keep her smiles in bloom.\\n\\n\\n\\n是“地”的泪点，使她的微笑保持着青春不谢。\", \"5\": \"The mighty desert is burning for the love of a blade of grass who shakes her head and laughs and flies away.\\n\\n\\n\\n广漠无垠的沙漠热烈地追求着一叶绿草的爱，但她摇摇头，笑起来，飞了开去。\", \"6\": \"If you shed tears when you miss the sun, you also miss the stars.\\n\\n\\n\\n如果错过了太阳时你流了泪，那么你也要错过群星了。\", \"7\": \"The sands in your way beg for your song and your movement, dancing water. Will you carry the burden of their lameness?\\n\\n\\n\\n跳舞着的流水呀，在你途中的泥沙，要求你的歌声，你的流动呢。你肯挟跛足的泥沙而俱下么？\", \"8\": \"Her wistful face haunts my dreams like the rain at night.\\n\\n\\n\\n她的热切的脸，如夜雨似的，搅扰着我的梦魂。\", \"9\": \"Once we dreamt that we were strangers. We wake up to find that we were dear to each other.\\n\\n\\n\\n有一次，我们梦见大家都是不相识的。\\n\\n我们醒了，却知道我们原是相亲爱的。\" } ","date":"2022-06-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E9%A3%9E%E9%B8%9F%E9%9B%86/:1:0","tags":null,"title":"正则表达式提取《飞鸟集》","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E9%A3%9E%E9%B8%9F%E9%9B%86/"},{"categories":["技能分享","笔记"],"content":"实现 regex101.com，这个网站真是太好用了。 因为我用的是python，进去之后记得选择python，把文件复制进去，就可以编辑正则表达式了。 代码可以点Code Generator生成，不过不太好用，可以作为参照。 代码： 因为正则表达式中的特殊符号会被博客无情转译，所以放图片不放文本了。 顺便记录一下两日期相差天数的代码： import time past = time.mktime(time.strptime(\"2022-06-29 00:00:00\",\"%Y-%m-%d%H:%M:%S\")) now = time.time() delta_day = int((now-past)/(24*60*60)) print(delta_day) 保存为json文件，中文不乱码 import json with open(\"Birds.json\",'w',encoding = 'utf-8') as file_obj: json.dump(res,file_obj,ensure_ascii=False,indent = 4) ","date":"2022-06-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E9%A3%9E%E9%B8%9F%E9%9B%86/:2:0","tags":null,"title":"正则表达式提取《飞鸟集》","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E9%A3%9E%E9%B8%9F%E9%9B%86/"},{"categories":["技能分享","随笔杂记"],"content":"准备物资 6月22日，班级组织了一次团建，去轰趴馆（一个双层别墅，有烧烤、厨房、KTV、游戏机、投影仪、麻将、台球等等的地方）早上十点到达，晚上五点离开，吃一个中午饭。因为我对这些玩的东西不感兴趣，想自己动手做一做吃的，所以找了几个人一起做烧烤吃。我列出了要买物品的清单，跟小伙伴一起去超市购买。小伙伴都非常靠谱，到轰趴馆之后有人负责串，有人负责烤，大家其乐融融。最后我还露了一手，整了烤面包，大家吃了都说好吃～ 整一个10人烧烤，需要以下物资： 烧烤架：轰趴馆提供，如图： 木炭：拼多多购入10斤竹炭，45元，买多了只用了一半； 签子：铁签100支，串五花肉，约20元；木签300支，6.8元，便宜量大； 去超市购买食材，肉类需要腌制，让超市里卖肉的师傅帮忙切一下腌一下： 牛肉1～2斤； 羊肉2斤； 猪肉（五花肉）2斤； 鸡翅18个； 土豆2、3个，买圆一点的； 蘑菇（口菇），一小盒就行； 面筋（没买到）； 金针菇、豆皮。豆皮可以包着金针菇烤； 鸡蛋、炼乳、白糖、黄油、蜂蜜、白芝麻、面包（吐司）。做烤面包； 盒装烧烤料、烧烤酱、色拉油、酱油； 刷子； 最后肉没吃完，炭也没烤完，总共花了500块钱，平均每个人才50元，蛮划算的！ ","date":"2022-06-23","objectID":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:1:0","tags":null,"title":"组织一次成功的班级烧烤经验分享","uri":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享","随笔杂记"],"content":"开烤！ 牛肉不需要烤全熟，烤太久烤老了就不好吃了； 五花肉很肥，但是很香，能吃的都说好吃； 烤土豆有技巧，要刷酱油，上b站看教程； 烤面包看这个教程，简单又好吃！ ","date":"2022-06-23","objectID":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:2:0","tags":null,"title":"组织一次成功的班级烧烤经验分享","uri":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享","随笔杂记"],"content":"相册 ","date":"2022-06-23","objectID":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:3:0","tags":null,"title":"组织一次成功的班级烧烤经验分享","uri":"/posts/%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E7%8F%AD%E7%BA%A7%E7%83%A7%E7%83%A4%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["技能分享","笔记"],"content":"需求 最近跟正则表达式杠上了。有这样一个需求，我的博客文章是用typora写的，markdown格式的语法插入图片的表达是这样的： ![](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/IMG_1562%20%E5%A4%A7.jpeg) 但是这样渲染出的图片不能居中，也不能缩放，我得把它转换成博客主题的格式： \\{\\{\u003c figure src=\"https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/IMG_1562%20%E5%A4%A7.jpeg\" \u003e\\}\\}（为了防止渲染原文没有\\斜杠） 思路很简单，但不能简单的使用python的replace函数，因为不仅要匹配![]()，还要匹配括号里的url ","date":"2022-06-17","objectID":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/:1:0","tags":null,"title":"使用正则表达式进行高级替换","uri":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/"},{"categories":["技能分享","笔记"],"content":"代码 可以拿这个网站试一试：https://regex101.com 点左边FUNCTION里的Substitution，就是替换模式 TOOLS里的Code Generator可以生成代码（不过python的代码不太好用） # 匹配字符串 r\"!\\[.*\\]\\((https:\\/\\/myblog.*)\\)\" # 替换字符串 '/{/{\u003c figure src=\"\\\\1\" \u003e/}/}'（为了防止渲染原文没有/斜杠） 这里面的\\\\1就表示匹配字符串里用括号包围起来的那部分，replace是没有这种功能的。 完整代码： import os import re path = \"\" # 文件夹路径 file = \"\" # 文件名 with open(os.path.join(path, file),\"r\") as f: all_text = f.read() res = re.sub(r\"!\\[.*\\]\\((https:\\/\\/myblog.*)\\)\", '/{/{\u003c figure src=\"\\\\1\" \u003e/}/}', all_text, 0, re.MULTILINE) # （为了防止渲染原文没有/斜杠） with open(os.path.join(path, file),\"w\") as f: f.write(res) ","date":"2022-06-17","objectID":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/:2:0","tags":null,"title":"使用正则表达式进行高级替换","uri":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/"},{"categories":["技能分享","笔记"],"content":"re.sub def sub(pattern, repl, string, count=0, flags=0): \"\"\"Return the string obtained by replacing the leftmost non-overlapping occurrences of the pattern in string by the replacement repl. repl can be either a string or a callable; if a string, backslash escapes in it are processed. If it is a callable, it's passed the match object and must return a replacement string to be used.\"\"\" return _compile(pattern, flags).sub(repl, string, count) 1）pattern：该参数表示正则中的模式字符串； （2）repl：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数； （3）string：该参数表示要被处理（查找替换）的原始字符串； （4）count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换； （5）flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。 re.MULTILINE:多行模式 ","date":"2022-06-17","objectID":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/:3:0","tags":null,"title":"使用正则表达式进行高级替换","uri":"/posts/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%9B%BF%E6%8D%A2/"},{"categories":["技能分享"],"content":"需求 一个212页的word文档，包含如下反复出现的单元： 2022.2.2 英语1902班王彤 每日一词∣快递包装绿色治理 green governance of express packaging 来源：中国日报网 国家邮政局发展研究中心近日发布《中国邮政快递业绿色发展报告（2019-2020年）》。报告称，2019年我国在快递包装绿色治理方面取得显著成效，行业正加速构建绿色发展体系。到2025年年底，全国范围邮政快递网点禁止使用不可降解的塑料包装袋、塑料胶带和一次性塑料编织袋。 China made remarkable progress on the green governance of express packaging in 2019, with a more environment-friendly development framework taking shape, according to a recent report on the green development of China's post and express industry. Compiled by the development and research center of the State Post Bureau, the report reaffirmed the country's plan to cease the use of non-degradable plastic packaging, plastic tape, and single-use plastic woven bags at postal and express service outlets by 2025. 【知识点】 2019年，我国快递业务量完成635.2亿件，同比增长25.3%，连续6年稳居世界第一。随着电商快递的快速发展，产生的快递包装废弃物问题引起各界关注，推进快递包装绿色治理刻不容缓。 为了适应新形势新要求，推进快递包装绿色治理，国家邮政局坚持系统治理，强化责任分工和部署落实，印发了《2020年行业生态环境保护工作要点》，围绕快递包装绿色治理明确年度工作任务和措施，提出实施“9792”工程，即“瘦身胶带”封装比例达90%，电商快件不再二次包装率达70%，循环中转袋使用率达90%，新增2万个设置标准包装废弃物回收装置的邮政快递网点。 下一步，国家邮政局将制定出台《邮政业绿色发展行动计划（2021—2025）》，明确未来五年的目标任务和主要措施，确定路线图。同时，将深入推进责任落实，指导各地邮政管理部门认真履行监管责任，加快建立与绿色理念相适应的法律标准和政策体系，加强监督管理和行政执法，推动寄递企业落实主体责任，推动落实邮政业污染治理的地方属地责任。 【重要讲话】 要倡导环保意识、生态意识，构建全社会共同参与的环境治理体系，让生态环保思想成为社会生活中的主流文化。要倡导尊重自然、爱护自然的绿色价值观念，让天蓝地绿水清深入人心，形成深刻的人文情怀。 We need to raise people's awareness, develop a conservation system in which everyone plays a part, and mainstream ecological conservation into every aspect of social life. We need to advocate the value of green development that reveres and cares for nature so that blue skies, green fields and clear waters will be a vision cherished by all. ——2019年4月28日，习近平在2019年中国北京世界园艺博览会开幕式上的重要讲话 绿水青山就是金山银山，贯彻创新、协调、绿色、开放、共享的发展理念，加快形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，给自然生态留下休养生息的时间和空间。 Lucid waters and lush mountains are invaluable assets. China must pursue the vision of innovative, coordinated, green and open development that is for everyone, accelerate forming spatial patterns, industrial structures, production and living modes that are resource-saving and environmental-friendly, and provide time and space for the natural ecology to rehabilitate. ——2018年5月19日，习近平在全国生态环境保护大会上的重要讲话 【相关词汇】 绿色发展 green development 遏制环境破坏 curb environmental damage 现将其中的 2022.2.2 英语1902班王彤 每日一词∣快递包装绿色治理 green governance of express packaging ... 【相关词汇】 绿色发展 green development 遏制环境破坏 curb environmental damage 保留，中间省略号部分删除。使用正则表达式可以轻松解决这个问题： 每日一词.*\\n[a-zA-Z\\s]+([\\s\\S]*)【相关词汇】 使用上面的正则表达式就能匹配到需要删除的内容，替换成空格就好了。 However, 用编程语言操作word是比较麻烦的，不如使用word自带的查找替换功能。word自带的查找替换支持使用通配符，类似正则表达式，但功能比较简单。它与正则表达式有如下不同： 只支持懒惰匹配，即匹配最小长度的文本 一些符号不同，比如*表示任何一段文本 那么我们考察一下如何使用吧！ ","date":"2022-06-16","objectID":"/posts/%E5%9C%A8word%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2/:1:0","tags":null,"title":"在word中使用通配符进行高级的查找和替换","uri":"/posts/%E5%9C%A8word%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2/"},{"categories":["技能分享"],"content":"解决方案 注意，我们并不是要把匹配到的所有内容都替换掉，而是只替换所匹配内容中的一部分。这在正则表达式里只需要加两个括号就能解决，在word里不可以！ 我想到一个办法，就是先匹配上文，即 每日一词∣快递包装绿色治理 green governance of express packaging 然后在它后面加上abcdefg（自己随便弄的标识） 每日一词∣快递包装绿色治理 green governance of express packaging abcdefg 同理，匹配下文，在前面加上abcdefg abcdefg 【相关词汇】 最后再匹配两个abcdefg中的内容，替换成空白就可以啦。原本在正则表达式中一个步骤就能搞定的，在word中拆成三个步骤也是可以解决的。 下面是我所使用的通配符 查找内容 每日一词*^13*^13 替换为 ^\u0026abcdefg 查找内容 【相关词汇】 替换为 abcdefg^\u0026 查找内容 abcdefg*abcdefg 替换为 其中，^13表示回车，^\u0026表示查找内容 ","date":"2022-06-16","objectID":"/posts/%E5%9C%A8word%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2/:2:0","tags":null,"title":"在word中使用通配符进行高级的查找和替换","uri":"/posts/%E5%9C%A8word%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2/"},{"categories":["书影记录"],"content":"写给大家看的设计书 本书作者是美国著名设计师Robin Williams，Mac爱好者（因为我也喜欢Mac，所以强调一下这个）。 这是一本写给非设计专业人士看的设计科普类数据，介绍了有关设计的四个基本原则、颜色运用、字体搭配等内容。语言通俗易懂，由易到难，循序渐进，逻辑清晰，有丰富的图片和案例，是一本写的非常好的科普书籍，谁看了都能从书里学到点什么。 ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"约书亚树 当作者偶然知道家门口的那种树的名字叫“约书亚树”时，她才会注意到它，认识它，了解它。所以说，想弄明白任何问题，首先搞清楚问题的定义。 ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"四大基本原则 这是一个相当乏味但很典型的报告封面： 亲密性：把相关的项组合到一起，使结构清晰。 对齐：使整个页面清爽整齐。 重复：增加条理性，引导视觉。 对比：引人注目。 ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"颜色运用 以下都是能用的上的小常识，没有很强的理论性！ 色轮 颜色关系（互补、三色组… 暗色和亮色 单色、色质 暖色与冷色 CMYK与RGB ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"具体情景 包装 企业名片 信笺和信封 传单 新闻简报 宣传册 明信片 报纸广告 网站（一点点 ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"字体设计 什么是字体的衬线？Oldstyle、Modern、Sans serif 等字体你一定使用过，但你仔细观察过它们的特点吗？ 虽然这一部分介绍的都是英文字体，但仍然非常值得一读～ ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"告诉你一个小技巧 “告诉你一个方法，这是我们在图形设计课上经常使用的技巧，如果一个客户坚持他自己拙劣的设计，不想再认真考虑你更精美的作品，就可以采用这个技巧。展示他的设计时先搞得一团糟。比如（有意）洒点咖啡上去，把边缘弄得参差不齐，划上钢笔印，放得不整齐，诸如此类。展示你认为更棒的设计时则要做得干净漂亮，用非常好的纸张打印，把它们贴在展示板上，覆一层保护膜等。这样一来，大多数情况下客户都会考虑你的作品，并相信你的作品确实比他原先的想法更好，而且由于他是一个 VIP*（而你已经脱离这个行列），他无法指出自己为什么做不到这么好，只知道你的设计看上去更棒。告诉别人这是我说的。） VIP：未经过视觉训练的人” 摘录来自 写给大家看的设计书（第 4 版） [美] Robin Williams ","date":"2022-06-14","objectID":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:0","tags":null,"title":"《写给大家看的设计书》读书笔记","uri":"/posts/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["技能分享"],"content":"Vue 之前有小程序开发基础，上手Vue稍微容易一点，但也走了很长一段路。学习框架，理解逻辑是最重要的，一旦理解了逻辑，写代码就可以听着歌边查文档边写了。前端框架逻辑都差不多，一通百通，很开心能掌握这项技术。 我的学习路线： 先了解web基础知识，比如http，get，post请求等等 了解html，css，js等前端基础知识（非常基础，我甚至没写过一行css代码 看b站的手把手教学视频（非常长，只需要看一部分就可以啦 看Vue官方文档（不建议新手直接看，很难懂 Vue官方文档：https://cn.vuejs.org/ 一个案例（后台管理系统： 教学视频：https://www.bilibili.com/video/BV14y4y1M7Nc?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click 源代码：https://gitee.com/xqnode/springboot-vue-demo ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:1:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"Vue Cli Vue的脚手架工具，配合编译器Vscode就可以拿来直接开发Vue啦 同样是看b站手把手教学视频，官方文档，搜索引擎搜索问题 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:2:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"ElementUI https://element.eleme.io/ 大名鼎鼎的UI工具，不用手写样式啦 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:3:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"通信axios，解决跨域问题 前后端通信，主流的解决方案是使用axios，视频里有演示如何在Vue里使用axios，也非常方便。 跨域问题是由于浏览器为了安全性拒绝向其它ip或端口的地址发送请求，vue的解决方案是它帮你在后台发送请求，部署的时候用nginx可以非常方便的解决 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:4:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"后端Flask 直接看官方文档，很简单好用，做小项目速度起飞 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:5:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"数据库 团队项目用腾讯云或阿里云云MySQL数据库，一年也就几块钱 小项目直接SQLite，开发速度起飞 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:6:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["技能分享"],"content":"部署 我针的针的没想到我能一次性部署成功～ 首先把前端build一下 npm run build 产生dist文件夹，直接拖到服务端（我使用的是ubuntu 配置nginx（要改的地方已标出 server { listen 80; server_name 你的server_name，ip or 域名; location ^~ /api { rewrite ^/api/(.*)$ /$1 break; # 解决跨域，路径替换，把前端中的/api替换掉 proxy_pass http://localhost:9090; # 后端地址 add_header Access-Control-Allow-Methods *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Headers $http_access_control_request_headers; if ($request_method = OPTIONS ) { return 200; } } location / { root /home/ubuntu/sgjyb/vue2/dist; # 前端路径 index index.html index.htm; add_header 'Access-Control-Allow-Origin' '*'; try_files $uri $uri/ /index.html; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 然后可以测试一下能不能访问 最后部署后端：在服务器上装python=\u003e上传后端到服务器=\u003e运行 可以使用screen让它一直保持运行 ","date":"2022-05-24","objectID":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/:7:0","tags":null,"title":"解锁新技术栈vue+flask前后端分离","uri":"/posts/%E8%A7%A3%E9%94%81%E6%96%B0%E6%8A%80%E6%9C%AF%E6%A0%88vue+flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"categories":["随笔杂记"],"content":"最近在读《挪威的森林》，可能是受主人公渡边漫无目的的生活态度所影响，我也变得很佛系，不想把大量时间放在学习和工作上，没有期中会儿那种争分夺秒的感觉了。 最近交了个朋友（一个学姐），她是一个很有想法的人，一起散了两次步，聊了很多跟其它朋友不一样的内容，挺有意思的。 明天又是周一了，work day，重新开始努力学习和工作吧！ ","date":"2022-05-22","objectID":"/posts/%E6%9C%80%E8%BF%91%E7%9A%84%E6%B8%B8%E7%A6%BB%E7%8A%B6%E6%80%81/:0:0","tags":null,"title":"最近的游离状态","uri":"/posts/%E6%9C%80%E8%BF%91%E7%9A%84%E6%B8%B8%E7%A6%BB%E7%8A%B6%E6%80%81/"},{"categories":["技能分享","笔记"],"content":"为什么要使用jwt验证？ jwt（json web token）主要用来解决单点登录（SSO）问题。设想一个场景，你在淘宝登录了你的账号，然后打开天猫（天猫属于淘宝的子网站），那么你需不需要重新登录呢？答案是不用，你会发现天猫。在一个站点登录后，在其它子站点就不需要重复登录，这就是单点登录。 传统的方法用session解决，session保存在服务端，记录用户的登录信息。然而像淘宝这种大型网站往往有多个服务器，服务器之间需要session共享才能实现上述功能。 jwt能较好解决这个问题。用户登录完成后，由服务端签发一个token，包含了用户登录信息，过期时间等等。然后把它加密发给用户，用户下次请求的时候把它放在请求头传给服务端，服务端经过愉快的解密就可以知道用户已经登录啦！ 在我的小项目当中，用户登录只需要密码，用session不好处理，所以也采用了jwt验证方法。 ","date":"2022-05-22","objectID":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/:1:0","tags":null,"title":"Flask+vue使用jwt验证","uri":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/"},{"categories":["技能分享","笔记"],"content":"Flask后端代码 pip install pyjwt import jwt app.secret_key = b'secret_key' @app.route(\"/login\", methods=[\"POST\"]) def login(): if request.method == 'POST': print(\"password\",request.json['password']) token = jwt.encode({'exp': datetime.now(tz=timezone.utc) + timedelta(seconds=3600), 'password':request.json['password']}, current_app.config['SECRET_KEY'], algorithm=\"HS256\") # 生成token print(token) return jsonify(err=\"已生成token\", token=token) # 装饰器函数 def login_required(func): @functools.wraps(func) # 修饰内层函数，防止当前装饰器去修改被装饰函数的属性 def inner(*args, **kwargs): print(\"token\",request.headers.get('token'),type(request.headers.get('token'))) if request.headers.get('token')!='null': password = jwt.decode(request.headers.get('token'), current_app.config['SECRET_KEY'], algorithms=\"HS256\")['password'] # print(password) if password == '123': return func(*args, **kwargs) else: return jsonify(err=\"无效token\") else: return jsonify(err=\"请输入密码\") return inner ","date":"2022-05-22","objectID":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/:2:0","tags":null,"title":"Flask+vue使用jwt验证","uri":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/"},{"categories":["技能分享","笔记"],"content":"Vue前端代码 前端需要用到cookies，把token保存在浏览器里 npm install vue-cookies --save main.js import VueCookies from 'vue-cookies' Vue.use(VueCookies) app.js created(){ // 设置cookies 30天后过期 this.$cookies.config('30d') // window object window.$cookies.config('30d') } 保存token到cookies里 request.post('/login',{\"password\":value}).then(res=\u003e{ that.$cookies.set(\"token\",res['token'])} 在请求头里携带token发送请求 request.post(\"/submit_edit\", this.form, {headers:{token: this.$cookies.get('token')}}) ","date":"2022-05-22","objectID":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/:3:0","tags":null,"title":"Flask+vue使用jwt验证","uri":"/posts/flask+vue%E4%BD%BF%E7%94%A8jwt%E9%AA%8C%E8%AF%81/"},{"categories":["笔记"],"content":"《学术研究，你的成功之道》 ","date":"2022-05-07","objectID":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/:0:0","tags":null,"title":"《学术研究，你的成功之道》","uri":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/"},{"categories":["笔记"],"content":"格雷准则 如何判断一个好问题？ 格雷准则是由图灵奖得主Jim Gary, 在1999年图灵奖颁奖典礼上提出的一个好的问题应该具备的几个条件。 1. 有明显的益处； 测试描述简单可以用“电梯描述法”看能否在1分钟之内将问题意义清楚明白的讲出来。 2. 描述简单； 3. 尚且不具备明确的解法； 4. 解决方案具备可测试性，大问题可以拆解为多个子问题，能观察到每个子问题的进程；拒绝开盲盒。 在上述四点之外，本书作者提出了第五个针对现在计算机领域的一个条件 5. 要确保研究中数据获取的可靠性以及足够数量； 对于机器学习领域应该不陌生，一个好的研究，应当能够提供更好的预测能力和解释能力，足够多的优质数据能够大大增强研究结果的说服力。我自己认为除了增加研究说服力，可靠的数据本身也是算法研究的导航系统之一，如果验证集错了，评价指标也成了无源之水，根本无法确定算法改进是否真的有效。 ","date":"2022-05-07","objectID":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/:1:0","tags":null,"title":"《学术研究，你的成功之道》","uri":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/"},{"categories":["笔记"],"content":"棋盘法 棋盘法可以清晰有条理地刻画出研究工作的大体脉络，从而便于见缝插针的找到新的研究课题。 如下图所示，由一个4*4的棋盘构成，其中横轴代表研究领域用到的不同方法、方案和技术，纵轴代表要解决的研究问题，或者潜在的研究问题。在排布方面，具有相关性的研究问题要安顺序排放，无相关性问题可以随意排放。 举例而言，在目标检测领域，研究子领域可以分为密集目标检测，小样本目标检测，样本不平衡问题目标检测，连续学习目标检测等，方法上则包括loss设计，backbone设计，feature fusion， sampling机制设计等。然后根据已有的方法和对应的问题向棋盘中下子。调研完成后，可以看看哪个棋盘格子还是空着的，这就是很好的研究机会。把方法当做锤子，把领域当做钉子，用不同的方法在这个钉子上面进行尝试，说不定就是一个尚未开采的研究金矿。 该笔记正在修改…. ","date":"2022-05-07","objectID":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/:2:0","tags":null,"title":"《学术研究，你的成功之道》","uri":"/posts/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%BD%A0%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93/"},{"categories":["书影记录"],"content":"《从零开始的女性主义》 “女性主义”其实就是“女权主义”，只不过后者在大家的印象里有贬义的意味，所以换了一种说法。“女权”这个词在近几年特别火，有很多人抨击，也总有人为它辩护，还有人趁乱在其中捣鬼。那么为什么会产生女权主义呢？它到底是怎样的斗争呢？我很好奇，所以去阅读了这本豆瓣热榜第一名的《从零开始的女性主义》。 《从零开始的女性主义》的作者是【日本】上野千鹤子、田房永子。其中上野千鹤子是东京大学人文社会学系教授，号称日本女性主义理论第一人。这本书以两位女士对话的形式向我们阐述了上野千鹤子关于女性主义的种种观点，语言朴素直白还配有漫画，读起来蛮有趣。 ","date":"2022-05-06","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"《从零开始的女性主义》读后有感","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"我的感受 上个世纪60年代，日本经济高速发展，也是日本女权主义运动的顶峰时期，当时大学生就有示威游行，甚至引发暴力冲突的，后来日本经济泡沫崩盘，女权主义渐渐偃旗息鼓了。而近几年，中国的经济也高速增长，正值社会发生快速变化的时候，并且中国和日本的传统文化也有很大相似之处，比如“女德”、“妇道”等都大相径庭，所以中国和日本的女权主义有相似的土壤，这也是为什么这本介绍日本女权的书在中国得到的反响很大。 书的第一章有一个观点是“女性的第一个敌人是自己的母亲”。这个我深有体会，因为我的姐姐和我妈妈就有非常多的矛盾，而且这些矛盾是根深蒂固地埋在两代人生存的土壤里的，几乎无法调和。而我和我妈妈的矛盾要小得多，我也确实觉得我妈妈更偏爱我一点。但也不能以偏概全，身边也有很多的女性朋友，她们和妈妈的关系非常要好，像亲姐妹、好闺蜜一样可以在一起拍照，旅行，聊天。能跟女儿相处的很好的母亲一定是一个能够跳出传统思维的，思想开明的母亲。 女权主义到底在反抗什么，争取什么？她们是想要成为男人，和男人一样工作，服兵役吗？还是说要男人对她们百依百顺，统治男人吗？都不是。以上提到的都是极端的、狭隘的女权主义，是明显站不住脚的。但是多人都会对女权主义产生类似的误解。真正的女权主义者承认自己的是弱势的一方，她们并不想和男人一争高下，而是想要获得男人的尊重。比如你可能听过这样评论：“你被人摸还不是因为裙子太短。”被性骚扰，结果还要受到这种指责，换作是谁都会感觉被严重冒犯。穿裙子只是为了展现美，人人都有追求美的权利，不管裙子长短，错的并不是裙子，错都在于犯罪的人啊。说这种话，是在骨子里对女性的轻蔑，在现代社会，这样的人少了很多，但是依然存在，女权主义者正是要反抗这样的人，争取得到尊重。 随着社会的进步，人们思想意识的提升，女性的地位提升了很多，男女平等的观念深入人心，尤其是在中国，男女之间的矛盾不再那么尖锐了，但是有一种代代相传的东西，叫“直男式的思维”，或者说“大叔式的思维”，仍然根深蒂固。比如： 上野：某些人会毫无根据地认定自己是对方深爱的人。如果他喜欢的女性对他不理不睬，就会一厢情愿地解释成“她太害羞”“她不敢主动示好”，或是“有人阻碍了我和她的关系，我必须清除障碍”，总之一切都要符合自己的妄想。你瞧瞧这种自大！简直太男人了（笑）。一部分东大男生明明没有过恋爱经验，却对自己有着盲目自信，认为“只要我愿意，随时都能找到结婚对象”。我觉得太厉害了。 田房：是有那种人！有人亲口对我说过：“我是东大出身，又在大企业工作，工资这么高，却找不到女朋友，这太奇怪了！” 上野：他们认为奇怪的不是自己，而是女人。 读到这里的时候我有种上课被老师点名的尴尬，我也是才发现原来自己也有一点“叔味”。这种“直男式的思维”是目前女权主义者主要反抗的对象，不过这种反抗要温和的多，不会像以前那样搞运动，顶多是批判或者不理睬罢了。 总的来说，读完这本书后我刷新了对女性主义的认知，也成为了女性主义的肯定者之一。我认为这也是社会发展的趋势，说不定以后的社会真会像《三体》里描述的那样全体女性化呢。 ","date":"2022-05-06","objectID":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"《从零开始的女性主义》读后有感","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/combination-sum/ 做回溯题就像见老同学，你觉得它还像以前一样简单，但是你错了😭 ","date":"2022-05-06","objectID":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode39:组合总和——回溯","uri":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-05-06","objectID":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode39:组合总和——回溯","uri":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"搜索回溯 思路：对于candidates中的每一个数你有两个选项，要么选，要么不选。所以回溯的过程是一颗二叉树，用idx表示下标，左子树表示选择第idx个数放入路径，右子树不选择。如果不选择，下一次是idx+1，如果选择，下一次仍然是idx，这样可以做到重复选择一个数，但最终结果不会有数字相同但顺序不同的情况。 先看代码： class Solution: def combinationSum(self, candidates: List[int], target: int) -\u003e List[List[int]]: path = [] res = [] def backtrack(target, idx): if idx \u003e len(candidates)-1: return print(\"tar\",target,\"n\",candidates[idx],\"path\",path) if target == 0: res.append(path.copy()) return # 不选择 backtrack(target, idx+1) # 选择 if target-candidates[idx]\u003e=0: path.append(candidates[idx]) backtrack(target-candidates[idx], idx) path.pop() backtrack(target, 0) return res 标准的回溯模板，但又充满了细节： return要放在合适的位置 不选择的时候idx+1，选择的时候idx不+1 再看这张图就能理解了： ","date":"2022-05-06","objectID":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode39:组合总和——回溯","uri":"/posts/leetcode39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/ 约瑟夫环问题非常经典，记得大一学c++程序设计的时候遇到过这题，当时貌似没有做出来，现在就游刃有余了。 ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:1:0","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:2:0","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["刷题"],"content":"朴素的模拟法 即真正按照题目的描述，维护一个初始长度为n的数组和计数变量cnt，迭代找到最终解。最朴素的方法，一般都会超时。 ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:2:1","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["刷题"],"content":"模拟+队列 使用队列来模拟这个过程，首先创建一个双端队列（python中有此数据结构），包括n个数。然后在接下来的n-1次迭代中每次从队首pop出k-1个数到队尾。最终剩下的数就是答案。 class Solution: def findTheWinner(self, n: int, k: int) -\u003e int: q = deque(range(1, n + 1)) while len(q) \u003e 1: for _ in range(k - 1): q.append(q.popleft()) q.popleft() return q[0] 因为要执行n-1轮，每轮把k-1个数从队首拿到队尾，所以时间复杂度为O(nk)。和第一种方法差不多，但代码更简洁。 ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:2:2","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["刷题"],"content":"直接pop 对上面的方法进行优化，也是我采用的方法。就是在每轮迭代中省去计数这个过程，直接找到要pop的数。 class Solution: def findTheWinner(self, n: int, k: int) -\u003e int: people = [i for i in range(1,n+1)] kick = 1 while(len(people)!=1): kick = (kick-1+k)%len(people) if kick==0:kick=len(people) people.pop(kick-1) print(kick,end=\" \") print(people) return people[0] 细节： 记录上一次杀掉的人的位置为kick（从1开始计数），那么下一次从第kick人开始计k个数，它的位置是kick+k-1。 但考虑到是一个环，所以要把位置mod当前数组的长度。 mod时有一个问题，如果位置恰好是最后一个元素，mod结果为0，所以加一个判断条件，如果结果为0，就令它等于len(people)。 因为我们分析的位置是从1开始计数，所以pop的时候要-1 由于pop的时间复杂度比较高，所以这也不是一种十分优雅的方法。 ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:2:3","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["刷题"],"content":"数学+递归/数学+迭代 递归公式 f(n,m)=(f(n-1,m)+m)%n f(n,m)指n个人，报第m个编号出列最终编号 这个推理没搞懂…题解：https://leetcode-cn.com/circle/article/BOoxAL/ 时间复杂度O(n) ","date":"2022-05-04","objectID":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:2:4","tags":null,"title":"Leetcode1823:找出游戏的获胜者——约瑟夫环","uri":"/posts/leetcode1823%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["随笔杂记"],"content":"前言 今年影响我们最大的事情就是疫情的反弹，导致学期初无法正常上课。等到课程恢复时又到了期中，体测、考试等都被推迟，本来就漫长煎熬的期中阶段变得更加漫长煎熬了。学期初的时候我写了篇blog，当时立的flag完成的不错，所以今天再立一次。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"梳理上半学期 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"学习、工作以及生活 这学期的学习我更加注重培养自己的基本能力，比如编程能力，数学能力。最值得拿出来说的一件事就是我坚持每天做一道编程题已经坚持了50天，我感觉我的算法能力在潜移默化中已经有了质的提升。 工作方面，社团的学生工作、导师的任务、竞赛、入党的事务、班级事务、英语作业、毛概视频等等，我唯恐避之不及。我觉得这些都是一些无聊的琐事。这样说未免有些太极端了，但我的心态确实如此。 生活方面，这学期因为疫情的影响，我两个半月都没有出校门，整天过着四点一线的生活（教室、食堂、寝室、操场）。甚至有一个多月连外卖都点不了，可以说是没有任何生活的情趣了。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:2:1","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"心态 心情真的很低沉，主要三点原因，一是跟我一个同导师同班级的女生关系闹的很僵，我作为男生，在表面上要保持大度，但心里其实很不爽。（多说一句，通过这件事我明白从此之后跟女生打交道要慎重！）二是长期的疫情导致的封校把我的生活压缩到极简，让我的思维也变得闭塞起来，就像上高中的时候一样压抑。三是恶心的、漫长的期中时期（4月份左右）让人窒息，期中时期有各种打扰人的杂事、工作、应酬，就像漫长的中世纪一样，只有等待它的结束才能看到曙光。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:2:2","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"规划下半学期 立flag吧： ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"学习 《可视化导论》这本书在期末前读完。要做读书笔记。 开始读论文。读的时候记一些东西，方便组会检查。这也和这学期学术英语课的要求一致，所以要把这件事的优先级提高。 学习机器学习。注重数学基础。 做题。优先级降低，大概是三天做一道中等题，写题解。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:3:1","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"工作 能推就推，能混就混。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:3:2","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"生活 读一些有意思的书，比如科普、哲学、思辩的，少读感伤的小说。 坚持锻炼，可以多跑跑步。 尽量在寝室里读一些书（虽然寝室很吵，但是能读多少是多少）。 ","date":"2022-05-03","objectID":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/:3:3","tags":null,"title":"期中梳理以及规划","uri":"/posts/%E6%9C%9F%E4%B8%AD%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%84%E5%88%92/"},{"categories":["书影记录"],"content":"作者 《无人生还》是英国作家女侦探小说家阿加莎·克里斯蒂，其一生写过80部推理小说，可谓著作等身，被誉为举世公认的侦探小说女王。《无人生还》写于1939年。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"情节 小说是以上帝视角叙述的，开头首先介绍了十位被“欧文”邀请到岛上的客人，他们的背景都截然不同，有法官、医生、警督等等，但他们有个共同的特点，就是这十位都是曾经有过命案但是逃脱法律制裁。他们彼此互不相识，无冤无仇，但是到达岛上的第二天就开始离奇的死人，大家既谨慎地保全自己，又想找到最终的凶手。 小说的标题以及故事开头出现的“童谣”都暗示了最后无人生还的结局。凶手究竟是谁呢？最后的花絮揭示了答案。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"阅读感受 五一假期，难得有一下午的时间坐在图书馆的沙发上一口气三个半小时看完这本悬疑推理小说。朋友对它评价很高，我看完之后感觉确实很有意思。对于这种小说，真正吸引人的地方不是严谨的推理，而是它所描绘的那种复杂的人物心理，和充满未知的剧情。现在有很多的影视作品都是类似“孤岛生存”的主题，比如饥饿游戏，鱿鱼游戏，这些可能或多或少都有借鉴这部将近100年前的作品。 最后一部分犯人的陈述中有一句耐人寻味： 我要写完了。我要把它密封进一个瓶子里,然后将这个瓶子抛人大海。 为什么要这么做呢？ 是呀，为什么呢？ 我的目的就是要发明一桩谁也解不开的谋杀谜。 但是，我现在意识到，面对艺术，没有一个艺术家愿意孤芳自赏的。不可否认，这里面有一种渴望得到别人认可和赏识的正常心理。 这种心理可能跟我写博客一样，我不想自己把文章拿给别人去炫耀，而是写好了放在博客上，等待有心人去欣赏。 ","date":"2022-04-30","objectID":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:3:0","tags":null,"title":"《无人生还》读后有感","uri":"/posts/%E6%97%A0%E4%BA%BA%E7%94%9F%E8%BF%98%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/permutations/ 全排列问题也是比较经典的问题，其所用的交换法也很巧妙。 ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"纯dfs 首先想到的办法，不用回溯，每次递归传参都是数组的复制，空间复杂度很大，但是时间复杂度和回溯法是相同的（应该）。 class Solution: def permute(self, nums: List[int]) -\u003e List[List[int]]: path = [] res = [] size = len(nums) def recursion(leftnums,path): if len(path)==size: res.append(path) else: for num in leftnums: new_path = path.copy() new_path.append(num) new_leftnums = leftnums.copy() new_leftnums.remove(num) recursion(new_leftnums, new_path) recursion(nums, path) return res ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"交换、回溯 在前面做过的回溯题中，比如Leetcode17:电话号码的字母组合、Leetcode113:路径总和，我们都是用栈来维护储存路径的数组，但是在这题当中我们用交换的方法来维护，很巧妙啊！ 有两个变量first和i。在每一次递归当中，0～first是已确定的路径，i是与first交换的数的位置。看下图： 代码（c++的stl里有swap函数，写出的代码更简洁） class Solution { public: void backtrack(vector\u003cvector\u003cint\u003e\u003e\u0026 res, vector\u003cint\u003e\u0026 output, int first, int len){ if(first==len){ res.emplace_back(output); return; } for(int i=first;i\u003clen;i++){ // 动态维护数组 swap(output[i], output[first]); // 继续递归填下一个数 backtrack(res, output, first+1, len); // 撤销操作 swap(output[i], output[first]); } } vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e res; backtrack(res, nums, 0, (int)nums.size()); return res; } }; ","date":"2022-04-29","objectID":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/:2:2","tags":null,"title":"Leetcode46:全排列——交换、回溯","uri":"/posts/leetcode46%E5%85%A8%E6%8E%92%E5%88%97%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ 终于能自己做出一道题了😭，之前的回溯题没白刷 ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"回溯 思路：先用哈希表储存数字对应的字母，然后用回溯法记录搜索路径。 画个图帮助理解： 代码： class Solution: def letterCombinations(self, digits: str) -\u003e List[str]: if digits==\"\": return [] tel = {\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"} size = len(digits) path = [] res = [] def backtracking(i, path, res): for letter in tel[digits[i]]: path.append(letter) if i==size-1: res.append(\"\".join(path)) path.pop() else: backtracking(i+1, path, res) path.pop() backtracking(0, path, res) return res 时间复杂度：O(3^m * 4^n)，m是电话键盘上有三个字母对应的数的个数，n是电话键盘上有四个字母对应的数的个数。需要遍历一遍所有的组合。 空间复杂度：O(m+n)，主要为记录路径的开销，路径最长也只有len(digits) ","date":"2022-04-27","objectID":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode17:电话号码的字母组合——回溯","uri":"/posts/leetcode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/3sum-closest/ ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"排序+双指针 这道题的官方题解写的太好了：https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/ 我总结一下： 思路是在暴力搜索枚举i，j，k 三个指针的基础上发展来的。首先要对数组进行排序，因为： 不排序的话，数组没有规律，只能暴力搜索，没有可操作空间。 排序完就可以在搜索过程中优化，相当于剪枝。 以升序为例，排完序后先枚举i，对于剩下的j和k，令j=i+1，k=nums.size()-1： 如果三数之和 \u003e target，则左移k。 如果三数之和 \u003c target，则右移j 如果三数之和 = target，直接返回target。 代码： class Solution { public: int threeSumClosest(vector\u003cint\u003e\u0026 nums, int target) { sort(nums.begin(), nums.end()); int res=nums[0]+nums[1]+nums[2]; for(int i=0;i\u003cnums.size()-2;i++){ int j=i+1, k=nums.size()-1; while(j\u003ck){ int cur_sum = nums[i]+nums[j]+nums[k]; if(abs(cur_sum-target)\u003cabs(res-target)){ res = cur_sum; } if(cur_sum\u003ctarget){ j++; } else if(cur_sum\u003etarget){ k--; } else{ return cur_sum; } } } return res; } }; 时间复杂度O(N^2)，空间复杂度O(logN)，主要为排序的空间。 ","date":"2022-04-26","objectID":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode16:最接近的三数之和——排序、双指针","uri":"/posts/leetcode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/container-with-most-water/ 每次看题解：“我又会了！” 下一题：“我是废物。” ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"双指针 定义两个指针left和right分别在最左边和最右边，指向两个柱子，那么面积肯定等于两柱子中最小的柱子乘上宽度。 求出面积后要移动指针，那么移动哪一个指针呢？当然是指向柱子中较矮的那个指针。因为如果移动高的珠子，宽度减小，而由于短板效应，高度仍取决于矮柱子，所以移动后的面积只减不增。 那如果两指针指向柱子的高度相同呢？那就两个指针一起向中间移动，原理同上。 代码： class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int max_area = 0; int left=0,right=height.size()-1; while(left\u003cright){ if(height[left]\u003cheight[right]){ max_area = max(max_area, height[left]*(right-left)); left++; } else if(height[left]\u003eheight[right]){ max_area = max(max_area, height[right]*(right-left)); right--; } else{ max_area = max(max_area, height[left]*(right-left)); left++; right--; } } return max_area; } }; 相比于暴力搜索，这种方法相当于是剪枝，把不可能的情况都嘎掉了。 时间复杂度O(n)，空间复杂度O(1)。 ","date":"2022-04-25","objectID":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode11:盛水最多的容器——双指针","uri":"/posts/leetcode11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/network-delay-time/ 关于最短路径dijkstra算法，学了很多遍，每次学的都不深，所以学完就忘，代码肯定更是写不出来。今天再学一次。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 关于dijkstra算法具体内容就不在这里细说了，网上一大堆，这里主要关注代码。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"代码 class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: g = [[float('inf')]*n for _ in range(n)] for x, y, time in times: g[x-1][y-1] = time dist = [float('inf')] * n dist[k-1] = 0 used = [False] * n for _ in range(n): x = -1 for y, u in enumerate(used): if not u and (x == -1 or dist[y] \u003c dist[x]): x = y used[x] = True for y,time in enumerate(g[x]): dist[y] = min(dist[y], dist[x]+time) ans = max(dist) return ans if ans \u003c float('inf') else -1 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"代码详解 g[][]：用邻接矩阵来储存这个图。g[x][y]表示从节点x到节点y的距离。如果不能到达，储存距离为无穷大。注意这段代码中把所有的节点都-1，这只是表示方式的问题，不重要。 这段代码就是在构建g： g = [[float('inf')]*n for _ in range(n)] for x, y, time in times: g[x-1][y-1] = time dist[]：dist[i]表示从起点k到节点i的最短距离（当前已知）。赋初值为无穷大。 used[]：记录算法运行时使用过的节点。初值是把起始节点赋值为True，其余False。 for y, u in enumerate(used): if not u and (x == -1 or dist[y] \u003c dist[x]): x = y used[x] = True 上面这段代码，每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。x就是要找的那个已确定节点，第一次x=k。 for y,time in enumerate(g[x]): dist[y] = min(dist[y], dist[x]+time) 用节点 A「更新」节点 B 的意思是，用起点到节点 A 的最短路长度加上从节点 A 到节点 B 的边的长度，去比较起点到节点 B 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。这里节点A就是x，节点B就是y。 最后根据这题的要求，找dist[]里最大的返回就行了。 时间复杂度：O(n^2+m)，其中 m 是数组times 的长度。 空间复杂度：O(n^2)。邻接矩阵需占用 O(n^2)的空间。 dijkstra算法的时间复杂度为O(n^2) ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"用小根堆优化 可以使用一个小根堆来寻找「未确定节点」中与起点距离最近的点。 这个具体就不研究了，能把基本算法搞明白就不错了😂。 ","date":"2022-04-21","objectID":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"Leetcode743:网络延迟时间——dijkstra算法","uri":"/posts/leetcode743%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4dijkstra%E7%AE%97%E6%B3%95/"},{"categories":["刷题","笔记"],"content":"题目 题目：在二维坐标系中，给你两条线段的四个端点坐标，问如何判断两条线段是否相交？ 初步分析：我们知道，对于直线来说不平行就相交，非常好判断。但是对于线段来说，有共线相交，共线不相交，不共线相交，不共线不相交等情况。我们要找到一个优雅的办法，把所有的情况都能考虑到。下面介绍两步就能判断的方法： ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:1:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"第一步：快速排斥实验 **如果两线段在x，y的投影都不重合，是不可能会相交的。**换一种说法，就是以两条线段为对角线画矩形，两矩形如果没有重合的地方，那么两线段也一定不相交。 假设给出的四个点为Ax1, Ay1,Ax2,Ay2,Bx1,By1,Bx2,By2，代码如下： max(Ax1,Ax2)\u003e=min(Bx1,Bx2)\u0026\u0026min(Ax1,Ax2)\u003c=max(Bx1,Bx2)//判断x max(Ay1,Ay2)\u003e=min(By1,By2)\u0026\u0026min(Ay1,Ay2)\u003c=max(By1,By2)//判断y 除此之外，这一步还能排除一个特殊情况：共线不相交 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:1:1","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"第二步：跨立实验 先了解一个线性代数知识：叉积 向量A和向量B叉积，如果AxB\u003e0，那么B在A的逆时针方向，如果AxB\u003c0，那么B在A的顺时针方向。如果AxB=0，那么B与A共线。 图我就不画了，很好理解，AxB = a*b*sin(theta) 把端点移到原点，向量(x1,y1)与向量 （x2，y2）的叉积为 x1*y2-x2*y1 然后对于两直线相交的情况，我们发现它有一个性质，就是向量A1B1叉乘向量A1A2的符号一定与向量A1B2叉乘向量A1A2的符号相反。为了方便写代码，我们把其中一个端点移到零点。 代码： if( ( (Bx1-Ax1)*(Ay2-Ay1)-(By1-Ay1)*(Ax2-Ax1) ) * //判断B是否跨过A ( (Bx2-Ax1)*(Ay2-Ay1)-(By2-Ay1)*(Ax2-Ax1) ) \u003c=0 \u0026\u0026 ( (Ax1-Bx1)*(By2-By1)-(Ay1-By1)*(Bx2-Bx1) ) * //判断A是否跨过B ( (Ax2-Bx1)*(By2-By1)-(Ay2-By1)*(Bx2-Bx1) ) \u003c=0 ) 还有一种特殊的情况，一条线段的端点在另一条线段上，这样的话A1B1与A1A2的叉积为0，我们只要把判断条件加一个等于号就行了。 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:2:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题","笔记"],"content":"完整代码 bool judge(int Ax1,int Ay1,int Ax2,int Ay2,int Bx1,int By1,int Bx2,int By2) { if( ( max(Ax1,Ax2)\u003e=min(Bx1,Bx2)\u0026\u0026min(Ax1,Ax2)\u003c=max(Bx1,Bx2) )\u0026\u0026 //判断x轴投影 ( max(Ay1,Ay2)\u003e=min(By1,By2)\u0026\u0026min(Ay1,Ay2)\u003c=max(By1,By2) ) //判断y轴投影 ) { if( ( (Bx1-Ax1)*(Ay2-Ay1)-(By1-Ay1)*(Ax2-Ax1) ) * //判断B是否跨过A ( (Bx2-Ax1)*(Ay2-Ay1)-(By2-Ay1)*(Ax2-Ax1) ) \u003c=0 \u0026\u0026 ( (Ax1-Bx1)*(By2-By1)-(Ay1-By1)*(Bx2-Bx1) ) * //判断A是否跨过B ( (Ax2-Bx1)*(By2-By1)-(Ay2-By1)*(Bx2-Bx1) ) \u003c=0 ) { return 1; } else return 0; } else return 0; } 参考资料：https://blog.csdn.net/NEFU_kadia/article/details/104462906 ","date":"2022-04-20","objectID":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/:3:0","tags":null,"title":"判断两条线段是否相交——快速排斥实验和跨立实验","uri":"/posts/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%9D%A1%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"遍历k次，取最小 思路：创建结果数组v，赋一个很大的初始值（s.size()+1就够了）。首先遍历一遍s，记录下每个c的位置ci。然后对于每个ci遍历一次s，如果abs(ci-当前位置) \u003c v[i]，那么就令v[i] = ci。最后得到的答案就是距离最近的。 代码： class Solution { public: vector\u003cint\u003e shortestToChar(string s, char c) { int size = s.size(); vector\u003cint\u003e v(size, size+1); vector\u003cint\u003e cv; for(int i=0;i\u003csize;i++){ if(s[i]==c){ cv.push_back(i); } } // cout \u003c\u003c \"cv:\"; // for(int i=0;i\u003ccv.size();i++){ // cout \u003c\u003c cv[i] \u003c\u003c \",\"; // } for(const int\u0026 ccv:cv){ for(int j=0;j\u003csize;j++){ if(abs(ccv-j)\u003cv[j]){ v[j]=abs(ccv-j); } } } return v; } }; 如果有k个c，那么就要遍历k+1遍。时间复杂度O((k+1)*n)。空间复杂度O(1)，返回数组不计入。 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:1","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"两次遍历 事实上，只需要两次遍历，一次从左到右遍历s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=i-idx。 从右往左遍历 s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=min(answer[i],idx−i)。 代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 −n 或 2n 表示，这里 n 是 s 的长度。 代码： class Solution { public: vector\u003cint\u003e shortestToChar(string s, char c) { int n = s.length(); vector\u003cint\u003e ans(n); for (int i = 0, idx = -n; i \u003c n; ++i) { if (s[i] == c) { idx = i; } ans[i] = i - idx; } for (int i = n - 1, idx = 2 * n; i \u003e= 0; --i) { if (s[i] == c) { idx = i; } ans[i] = min(ans[i], idx - i); } return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode-sol-2t49/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 虽然是道简单题，但我还是被秀了一脸。 ","date":"2022-04-19","objectID":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/:2:2","tags":null,"title":"Leetcode821:字符的最短距离——两次遍历","uri":"/posts/leetcode821%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/lexicographical-numbers/ 日常做不出来😭 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:1:0","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"题解 什么是字典序？（原谅我到了大二才搞明白什么是字典序😂） 对于字符串，先按首字符排序，如果首字符相同，再按第二个字符排序，以此类推。 如aa,ab,ba,bb,bc就是一个字典序。 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:0","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"dfs 我们可以画一棵树。 第一层设置为0。 第二层是1,2,3…,9 第三层是0,1,2,3,…,9 第四层及往后层都同第三层 深度优先遍历这棵树，记录路径就是答案啦。 当然了，把树具体化为代码其实是一件很难得事情： class Solution: def lexicalOrder(self, n: int) -\u003e List[int]: res = [] for i in range(1,10): if i \u003e n: break res.append(i) self.dfs(i, n, res) # 以i为开头枚举 return res def dfs(self, i, n, res): for k in range(0,10): val = i*10+k if val \u003e n: return else: res.append(val) self.dfs(val, n, res) 细节： 先枚举1,2,3…,9，因为第一个数不能为0。 在后面枚举时要把0加上。 时间复杂度O(n)，空间复杂度O(logn)，主要为栈的开销 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:1","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"迭代法 很有思维的一种方法！ 代码： class Solution: def lexicalOrder(self, n: int) -\u003e List[int]: ans = [0] * n num = 1 for i in range(n): ans[i] = num if num * 10 \u003c= n: num *= 10 else: while num % 10 == 9 or num + 1 \u003e n: num //= 10 num += 1 return ans 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/lexicographical-numbers/solution/zi-dian-xu-pai-shu-by-leetcode-solution-98mz/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-04-18","objectID":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/:2:2","tags":null,"title":"Leetcode386:字典序排数——dfs、迭代","uri":"/posts/leetcode386%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0dfs%E8%BF%AD%E4%BB%A3/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/longest-palindromic-substring/ ","date":"2022-04-17","objectID":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/:1:0","tags":null,"title":"Leetcode5:最长回文子串——中心扩展法","uri":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"},{"categories":["刷题"],"content":"题解 中心扩展法，看到这个名字我就知道该怎么做了，然后做了二十分钟….debug总是出问题… 这道题需要注意的细节： 回文子串长度既可以是奇数也可以是偶数，如果是奇数，那么它有一个中心，如果是偶数，则是两个中心。 那么代码思路就是先枚举中心，然后由中心向外扩展，直到不能扩展为止，记录下最大的扩展长度。 优雅的官方题解代码如下： class Solution: def expand(self, s, left, right): while left \u003e=0 and right \u003c len(s) and s[left] == s[right]: left -= 1 right += 1 return left+1, right-1 def longestPalindrome(self, s: str) -\u003e str: start, end = 0, 0 for i in range(len(s)): left1, right1 = self.expand(s, i ,i) left2, right2 = self.expand(s, i, i+1) if right1-left1 \u003e end - start: start, end = left1, right1 if right2-left2 \u003e end - start: start, end = left2, right2 return s[start: end+1] 太优雅了，我感觉这代码水平领先我至少刷一年题。 ","date":"2022-04-17","objectID":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/:2:0","tags":null,"title":"Leetcode5:最长回文子串——中心扩展法","uri":"/posts/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"},{"categories":["技能分享","笔记"],"content":"Git如何撤回远程仓库已经提交的版本？ 不能直接在像gitee, github这样的远程仓库上直接操作。所以先把项目clone下来。 执行 git log查看日志，获取需要回退的版本号 ，如5f6935bcc46d480113f0c49d4b54052d10c5aec0。 执行git reset --hard \u003c版本号\u003e，重置到这个版本。(此时相当于撤回了commit) –soft 表示只是改变了HEAD的指向，本地代码不会变化 –hard 表示本地代码也重置到此版本 执行 git push origin 分支名 –-force 强制提交。 如git push origin master –f 然后看远程仓库，你会惊喜的发现5f6935bcc46d480113f0c49d4b54052d10c5aec0之后的版本都消失啦！ ","date":"2022-04-16","objectID":"/posts/git%E6%92%A4%E9%94%80%E7%89%88%E6%9C%AC/:1:0","tags":null,"title":"Git撤销版本","uri":"/posts/git%E6%92%A4%E9%94%80%E7%89%88%E6%9C%AC/"},{"categories":["笔记"],"content":"read_csv()参数 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:1:0","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["笔记"],"content":"header header=None 读取时不设置表头 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:1:1","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["笔记"],"content":"drop() df.drop(0) 删除第一行 ","date":"2022-04-16","objectID":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:2:0","tags":null,"title":"Pandas使用技巧","uri":"/posts/pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/sort-characters-by-frequency/ ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:0","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"思路 用一个哈希map先统计每个字符出现的次数，然后再排序，最后拼接字符串。排序的方法多种多样，因为字符是有限的（26个小写，26个大写，0-9数字），所以使用桶排序是最好的选择。 ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:1","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"桶排序 假设你对2，5，3三个数字排序，最大的数字是5，所以你拿来五个桶，从头到尾遍历这三个数字。然后把数字放在相同标号的桶里，比如第一个数字是2，就把它放在标号为2的桶里，5就放在标号为5的桶，3就放在标号为3的桶里。最后再把1号到5号桶遍历，空的跳过，就完成了排序。典型的空间换时间，当已知不会消耗很大的空间时，桶排序无非是效率最高的。 具体做法如下： 遍历字符串，统计每个字符出现的频率，同时记录最高频率maxFreq； 创建桶，存储从 11 到 maxFreq 的每个出现频率的字符； 按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。 代码： class Solution { public: string frequencySort(string s) { unordered_map\u003cchar, int\u003e mp; int maxFreq = 0; int length = s.size(); for (auto \u0026ch : s) { maxFreq = max(maxFreq, ++mp[ch]); } vector\u003cstring\u003e buckets(maxFreq + 1); for (auto \u0026[ch, num] : mp) { buckets[num].push_back(ch); } string ret; for (int i = maxFreq; i \u003e 0; i--) { string \u0026bucket = buckets[i]; for (auto \u0026ch : bucket) { for (int k = 0; k \u003c i; k++) { ret.push_back(ch); } } } return ret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-by-l-zmvy/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：O*(n+*k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。 空间复杂度：O*(n+*k) ","date":"2022-04-15","objectID":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/:2:2","tags":null,"title":"Leetcode451:根据字符出现频率排序——桶排序","uri":"/posts/leetcode451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["书影记录"],"content":"故事简叙 《失乐园》 久木是一家出版社的编辑，人到中年，事业不会有进一步发展了，对家人的感情也是平平淡淡的，生活只是一日复一日，清闲无聊得很。 一次偶然的工作聚会上，久木认识了凛子，对她产生了兴趣。凛子30岁，正是端庄美丽之时，但她的婚姻生活并不美好，丈夫忙于工作，无论是在感情上还是在性上都不能满足凛子。但凛子并不是淫荡的女人，在认识久木之前，她也秉持着传统东方女人的内敛，羞涩与神秘，还有坚韧和倔强，直到认识久木之后，是久木带着她闯入了性爱的乐园唤醒了她对性与爱的渴望，坠入深渊之后，便一去不复返了。 两人最初是在镰仓旅馆里做云雨之事，这个时候久木是进攻者，凛子是防守者。看着凛子破防是久木的享受： “和女性同时达到高潮固然不错，但眼看着女性一步步走向顶点也另有其美妙的感觉。前者沉浸在自己的快乐中，后者则享有把所爱的女人送入极乐的境地，令她充分满足的握有主动权的喜悦。” 凛子的父亲去世了，呆在娘家守丧。久木按耐不住自己的欲望，死乞白赖地请求凛子抽空跟他见一面，凛子穿着丧服赴约后，久木命令她撩开裙摆插入…如此背德的事情，让性爱的快感更强烈了。二人就像同谋罪犯一样，命运更紧密地联合在一起了。 “男人和女人都清楚，眼前这无与伦比的美，发源于稀世罕见的粗俗和淫靡，而他们却甘愿堕人到那淫荡的世界中去。” 本来二人都以为这次偷情只是昙花一现，很快就能恢复原本的生活，结果却越陷越深，难以割舍。频繁的幽会，自然引起了家人的怀疑，久木的妻子提出离婚，而久木犹豫不决。凛子的丈夫则不同意离婚，他想把凛子限制在婚姻的枷锁内惩罚她，悲剧的发生似乎是不可阻挡了。同时久木的同事水口去世，还有两人反复聊到阿部定情杀的故事，在性爱时掐住脖子体验濒死的感觉，暗示着最终走向死亡的结局。 “刚才凛子说“我好难受”时掐住了他脖子，久木以为她是闹着玩儿，没想到凛子会来真格的。被她扼住喉咙时，久木真切地感受到了被带往遥远的世界去的不安，也品味到了某种甘美的感觉。” 凛子打算彻底与丈夫断绝关系，更多的时间是跟久木厮混在一起。她的身体更加丰满，更有韵味，在性爱中变得更加主动，或者说更加淫荡。 “这回没忍住吧?” 望着笑眯眯的凛子，久木再次品尝了失败的滋味。” 二人在欲乐园里贪恋不可自拔，为了追求更高的刺激，她们变换不同的姿势，用不同的体位，还购买了工具。而来自家庭，工作的恶意让他们难以在现实生活中立足，只能彼此依靠。所以活着有什么意思呢？还不如就在欢娱达到顶点之时死去算了。 “女人是在晕眩般极度快乐中梦见死，相比之下，男人则是在坠落下去的虚脱感中被死的阴影所缚，两者真是天壤之别啊！” “在人生态度上，久木渐渐开始倾向于要全力以赴地把握现在的刹那主义，这也是凛子的影响。” 最终的结局，是二人在别墅中自杀。被发现时身体还紧紧的结合在一起。 ","date":"2022-04-15","objectID":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"《失乐园》读后有感","uri":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"日本人对死的看法 日本文学中出现了很多关于死的想法，很多日本知名作家都选择自杀，比如有岛武郎（小说中有提到），芥川龙之介，太宰治，三岛由纪夫，川端康成（小说中也提到了），樱花精神和武士精神也都是一种崇尚“高贵的死”的精神，这一点和中国古代的文人把精神看作比生命更重要是类似的，可能也是因为日本的文化来源于中国文化，但是日本人把这种精神发展到极致了。 很明显我们现在的价值观是不认同这种的，中国有句话叫“好死不如赖活着”，中国的自杀率也远低于日本。我们大家都要好好活着。 ","date":"2022-04-15","objectID":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"《失乐园》读后有感","uri":"/posts/%E5%A4%B1%E4%B9%90%E5%9B%AD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":" 腾讯会议截图 最好的会议软件 参会人数150 每一次在公开场合的讲话对我都是一次极大的锻炼提高！担任活动策划、组织者非常不容易，要考虑每一个细节，尽力满足每一个参与者。事前进行了很多准备，真是台上十分钟台下十年功啊！经过几次锻炼，我现在可以越来越从容稳重地做这种工作了。 ","date":"2022-04-10","objectID":"/posts/%E6%88%90%E5%8A%9F%E4%B8%BB%E6%8C%81150%E4%BA%BA%E5%8F%82%E4%BC%9A%E7%9A%84%E8%AE%B2%E5%BA%A7/:0:0","tags":null,"title":"成功主持150人参会的讲座！","uri":"/posts/%E6%88%90%E5%8A%9F%E4%B8%BB%E6%8C%81150%E4%BA%BA%E5%8F%82%E4%BC%9A%E7%9A%84%E8%AE%B2%E5%BA%A7/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/subarray-sum-equals-k/ 不能用滑动窗口，因为右指针不一定递增。不能用dp，会超时溢出。 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"枚举法 枚举法会超时，但可以为我们提供思路。 考虑以j结尾和为 k 的连续子数组个数，我们需要统计符合条件的下标 i的个数。在确定了i和j之后，如果我们再遍历求和，时间复杂度就达到了O(n的3次方)。实际上我们发现sum([i:j]) = sum([i-1:j])-nums[i-1]，这样递推地可以直接求和。时间复杂度降到了O(n的2次方)。 代码： class Solution { public: int subarraySum(vector\u003cint\u003e\u0026 nums, int k) { int size = nums.size(); int cnt = 0; int sum = 0; for(int i=0;i\u003csize;i++){ sum = 0; for(int j=i;j\u003csize;j++){ sum += nums[j]; if(sum==k){ cnt+=1; } } } return cnt; } }; ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:1","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"前缀和+哈希表 我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。 我们定义 pre[i] 为 0..i 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即： pre[i]=pre[i−1]+nums[i] 那么 j..i 这个子数组和为 k 这个条件我们可以转化为 pre[i]−pre[j−1]==k 简单移项可得符合条件的下标 j 需要满足 pre[j−1]==pre[i]−k 所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。 需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于 pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。 AC代码： class Solution { public: int subarraySum(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; mp[0] = 1; int cnt=0, pre=0; for(auto\u0026 x:nums){ pre += x; if(mp.find(pre-k)!=mp.end()){ cnt += mp[pre-k]; } mp[pre]++; } return cnt; } }; 实际上这道题的细节我花了很多时间去想，但到现在也没弄懂，先放在这里留个问号吧。 ","date":"2022-04-09","objectID":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/:2:2","tags":null,"title":"Leetcode560:和为K的子数组——前缀和、哈希表","uri":"/posts/leetcode560%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题","笔记"],"content":"c++常用函数 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"sort(v.begin(),v.end()) // 向量v vector\u003cint\u003e v; sort(v.begin(),v.end()) // 数组a sort(a,a+n); // 可以加参数cmp // 比如对intervals = [[1,2],[2,3],[3,4],[1,3]] 中每个向量第一个元素按从小到大排序 sort(intervals.begin(), intervals.end(), [](const auto\u0026 u, const auto\u0026 v) { return u[0] \u003c v[0]; }); 默认升序 如果要逆序就麻烦了 template \u003ctypename T\u003e struct cmp { bool operator()(const T \u0026x, const T \u0026y) { return x\u003ey; } }; sort(nums.begin(),nums.end(),cmp\u003cint\u003e()); ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:1","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"max_element(v.begin(),v.end()) 返回指针，指向最大元素 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:2","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"pair\u003cint,int\u003e pair\u003cint, int\u003e p1(1, 2); 定义和初始化 可以用已有对象初始化pair\u003cint, int\u003e p2(p1); 没有初始化，默认为(0,0) 赋值：p2 = pair\u003cint, int\u003e (1, 4); 强制类型转换 访问：p2.first,p2.second make_pair(1,2) ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:3","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"queue() queue\u003cpair\u003cint,int\u003e\u003e que 构造 que.emplace(1,2) emplace自带调用构造函数，而push需要先自己搞出对象再传入 que.front()返回队首元素的引用 que.back()返回队尾元素的引用 que.pop()删除第一个元素 queue.size()元素数量 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:4","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"find() find(v.begin(), v.end(), 3) 查找v中==3的元素的位置，返回指针 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:5","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"priority_queue 头文件： #include\u003cqueue\u003e 定义：priority_queue\u003cint\u003e p; 默认为大顶堆 或priority_queue\u003cType, Container, Functional\u003e Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。 如priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); 其中比较函数为： static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } 这里定义的是一个储存pair\u003cint,int\u003e的小顶堆。 操作（和队列基本操作相同： top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 参考：https://blog.csdn.net/weixin_36888577/article/details/79937886 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:6","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"unordered_set() 创建：unordered_set\u003cchar\u003e occ; 删除：occ.erase('a') 插入：occ.insert('a') 判断是否在set中：occ.count('a') ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:7","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"vector\u003c\u003e 创建一个n*n的二维数组：vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(n)); 创建变量并赋初始值：vector\u003cint\u003e v(10,1) 长度为10，初值1 dp.push_back()，添加一个元素 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:8","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"python常用函数 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"sorted() sorted(iterable, key=None, reverse=False) 参数说明： iterable – 可迭代对象。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 返回重新排序的列表。 ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:1","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题","笔记"],"content":"set() 创建：occ = set() occ = set(iterable比如列表、字符串) 删除：occ.remove('a') 插入：occ.add('a') 判断是否在set中：'a' in occ ","date":"2022-04-08","objectID":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:2","tags":null,"title":"C++和python常用函数","uri":"/posts/c++%E5%92%8Cpython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 乍一看好像做过，再一看好像不会😂 题解 ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"暴力法 设字符串为s，假如我们要找的这段没有重复字符的序列是从i起始，到rk结束（即s[i:rk]）。 那么用两个循环暴力枚举i和rk，看s[i:rk]是不是无重复元素的序列，记录下最大的序列。 贴个超时代码： class Solution: def lengthOfLongestSubstring(self, s: str) -\u003e int: s = s.replace(\" \",\"1\") size = len(s) max = 0 for i in range(size): for j in range(size+1): n = len(s[i:j]) if n==len(set(s[i:j])) and n\u003emax: max = n return max 暴力法是无脑的，不懂得使用先前循环的经验。那么如何优化呢？ ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:1:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"滑动窗口 首先就是建议看官方题解….我这里再稍微总结一下： 这道题目有这样的性质：当i递增时，rk也一定是递增的，因此我们不用像暴力法那样一次又一次把rk回溯。 为什么呢？因为如果s[i:rk]没有重复元素，那么s[i+1:rk]也一定没有重复元素。因此rk只需要向后移动，不需要回到前面。 所以滑动窗口的思路就是这样： 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk。 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度； 在枚举结束后，我们找到的最长的子串的长度即为答案。 判断一个序列是否有重复的字符用到的数据结构是哈希集合。c++和python都有这种数据结构。 看代码： class Solution { public: int lengthOfLongestSubstring(string s) { // 哈希set unordered_set\u003cchar\u003e occ; int rk=0; int n = s.size(); int max_len = 0; // 左指针初始为-1，此时不需要删除 for(int i=-1;i\u003cn-1;i++){ if(i!=-1){ occ.erase(s[i]); } // 右指针先加入set，再右移1格 while(rk\u003cn \u0026\u0026 !occ.count(s[rk])){ occ.insert(s[rk]); rk++; } max_len = max(max_len, rk-i-1); } return max_len; } }; 细节： 左指针移动，从哈希set中删除一个元素 右指针移动，从哈希set中添加一个元素 左指针从-1开始，如果从0开始，会导致第一个元素不能被删除 …这段代码细节蛮多的，涉及到双指针的问题，一定要在草稿纸上演算好，不然写代码一时爽，debug火葬场。 ","date":"2022-04-08","objectID":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:2:0","tags":null,"title":"Leetcode3:无重复字符的最长子串——滑动窗口","uri":"/posts/leetcode3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/top-k-frequent-elements/ 从这题开始学会使用堆 题解 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:0:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"堆（heap） 大顶堆：父节点的值大于子节点的值。 小顶堆：父节点的值小于子节点的值。 性质：根节点一定是最大（最小）值 这是一个小顶堆的例子： 小顶堆例子 参考：https://www.cnblogs.com/wmyskxz/p/9301021.html ps：会有人把上学期刚学的东西忘得一干二净吗？会，是谁我不说😂。 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:1:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"优先队列（priority_queue） 优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 直接看c++ STL 头文件： #include\u003cqueue\u003e 定义：priority_queue\u003cint\u003e p; 默认为大顶堆 或priority_queue\u003cType, Container, Functional\u003e Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。 如priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); 其中比较函数为： static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } 这里定义的是一个储存pair\u003cint,int\u003e的小顶堆。 操作（和队列基本操作相同： top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 参考：https://blog.csdn.net/weixin_36888577/article/details/79937886 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:2:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"排序大法和大顶堆法 先搞清楚这些咱们才开始做题： 首先最容易想到的，就是统计次数，时间复杂度O(n)。再排序，时间复杂度O(nlogn)。总时间复杂度O(nlogn) 下面是自己写的代码： class Solution: def topKFrequent(self, nums: List[int], k: int) -\u003e List[int]: s = {} for i in nums: if i not in s.keys(): s[i] = 1 else: s[i] += 1 s1 = [(a,b) for a,b in s.items()] s2 = sorted(s1, key=lambda x:x[1], reverse=True) print(s2) return [s2[i][0] for i in range(k)] 同样的，如果用大顶堆把所有[数字,出现次数]加入进去，然后k次返回堆顶元素，时间复杂度也是O(nlogn)。涉及到数据结构的话，最好还是用c艹来写： class Solution { public: static bool cmp(pair\u003cint,int\u003e\u0026m, pair\u003cint,int\u003e\u0026n){ return m.second \u003c n.second; } vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint,int\u003e occur; for( auto\u0026 v:nums){ occur[v]++; } priority_queue\u003cpair\u003cint,int\u003e,vector\u003cpair\u003cint,int\u003e\u003e,decltype(\u0026cmp)\u003e q(cmp); for(auto\u0026 [num,count]:occur){ q.emplace(num,count); } vector\u003cint\u003e res; while(k\u003e0){ res.push_back(q.top().first); q.pop(); k--; } return res; } }; 以上两种方法时间复杂度为O(nlogn)，都不符合题目要求。那么要做到“优于O(nlogn)”用什么方法呢？ ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:3:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"小顶堆法 取自官方题解： 在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」： 如果堆的元素个数小于 k，就可以直接插入堆中。 如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。 遍历完成后，堆中的元素就代表了「出现次数数组」中前 k 大的值。 代码： class Solution { public: static bool cmp(pair\u003cint, int\u003e\u0026 m, pair\u003cint, int\u003e\u0026 n) { return m.second \u003e n.second; } vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e occurrences; for (auto\u0026 v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(\u0026cmp)\u003e q(cmp); for (auto\u0026 [num, count] : occurrences) { if (q.size() == k) { if (q.top().second \u003c count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector\u003cint\u003e ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 由于只需要维护大小为k的堆，所以空间复杂度会小。而且不用对于所有的元素都执行插入堆的操作，所以时间复杂度也优于上面的方法。 ","date":"2022-04-07","objectID":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/:4:0","tags":null,"title":"Leetcode347:前K个高频元素——优先队列、堆","uri":"/posts/leetcode347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/minimum-height-trees/ 这是一道理论性很强，代码也很有技巧性的“中等”难度题目。 题解 ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:0:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"暴力法 献上我的超时代码： class Solution: def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u003e List[int]: find = {} for edge in edges: if edge[0] in find.keys(): find[edge[0]].append(edge[1]) else: find[edge[0]] = [edge[1]] if edge[1] in find.keys(): find[edge[1]].append(edge[0]) else: find[edge[1]] = [edge[0]] if not len(find): return [0] def findlevel(edges, root): que = [root] used = [] cnt = 0 while(len(que)): # print(que) for i in range(len(que)): root = que.pop(0) used.append(root) for f in find[root]: if f not in used: que.append(f) cnt+=1 return cnt-1 res_num = [findlevel(edges, root) for root in range(n)] min_num = min(res_num) return [i for i in range(len(res_num)) if res_num[i]==min_num] ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:1:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"广度优先搜索 有如下结论： 用反证法证明，证明过程挺复杂的。 所以我们就把这题从寻找最短距离变成了寻找最长距离。然后把路径记录下来，路径的中点就是我们要找的根节点。 你不觉得这个结论很奇妙吗？我想到了一团乱的绳子，如果你从中间把这堆绳子拎起来，四周绳子的末梢就会垂下去… 这题代码我分段详解： 首先是第一段代码： g = [[] for _ in range(n)] for x, y in edges: g[x].append(y) g[y].append(x) parents = [0] * n 因为后面要在edges里面查找某个节点连接的另一个节点，所以这里第一步先是做了一个初始化，便于后面的查询。最后得到的结果是g[x]=[a,b,c...]，表示标号为x的节点，连接了a,b,c等节点。（在我的代码中也有类似处理，但我用的是字典） 第二段： def bfs(start: int): vis = [False] * n vis[start] = True q = deque([start]) while q: x = q.popleft() for y in g[x]: if not vis[y]: vis[y] = True parents[y] = x q.append(y) return x x = bfs(0) # 找到与节点 0 最远的节点 x y = bfs(x) # 找到与节点 x 最远的节点 y 这是一个用队列实现的广度优先搜索。vis是记录已搜索过的节点。deque是双向队列（震惊！原来python也是有数据结构的，我才知道😂）。parents记录每个节点的父节点，用于下面找路径。 然后从0开始，找到最远节点x，再从x找最远节点y。那么x，y之间的距离就是最远的（这很奇妙）。 第三段： path = [] parents[x] = -1 while y != -1: path.append(y) y = parents[y] m = len(path) return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]] 在这里要找路径了，这时候parents就派上用场了。如果找到路径长度为奇数，那么正中间那个数就是我们要找的根节点。如果路径长度为偶数，中间的数有两个，那么两个都是我们要找的根节点。 ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:2:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"其他解法 这题还有深度优先搜索（跟广度优先搜索差不多），拓扑序列，不断剔除度为1的节点等方法，我太懒了，不想研究了… ","date":"2022-04-06","objectID":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:3:0","tags":null,"title":"Leetcode310:最小高度树","uri":"/posts/leetcode310%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/add-two-numbers/ 这道题主要是debug 题解 我自己写的代码： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* res = nullptr; int carry = 0; while(l1!=nullptr || l2!=nullptr){ int sum = 0; if(l1==nullptr){ sum = l2-\u003eval; } else if(l2==nullptr){ sum = l1-\u003eval; } else{ sum = l1-\u003eval + l2-\u003eval; } if(carry){ sum += carry; carry = 0; } if(sum\u003e=10){ carry = 1; sum = sum%10; } res = new ListNode(sum, res); if(l1!=nullptr) l1=l1-\u003enext; if(l2!=nullptr) l2=l2-\u003enext; } if(carry){ res = new ListNode(1, res); } return reverseList(res); } }; 还用了一个反转链表的函数，属于绕弯形选手😂 评论里给出的代码，我认为是最简洁优雅易懂的（虽然是java，不过其实和c艹差不多： class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode root = new ListNode(0); // 工具性的头节点 ListNode cursor = root; int carry = 0; while(l1 != null || l2 != null || carry != 0) { int l1Val = l1 != null ? l1.val : 0; int l2Val = l2 != null ? l2.val : 0; int sumVal = l1Val + l2Val + carry; carry = sumVal / 10; ListNode sumNode = new ListNode(sumVal % 10); cursor.next = sumNode; cursor = sumNode; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } return root.next; } } 时间复杂度O(max(m,n))；空间复杂度O(1)； 感想：这道题看起来很简单，但如果在csp考试中遇到我就完蛋了。因为细节太多，debug比较难。 ","date":"2022-04-05","objectID":"/posts/leetcode2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"Leetcode2:两数相加——链表","uri":"/posts/leetcode2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ 这是一道可拓展性很高的题目 题解 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:0","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"中序遍历递归法 最朴素的想法就是先中序遍历得到递增序列，然后返回序列的第k-1个元素。 可是我们只需要第k个元素，不用把所有元素都遍历完再返回结果，那么如何优化呢？ 那就让它遍历到第k个元素时就终止递归，返回结果呗。但是递归不是想终止就终止的，它会有“惯性”～ 比如下面的代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def kthSmallest(self, root: Optional[TreeNode], k: int) -\u003e int: nums = [] def inorder(root): if (not root) or (len(nums)\u003ek): return if root.left: inorder(root.left) nums.append(root.val) if root.right: inorder(root.right) inorder(root) print(nums) return nums[k-1] 对于k=1，我们想让len(nums)\u003e1时就终止，实际上它一直运行到了nums=3。所以这种解法不够优雅。 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:1","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"中序遍历迭代法 中序遍历还有一个用栈实现的迭代法，其代码如下： stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() root = root.right 迭代法相比递归法的优势就是随时可以终止，只需加上两句就可以啦。下面是完整代码： class Solution: def kthSmallest(self, root: TreeNode, k: int) -\u003e int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right 时间复杂度：O(H+k)；空间复杂度：O(H) ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:2","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"记录子树的节点 这个方法适用于频繁地查找第k个最小的值。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-8o07/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-04-04","objectID":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:3","tags":null,"title":"Leetcode230:二叉搜索树中第K小的元素","uri":"/posts/leetcode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/delete-node-in-a-bst/ 这道题完全可以当作一个知识点来对待。 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:1:0","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"题解 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:0","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"思路 众所周知，一颗二叉搜索树的中序遍历是一个递增序列，这是二叉搜索树最基本的性质之一。 某个节点node的后继节点successor，就是中序遍历中仅次于node的后一个节点，是比node大的节点当中最小的节点。node的右子树中最左边那个节点就是successor。 某个节点node的前继节点predecessor，就是中序遍历中稍大于node的前一个节点，是比node小的节点当中最大的节点。node的左子树中最右边那个节点就是successor。 我们要维护这个性质，所以，当删除一个节点时，我们要拿这个节点的后继节点successor或者前继节点predecessor来替换它，然后递归的删除它的后继节点或者前继节点。比如删除[1,2,3,4,5]中的3，我们就拿4来替换它（或者拿2替换）。然后为了删除4，拿5来替换。5后面没有节点了，就直接删除5。 删除的时候可能有三种情况： 要删除节点是叶节点。直接删除就好了。 要删除的节点只有左子树，或者只有右子树。如果是左子树，就找前继节点替换；如果是右子树，就找后继节点替换。 要删除的节点既有左子树又有右子树。前继，后继都可以。一般我们选择后继。 上面的描述比较易于理解，但为了写代码方便，我们稍作改变： 要删除节点是叶节点。直接删除。 要删除的节点有右子树，就拿后继替换。 否则，拿左继替换。 ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:1","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"代码 先看下ac的代码吧： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def get_successor(self, node): node = node.right while node.left: node = node.left return node.val def get_predecessor(self, node): node = node.left while node.right: node = node.right return node.val def deleteNode(self, root: Optional[TreeNode], key: int) -\u003e Optional[TreeNode]: if not root: return None if key \u003e root.val: root.right = self.deleteNode(root.right, key) elif key \u003c root.val: root.left = self.deleteNode(root.left, key) else: if (not root.left) and (not root.right): root = None elif root.right: root.val = self.get_successor(root) root.right = self.deleteNode(root.right, root.val) # 从root.right开始删除， # 如果从当前root删除，会死循环 else: root.val = self.get_predecessor(root) root.left = self.deleteNode(root.left, root.val) return root 为什么非要优先找后继节点呢？其实你优先找前继节点也可以，把这段代码改成这样： elif root.left: root.val = self.get_predecessor(root) root.left = self.deleteNode(root.left, root.val) else: root.val = self.get_successor(root) root.right = self.deleteNode(root.right, root.val) 为什么非要写成root.left = xxx，root.right = xxx呢？ 我把root.right = self.deleteNode(root.right, key)改成self.deleteNode(root.right, key)； 以及后面三处的赋值语句都改成了直接递归，结果只和正确答案差了一点，就是在递归的末端的叶子节点当中root=None没有生效。也就是说叶子节点没有成功删除。 我猜想可能是因为python的引用传递有关，这条赋值语句修改的只是形参而不是实参，所以无效！ 总之递归的代码好难写qwq，孩子根本想不到… ","date":"2022-04-02","objectID":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:2:2","tags":null,"title":"Leetcode450:删除二叉搜索树中的节点","uri":"/posts/leetcode450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/jump-game/ ","date":"2022-04-01","objectID":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode55:跳跃游戏——贪心","uri":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 所谓贪心算法，我个人浅薄的理解就是每一步找局部最优解，最终找到整体最优解。 那么这道题可以有这样的思路：从前往后遍历nums的元素，实时维护最远可以到达的位置 far。 对于当前遍历的位置i，先判断i\u003c=far，再有far = max(far, i+nums[i]) 直到far\u003e=len(nums)，则返回True，否则返回False。 代码： class Solution: def canJump(self, nums: List[int]) -\u003e bool: far = nums[0] size = len(nums) for i in range(size): if i \u003e far: return False far = max(far, nums[i]+i) if far \u003e= size-1: return True return False ps:因为前面做了几题递归，所以本来想用递归做，尝试一下代码不太会写，但我觉得思路上应该是行得通的。看来我的技术还有很大的提升空间呀！ ","date":"2022-04-01","objectID":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode55:跳跃游戏——贪心","uri":"/posts/leetcode55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/house-robber/ ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 看官方题解吧，官方题解写的真好。 ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"感想 我是从去年CSP考试中知道动态规划这个概念的，当时考前自以为弄懂了（其实根本没弄懂），现在做了两三道题了，反而觉得又不懂了。动态规划是很灵活的算法，很多题目想不到可以用动态规划来解决。要多练习才能融会贯通。 ","date":"2022-03-31","objectID":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"Leetcode198:打家劫舍——动态规划","uri":"/posts/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/path-sum-ii/ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:1:0","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:0","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"dfs无回溯 我们用深度优先搜索，在搜索时把当前路径记录下来为nums。如果满足 sum(nums)==targetSum； 该节点是叶节点； 就记录下这个路径。搜索完成后，我们就能把所有满足条件的路径找出来了。 代码的总体框架就是一个深度优先搜索，在这个框架的基础上修改使其符合题意。这是写代码的思路。下面是自己写的代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e List[List[int]]: if not root: return [] res = [] nums = [] def backtracking(nums, node): nums.append(node.val) # print(nums) if sum(nums)==targetSum and not node.left and not node.right: res.append(nums.copy()) if node.left: backtracking(nums.copy(), node.left) if node.right: backtracking(nums.copy(), node.right) backtracking(nums, root) return res 细节： 在往下递归是我传的参数不是nums的引用，而是复制了一个nums传给下一个函数。因此在做每一步递归时都有专属于它的一个nums，所以这段代码没有用到回溯。占用空间也比较大。 上面一点很重要！ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:1","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"dfs、回溯 如果把nums.copy()改成nums，然后在backtracking()的末尾加上nums.pop()，就是回溯了。 这样的话，传递的就是nums的引用，所有的递归过程用的都是同一个nums。在每次递归结束，往上回溯的时候通过pop()删去nums中最后一个元素。 class Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e List[List[int]]: if not root: return [] res = [] nums = [] def backtracking(nums, node): nums.append(node.val) # print(nums) if sum(nums)==targetSum and not node.left and not node.right: res.append(nums.copy()) if node.left: backtracking(nums, node.left) if node.right: backtracking(nums, node.right) nums.pop() backtracking(nums, root) return res 把这段代码跟Leetcode78题放在一起看，发现都是在合适的位置加一个pop()，这其实是回溯的重要特点。 时间和空间复杂度：不会算… ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:2","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"记录父节点、bfs 还有个很聪明的做法，就是用一个哈希表来每一个节点的父节点。这样，不用记录路径，只记录累加和。每找到一个满足条件的叶节点，就从该节点出发向父节点迭代，还原路径。 代码在官方题解～ ","date":"2022-03-30","objectID":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/:2:3","tags":null,"title":"Leetcode113:路径总和——dfs、回溯","uri":"/posts/leetcode113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciidfs%E5%9B%9E%E6%BA%AF/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/subsets/ 一道初中数学题，但是是很难的编程题。 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:1:0","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:0","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"二进制枚举 ​ 集合a={5,2,9}中任何一个数有两种状态，在子集中或者不在子集中，分别用1和0来表示。所以我们可以进行如下编码： 二进制序列 子集 十进制数 000 {} 0 001 {9} 1 010 {2} 2 011 {2,9} 3 100 {5} 4 101 {5,9} 5 110 {5,2} 6 111 {5,2,9} 7 众所周知，如果一个集合的基数为n，那么它有2**n个子集。照上述列举就可以啦。 ps:这个方法真的很巧妙 代码也很值得学习： class Solution { public: vector\u003cint\u003e t; vector\u003cvector\u003cint\u003e\u003e ans; vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int mask = 0; mask \u003c (1 \u003c\u003c n); ++mask) { t.clear(); for (int i = 0; i \u003c n; ++i) { if (mask \u0026 (1 \u003c\u003c i)) { t.push_back(nums[i]); } } ans.push_back(t); } return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码讲解： 1«n表示将二进制数0000 0001 左移n位，如果n=2，则结果为 0000 0100，转化成十进制就是2的n次方，在这题中2的n次方是子集的总数，也是需要枚举的次数。 mask表示的就是咱的编码，是从0，1，2，…，到2的n次方，用的时候当然是用它的二进制形式。 里面的小循环是依次判断集合中的每个数是否为当前编码所需要的数。比如mask=110，i=1，那么(1\u003c\u003ci)=010，mask\u0026(1\u003c\u003ci) = 110\u0026010 = 1 = true所以第i个数是符合这个编码的数。这里用到了位运算。 时间复杂度：O(n x 2的n次方)，外循环2的n次方，内循环O(n)。 空间复杂度：O(n)，临时数组t ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:1","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"dfs、回溯 从这道题开始理解回溯！ 画一颗树，数根为[]，对于子集中的某个元素，左子树是添加这个元素，右子树是不加这个元素。构造这棵树如图（自己画的图有点丑）： 子集递归树 最后叶节点就是所需答案。 代码： class Solution { public: vector\u003cint\u003e t; vector\u003cvector\u003cint\u003e\u003e ans; void dfs(int cur, vector\u003cint\u003e\u0026 nums) { if (cur == nums.size()) { // 叶节点添加到ans ans.push_back(t); return; } t.push_back(nums[cur]); // 取这个元素 dfs(cur + 1, nums); t.pop_back(); // 不取这个元素 dfs(cur + 1, nums); } vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) { dfs(0, nums); return ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 结合上面到图，深度优先搜索，先搜索最左侧的分支，最后到最右边。这个代码其实也是要看一会才能看懂…可能我就是菜。 时间复杂度和空间复杂度和二进制枚举一样。 ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:2","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["刷题"],"content":"回溯剪枝 上述递归过程可以看到很多节点是不必要的，剪枝就是通过增加一些条件，略过不必要的节点。有点难，不想研究了… ","date":"2022-03-29","objectID":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/:2:3","tags":null,"title":"Leetcode78:子集——递归、回溯——一道困扰我的题","uri":"/posts/leetcode78%E5%AD%90%E9%9B%86%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%80%E9%81%93%E5%9B%B0%E6%89%B0%E6%88%91%E7%9A%84%E9%A2%98/"},{"categories":["随笔杂记"],"content":"疫情期间的生活属实腐烂。老师不能来教室监督我们上课，食堂不能堂食，所以我天天呆在寝室，时间长了整个人都变得很低迷，学习的效率很低，每天干的最多的就是刷视频打游戏和睡觉。 今天早上没定闹钟，8:00上课，7:45我才起床。迷迷糊糊的还把时间看错了，以为是8:45，索性直接摆烂不去了。其实这个时候仍然有补救的机会，但是我上课的心已经死了。后来就有3个同学跟我说老师点我回答问题发现我不在，我心想你tm跟我说有什么用？看我笑话是不是？你就不能说我去做核酸了吗？一群靠不住的家伙，一大早就让我生气。 我的生活确实需要好好整理了：衣服堆了很多不洗，数据库实验还没做，竞赛的代码和文档也没写…疫情期间我拥有比往常更多的时间，但也浪费了这些时间。 今天算是给我敲响了警钟。我打开课表算一算，距离数据库原理、人工智能导论、民法概论结课只有三周时间了。复习工作（不如说是预习工作）现在开始刚好，我也该支棱起来了。 昨晚看了四叔的视频拥有的时间越多，人越苦恼，人如果能从低级的趣味中获得源源不断的快乐那是一种很潇洒的活法，但是我做不到，每次欢娱之后都会让我感到堕落、迷惘，那不是我真正的快乐。我只有鞭策自己然后看到自己胜利，才能获得短暂的属于我的真正的快乐，然后一次又一次重复这个过程。我在痛苦与快乐两边无限徘徊。 ","date":"2022-03-29","objectID":"/posts/%E4%BB%8A%E5%A4%A9%E9%80%83%E8%AF%BE%E8%BF%98%E8%A2%AB%E7%82%B9%E5%90%8D%E4%BA%86qwq/:0:0","tags":null,"title":"今天逃课还被点名了qwq","uri":"/posts/%E4%BB%8A%E5%A4%A9%E9%80%83%E8%AF%BE%E8%BF%98%E8%A2%AB%E7%82%B9%E5%90%8D%E4%BA%86qwq/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/ 做过102题后这题可以轻松做出来 ","date":"2022-03-27","objectID":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"Leetcode103:二叉树的锯齿形层序遍历","uri":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 复习一下[102. 二叉树的层序遍历]： 首先根节点入队 当队列不为空： 求队列长度s 依次从队列中取s个元素拓展，然后进入下一次迭代 得到层序遍历结果后，把奇数层reverse一下，就能ac了 代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def zigzagLevelOrder(self, root: TreeNode) -\u003e List[List[int]]: res = [] if not root: return res queue = [root] while len(queue): inner = [] for i in range(len(queue)): node = queue.pop() inner.append(node.val) if node.left: queue.insert(0,node.left) if node.right: queue.insert(0,node.right) res.append(inner.copy()) for i in range(len(res)): if i%2: res[i].reverse() return res 其实这题想让我们用一种数据结构deque双端队列。对于偶数层的节点，从后端插入元素；对于奇数层的节点，从前端插入元素。 我个人觉得并不比朴素的方法优秀很多，所以就不深入研究了哈哈。（其实是懒 ","date":"2022-03-27","objectID":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"Leetcode103:二叉树的锯齿形层序遍历","uri":"/posts/leetcode103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 上数据结构这门课时研究过这个问题，思路很快就有，难在debug ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:0","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"递归法 众所周知，只有前序遍历或中序遍历的结果是推演不出原树的。但是前序遍历+中序遍历可以推演出来。因为它们包含的信息特征不同，可以互补。 前序遍历得到的结果形式可以表示为这样：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ] 中序遍历得到的结果形式可以表示为这样：[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ] 所以说，由前序遍历数组的第一个元素可以确定根节点，然后在中序遍历中找到根节点的位置，这个位置左边是左子树，右边是右子树。递归的这么推演下去，就能把整颗树构造出来啦。 举个例子吧：比如preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]。那么首先确定的根节点是preorder[0]，即为3。然后把inorder劈成两半，一半是3左边的left_inorder=[9]，另一半是3右边的right_inorder=[15,20,7]。再把preorder劈成两半，left_preorder=[9]和right_preorder=[20,15,7]。 分别把left_preorder和left_inorder作为参数向左构造子树，把right_preorder和right_inorder作为参数向右构造子树。递归下去。 因为python的数组切片比较好用，所以这题就用了python： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def bt(preorder, inorder, node): node.val = preorder[0] left_inorder = inorder[0:inorder.index(preorder[0])] left_preorder = preorder[1:len(left_inorder)+1] right_inorder = inorder[inorder.index(preorder[0])+1:] right_preorder = preorder[len(left_inorder)+1:] if len(left_preorder)==1: node.left = TreeNode(left_preorder[0],None,None) elif len(left_preorder)==0: node.left = None else: node.left = TreeNode() bt(left_preorder,left_inorder,node.left) if len(right_preorder)==1: node.right = TreeNode(right_preorder[0],None,None) elif len(right_preorder)==0: node.right = None else: node.right = TreeNode() bt(right_preorder,right_inorder,node.right) root = TreeNode() bt(preorder,inorder,root) return root 细节 先确定left_inorder，因为left_inorder和left_preorder的长度应该相同，所以由它的长度可以确定left_preorder。right_inorder和right_preorder同理。 如果order数组为的长度为1，说明下一个节点是叶节点，后面就不用继续构造下去了。 如果order数组为的长度为0，即为[]，说明当前节点是叶节点，直接令下一个节点为None。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:1","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"改进 left_inorder = inorder[0:inorder.index(preorder[0])] right_inorder = inorder[inorder.index(preorder[0])+1:] 这两段代码在preorder中搜索根节点要花费很多时间，我们在一开始就创建一个哈希表储存每个数的索引，这样搜索时间就是O(1)了。 另外官方题解并没有把数组切片，而是传了指针的位置。 官方题解做法python： class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int): if preorder_left \u003e preorder_right: return None # 前序遍历中的第一个节点就是根节点 preorder_root = preorder_left # 在中序遍历中定位根节点 inorder_root = index[preorder[preorder_root]] # 先把根节点建立出来 root = TreeNode(preorder[preorder_root]) # 得到左子树中的节点数目 size_left_subtree = inorder_root - inorder_left # 递归地构造左子树，并连接到根节点 # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1) # 递归地构造右子树，并连接到根节点 # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right) return root n = len(preorder) # 构造哈希映射，帮助我们快速定位根节点 index = {element: i for i, element in enumerate(inorder)} return myBuildTree(0, n - 1, 0, n - 1) 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 官方题解的c++代码，学习一下： class Solution { private: unordered_map\u003cint, int\u003e index; public: TreeNode* myBuildTree(const vector\u003cint\u003e\u0026 preorder, const vector\u003cint\u003e\u0026 inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) { if (preorder_left \u003e preorder_right) { return nullptr; } // 前序遍历中的第一个节点就是根节点 int preorder_root = preorder_left; // 在中序遍历中定位根节点 int inorder_root = index[preorder[preorder_root]]; // 先把根节点建立出来 TreeNode* root = new TreeNode(preorder[preorder_root]); // 得到左子树中的节点数目 int size_left_subtree = inorder_root - inorder_left; // 递归地构造左子树，并连接到根节点 // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root-\u003eleft = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1); // 递归地构造右子树，并连接到根节点 // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root-\u003eright = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right); return root; } TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { int n = preorder.size(); // 构造哈希映射，帮助我们快速定位根节点 for (int i = 0; i \u003c n; ++i) { index[inorder[i]] = i; } return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1); } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:2","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"感想 解决树的问题，代码复杂度明显要高一点。以后我会更多使用较为熟悉方便的python而不是c++。 ","date":"2022-03-26","objectID":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:3","tags":null,"title":"Leetcode105:从前序与中序遍历序列构造二叉树","uri":"/posts/leetcode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"题目 从今天开始多做一点关于数据结构“树”的题目。 https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:0","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"知识点：二叉搜索树 定义很简单： 若其左子树存在，则其左子树中每个节点的值都不大于该节点值； 若其右子树存在，则其右子树中每个节点的值都不小于该节点值。 性质： 二叉搜索树中序遍历的结果是一个递增序列 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:1","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"递归法构造二叉搜索树 本题要求构造一棵平衡的二叉搜索树，所以我们要尽可能把数值大小处于中间的元素放在根节点。假设有一段从i到j的序列，如果序列的长度是奇数，根节点就是中间那个数，也就是第(i+j)/2个数；如果数组的长度是偶数，那也无妨，我们把中间偏左的元素作为根节点，仍然是第(i+j)/2个数（整除） 。然后把中间数左边的序列按照同样的方法构造成左子树，右边的序列构造成右子树，递归的这么构造下去即可。 比如nums = [-10,-3,0,5,9]，先选择0作为根节点，然后0左边的序列[-10,-3]构成左子树，0右边的序列[5,9]构成右子树。 递归这种东西，不会的时候觉得很难，会了之后就不觉得难了。请看代码： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) { return helper(nums, 0, nums.size()-1); } TreeNode* helper(vector\u003cint\u003e\u0026 nums, int left, int right){ // 递归的终止条件 if(left \u003e right){ return nullptr; } // 选择中间或中间左边的数为根节点 int mid = (left+right)/2; TreeNode* root = new TreeNode(nums[mid]); root-\u003eleft = helper(nums, left, mid-1); root-\u003eright = helper(nums, mid+1, right); return root; } }; 细节： 递归终止的条件是left \u003e right，此时已经没有序列可以构成子树了，所以子节点为nullptr。 另外，不一定非要把中间偏左的元素作为根节点，选择中间偏右的元素也是可以的。 ","date":"2022-03-25","objectID":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:2","tags":null,"title":"Leetcode108:将有序数组转换为二叉搜索树","uri":"/posts/leetcode108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/max-area-of-island/ leetcode的中等难度题对于我这种弱鸡来说确实花一点时间才能做出来。（即使是看了答案）和简单难度题相比，它的难点在于代码要注意很多细节。 ","date":"2022-03-24","objectID":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode695:岛屿的最大面积——中等难度的搜索算法","uri":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 这道题相较于Leetcode994:腐烂的橘子，有哪些不一样呢？ 994题给了你几个源点，而这题你需要从每个连通图里自己选择一个源点，才能进行搜索。 994题要统计的是轮数，而这题在搜索时你需要统计节点总共的数量。 解决方案： 初始时遍历整个图，一旦遇到岛屿就开始做搜索。为了避免重复搜索，可以把已搜索节点标为0。 带有返回值的递归。把整个递归过程看成一颗树，那么叶节点返回应该为1，其他节点返回应该是1+所有子节点。 上面这个图是我随手画的，只是便于理解，跟这个测试案例没啥关系😂。 上代码： class Solution { public: int get_area(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int i,int j){ if(i\u003c0 || i\u003egrid.size()-1 || j\u003c0 || j\u003egrid[0].size()-1 || grid[i][j]==0){ return 0; } grid[i][j] = 0; int ans = 1; vector\u003cint\u003e di = {0,0,1,-1}; vector\u003cint\u003e dj = {1,-1,0,0}; for(int x=0;x\u003c4;x++){ int next_i = i+di[x]; int next_j = j+dj[x]; ans += get_area(grid, next_i, next_j); } return ans; } int maxAreaOfIsland(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int maxarea = 0; for(int i=0;i\u003cgrid.size();i++){ for(int j=0;j\u003cgrid[0].size();j++){ if(grid[i][j] == 1){ int area = get_area(grid,i,j); if(maxarea \u003c area){ maxarea = area; } } } } return maxarea; } }; 细节： 搜索一个节点的时候先判断传入的坐标是否越界，如果越界了，或者所搜索的节点是0，直接return 0;因为只有1才有必要进行下一步操作。 ans这个变量就很关键了，先赋初值为0，再累加。结合上面的图思考。 di和dj这两个数组的定义就是节省了代码，上一道搜索算法的题目我也是这样写的。 ","date":"2022-03-24","objectID":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode695:岛屿的最大面积——中等难度的搜索算法","uri":"/posts/leetcode695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6%E7%9A%84%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/squares-of-a-sorted-array/ ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"先平方再排序 class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { for(int i=0;i\u003cnums.size();i++){ nums[i] = nums[i]*nums[i]; } sort(nums.begin(),nums.end()); return nums; } }; 没啥好说的，打败40%的用户😂 ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"双指针 不难发现，一个一般的nums数组前面是负数后面是正数，nums数组平方后的最大值一是第一个元素或最后一个元素。所以在第一位和最后一位分别放两个指针i和j。 判断if nums[i]*nums[i] \u003e nums[j]*nums[j]，则把nums[i]*nums[i]放到res数组最后一位，否则把nums[j]*nums[j]放到最后一位。然后往前移动i，或者往后移动j。 这里有个动画：977.有序数组的平方.gif 代码： class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { int i = 0; int j = nums.size()-1; int k = j; vector\u003cint\u003e res(nums.size()); while(i\u003c=j){ if(nums[i]*nums[i] \u003c= nums[j]*nums[j]){ res[k--] = nums[j]*nums[j]; j--; }else{ res[k--] = nums[i]*nums[i]; i++; } } return res; } }; 细节： 因为可能i和j所指的元素相等，所以判断里要加个等于 while循环停止的条件，可以是i\u003c=j，或许也可以是k\u003e=0 ? ","date":"2022-03-23","objectID":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/:2:2","tags":null,"title":"Leetcode977:有序数组的平方——双指针","uri":"/posts/leetcode977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/rotting-oranges/ 这道题就接着733题做刚刚好。正好介于有点思路但又写不出来中间，属于够一够脚尖才能实现的目标。 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:1:0","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:0","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"解题思路 这道题很明显要使用广度优先搜索，搜索的目标是每个腐烂橘子周围的新鲜橘子。相较于733题图像渲染来说，这道题由一个搜索源点变成了可能有多个源点。而且你得一轮一轮去搜索，并统计出搜索的轮数。 如果只用一个队列的话，难以区分队列中的烂橘子是在哪一轮烂掉的。所以本菜鸡突发奇想，用两个队列交替push。例如：第一轮把烂橘子push给que队列，第二轮push给newque队列，清空que队列，第三轮再push给que队列…以此类推。 官方题解只用了一个队列，它并不是在搜索时区分第几轮的。而是使用了一个dis[][]数组，记录了每一个橘子相较于上一个橘子腐烂时间+1。也非常巧妙。 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:1","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"代码 class Solution { public: int orangesRotting(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { vector\u003cint\u003e dx = {-1, 1, 0, 0}; vector\u003cint\u003e dy = {0, 0, -1, 1}; queue\u003cpair\u003cint,int\u003e\u003e que; queue\u003cpair\u003cint,int\u003e\u003e newque; // 定义了两个队列 int maxrow = grid.size(); int maxcol = grid[0].size(); int fresh = 0; // 新鲜橘子 // 先把坏橘子入队 for(int i=0; i\u003cmaxrow; i++){ for(int j=0;j\u003cmaxcol; j++){ if(grid[i][j] == 2){ que.emplace(i,j); }else if(grid[i][j] == 1){ fresh += 1; } } } newque = que; int minute = 0; // 一轮一轮地搜索腐烂橘子四周的新鲜橘子 while(!newque.empty()){ minute += 1; que = newque; newque = queue\u003cpair\u003cint,int\u003e\u003e(); // 清空 while(!que.empty()){ pair\u003cint,int\u003e rot = que.front();que.pop(); for(int i=0;i\u003c4;i++){ int x = rot.first+dx[i]; int y = rot.second+dy[i]; if(x\u003e=0 \u0026\u0026 x\u003cmaxrow \u0026\u0026 y\u003e=0 \u0026\u0026 y\u003cmaxcol \u0026\u0026 grid[x][y]==1){ grid[x][y] = 2; fresh -= 1; newque.emplace(x,y); } } } } if(fresh){return -1;} // 检查一下还有没有腐烂橘子 return max(0,minute-1); } }; 细节： 最开始把坏橘子找出来的同时顺便可以把新鲜橘子的总数找出来。在搜索时顺便统计一下坏掉橘子的数量，相减后就能知道几轮下来还有没有新鲜的橘子了。 我这样写代码把最初坏的橘子也算上消耗了一分钟时间，等于多算了一分钟，最后要把minute-1。但由于minute初值设置为0，所以可能会有-1的情况，此时取0就可。（我现在写题解的时候突然发现这个-1貌似没影响qwq） 看了下其他人的题解没有用我这种双队列方法的，哈哈，还特意发了个题解显摆一下，作者竟我自己😂 ","date":"2022-03-22","objectID":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/:2:2","tags":null,"title":"Leetcode994:腐烂的橘子——多源广度优先搜索—有趣的题目","uri":"/posts/leetcode994%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%E5%A4%9A%E6%BA%90%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A5%BD%E9%A2%98/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/flood-fill/ 美好的一天从一道简单题开始～ ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题解 理解题意后，发现这不就是windows自带画图工具里的油漆桶吗？ ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"深度优先搜索 众所周知，深度优先搜索可以用栈实现，而递归本质上就是栈。所以直接上递归代码： class Solution { public: void fill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int currcolor, int newColor, int sr, int sc){ image[sr][sc] = newColor; if(sr\u003e0 \u0026\u0026 image[sr-1][sc]==currcolor){ fill(image, currcolor, newColor, sr-1, sc); } if(sr\u003cimage.size()-1 \u0026\u0026 image[sr+1][sc]==currcolor){ fill(image, currcolor, newColor, sr+1, sc); } if(sc\u003e0 \u0026\u0026 image[sr][sc-1]==currcolor){ fill(image, currcolor, newColor, sr, sc-1); } if(sc\u003cimage[0].size()-1 \u0026\u0026 image[sr][sc+1]==currcolor){ fill(image, currcolor, newColor, sr, sc+1); } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currcolor = image[sr][sc]; fill(image, currcolor, newColor, sr, sc); return image; } }; 五分钟敲完，提交，嘿嘿，有趣的题目～ 等等，咋提示栈溢出了呢？ 看了下测试用例。嗷嗷，原来有一个情况没考虑到： 当所要修改的颜色和它本身的颜色一样时，这个代码会无穷无尽的拓展下去。好家伙，原来栈溢出就是这么回事呀！ 所以我加了一个判断： class Solution { public: void fill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int currcolor, int newColor, int sr, int sc){ if(image[sr][sc]==newColor){ // 在这里加了一个判断，如果newcolor等于现有颜色，直接退出。 return; }else{ image[sr][sc] = newColor; } if(sr\u003e0 \u0026\u0026 image[sr-1][sc]==currcolor){ fill(image, currcolor, newColor, sr-1, sc); } if(sr\u003cimage.size()-1 \u0026\u0026 image[sr+1][sc]==currcolor){ fill(image, currcolor, newColor, sr+1, sc); } if(sc\u003e0 \u0026\u0026 image[sr][sc-1]==currcolor){ fill(image, currcolor, newColor, sr, sc-1); } if(sc\u003cimage[0].size()-1 \u0026\u0026 image[sr][sc+1]==currcolor){ fill(image, currcolor, newColor, sr, sc+1); } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currcolor = image[sr][sc]; fill(image, currcolor, newColor, sr, sc); return image; } }; 官方题解的代码跟我的代码思路一样，但它的要更简洁一点。值得学习！： class Solution { public: const int dx[4] = {1, 0, 0, -1}; const int dy[4] = {0, 1, -1, 0}; void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int x, int y, int color, int newColor) { if (image[x][y] == color) { image[x][y] = newColor; for (int i = 0; i \u003c 4; i++) { int mx = x + dx[i], my = y + dy[i]; if (mx \u003e= 0 \u0026\u0026 mx \u003c image.size() \u0026\u0026 my \u003e= 0 \u0026\u0026 my \u003c image[0].size()) { dfs(image, mx, my, color, newColor); } } } } vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currColor = image[sr][sc]; if (currColor != newColor) { dfs(image, sr, sc, currColor, newColor); } return image; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度O(m*n)，最坏需要遍历所有方格。 空间复杂度O(m*n)，栈的空间开销蛮大。 ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"广度优先搜索 众所周知，实现广度优先搜索需要用到队列。 懒得写了，看一看官方题解： class Solution { public: const int dx[4] = {1, 0, 0, -1}; const int dy[4] = {0, 1, -1, 0}; vector\u003cvector\u003cint\u003e\u003e floodFill(vector\u003cvector\u003cint\u003e\u003e\u0026 image, int sr, int sc, int newColor) { int currColor = image[sr][sc]; if (currColor == newColor) return image; int n = image.size(), m = image[0].size(); queue\u003cpair\u003cint, int\u003e\u003e que; que.emplace(sr, sc); image[sr][sc] = newColor; while (!que.empty()) { int x = que.front().first, y = que.front().second; que.pop(); for (int i = 0; i \u003c 4; i++) { int mx = x + dx[i], my = y + dy[i]; if (mx \u003e= 0 \u0026\u0026 mx \u003c n \u0026\u0026 my \u003e= 0 \u0026\u0026 my \u003c m \u0026\u0026 image[mx][my] == currColor) { que.emplace(mx, my); image[mx][my] = newColor; } } } return image; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度分析同深度优先搜索。 别搞混了： 广度优先搜索 深度优先搜索 队列 栈 ","date":"2022-03-21","objectID":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"Leetcode733:图像渲染——搜索算法","uri":"/posts/leetcode733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/non-overlapping-intervals/ 这题我竟然一年前做过，第二遍再做的时候一点印象都没有。 看了下提交记录，发现一年前做的时候代码还是自己敲上去的，一年之后咋就什么都不会了呢？难道我的算法水平还不如一年前？？？ ","date":"2022-03-20","objectID":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode435:重叠区间——动态规划、贪心","uri":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 做的时候思路跑偏了，总想着把有重叠的区间找出来剔除掉。换一个思路，可以去寻找不重叠的最大区间数n，然后拿all-n就是最小重叠区间的数量。 贪心的解法其实不难理解，只是不太容易想到（因为我是菜鸡qwq）： 思路：可以把这题的情境想象成一个预定会议问题，区间的左右两端就是会议的开始时间和结束时间，要求会议时间不能重叠，寻找一个能安排最多会议次数的序列。那么我们先找到最先结束的那个会议，放在最开头。然后从剩下的会议里找到最先结束的，同时开始时间不早于第一个会议结束时间的那个会议，放在第二个。以此类推…就完成啦。 实际做题的时候有个技巧，就是可以先按照会议结束的时间（即区间右端点）进行排序。这样代码会好写很多。 上不是自己写的代码： class Solution { public: int eraseOverlapIntervals(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) { if (intervals.empty()) { return 0; } sort(intervals.begin(), intervals.end(), [](const auto\u0026 u, const auto\u0026 v) { return u[1] \u003c v[1]; }); int n = intervals.size(); int right = intervals[0][1]; int ans = 1; for (int i = 1; i \u003c n; ++i) { if (intervals[i][0] \u003e= right) { ++ans; right = intervals[i][1]; } } return n - ans; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度分析：排序nlogn+遍历n，因为nlogn的幂次高，所以O(nlogn+n)=O(nlogn)，故时间复杂度O(nlogn) 空间复杂度：O(logn)，排序所需要的栈空间 还有一种动态规划的方法，是按照左端点进行排序，然后用f[i]表示「以区间 i 为最后一个区间，可以选出的区间数量的最大值」来进行状态转移。 代码比贪心复杂，时间复杂度也大一点，懒得去研究了。 ","date":"2022-03-20","objectID":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode435:重叠区间——动态规划、贪心","uri":"/posts/leetcode435%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/search-a-2d-matrix-ii/ ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:1:0","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:0","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"法一：逐行二分 没啥好说的，代码可以参考一下 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { for (const auto\u0026 row: matrix) { auto it = lower_bound(row.begin(), row.end(), target); if (it != row.end() \u0026\u0026 *it == target) { return true; } } return false; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-so-9hcx/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 对一行使用二分查找时间复杂度O(logm)，对n行使用二分查找时间复杂度O(nlogm)。 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:1","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"法二：巧妙的利用性质 观察矩阵最右上角的元素： 它是所在行最大的元素 它是所在列最小的元素 这就有点像二分法了。对于一个目标数target，如果target\u003cmatrix[row][col]，则target一定不在第col列。如果target\u003ematrix[row][col]，则它一定不在第row行。 所以我们只要判断target和matrix[row][col]的大小，就能排除某一行或某一列的所有元素。 上代码： class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int row = 0; int col = matrix[0].size()-1; while(row\u003cmatrix.size() \u0026\u0026 col\u003e=0){ if(target \u003c matrix[row][col]){ col--; }else if(target \u003e matrix[row][col]){ row++; }else{ return true; } } return false; } }; 最多把所有的行和列都排除一遍，时间复杂度只有O(m+n)。这个方法很巧妙！ 其实关注左下角的元素也是一样的： 它是所在行最小的元素 它是所在列最大的元素 明白了就不觉得难了。 ","date":"2022-03-19","objectID":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/:2:2","tags":null,"title":"Leetcode240:搜索二维矩阵——二分、矩阵","uri":"/posts/leetcode240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E7%9F%A9%E9%98%B5/"},{"categories":["技能分享"],"content":"roboflow roboflow是一个支持数据集在线打标，在线导出的网站。除此之外它还支持可多人合作、数据增强，版本控制等功能。是我用过最好用的数据集处理平台。 网址：https://roboflow.com/ 提示： 可以免费使用 需要挂代理 套餐一定要选public，选择private后导出数据集会很麻烦 ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:1:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"colab 谷歌提供的计算平台 优点： 提供免费的tesla k80算力 可以很方便的上传下载文件，还可挂载谷歌云盘 用的人多，环境配置起来方便 网速不错，git clone,pip install都麻利的 ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:2:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"训练yolov5模型 完全在云端操作，你只需要一个浏览器就行了。 在roboflow上标好数据，点export导出，不用下载，只要复制这段代码就可以了 打开https://colab.research.google.com/github/roboflow-ai/yolov5-custom-training-tutorial/blob/main/yolov5-custom-training.ipynb 替换你的下载代码，点运行全部单元格 然后你就什么都不用管了，这个脚本会帮你训练、评估效果，最后把权重下载下来。 是不是非常优雅～ ","date":"2022-03-19","objectID":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/:3:0","tags":null,"title":"Roboflow+colab优雅地训练yolov5模型","uri":"/posts/roboflow+colab%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%AD%E7%BB%83yolov5%E6%A8%A1%E5%9E%8B/"},{"categories":["书影记录"],"content":"邓小平时代 所有中国人都知道，1949年建国时中国是一个落后封闭的社会主义国家（和现在的朝鲜差不多）。但是在80年代，社会主义市场经济取代了计划经济，对外封闭变成了改革开放。90年代，中国经济一路起飞，国际地位迅速提高。直到现在，中国已经成为世界最强的国家之一。 中国是如何崛起的？在大一时，孙运雷老师向我们提出过这个问题，让我们阅读一些书籍去寻找答案。当时我阅读了陈经的《中国的官办经济》，对这个问题已经有初步认识。现在再读傅高义的《邓小平时代》，算是进一步找到了答案。正如傅高义在序中所说： 我认为，要想了解今日之中国，很重要的一点是了解历史，特别是自 1978 年邓小平开始领导造就了当下中国的一系列进程之后的历史。 除此之外，作为一个中国人，作为一个充满好奇心年轻人，我们对自己的党，自己的国家都有许多疑问：毛泽东时代怎样进入到邓小平时代？我们国家曾经有哪些最高领导人？为什么有的领导人被称为领导核心，有的却不是？他们执政时发生了哪些事情？中国共产党执政时出现过哪些危机？为什么历史教材上很少提到？大陆和台湾关系有哪些细节？国家与国家的交往是怎么样的？…如果你在境外网站检索这些问题，你会得到充满偏见的、有诬蔑性的答案。不妨读一读这本书，从一个外国人的视角，真实客观的解读现代中国。 《邓小平时代》 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:1:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"傅高义 傅高义是土生土长的美国人，30岁时在哈佛大学开始研究中国，同时精通中文和日文，是著名的中国和日本问题专家，被称为“中国先生”。1979年出版《日本第一》，正值日本经济崛起，使他名声大噪。但很快日本经济泡沫破灭，开始衰败。2000年他又出版了《日本仍是第一吗？》，颇具争议。 2011年在美国出版《邓小平时代》，引起广泛关注。2013年此书在中国出版，首印50万册发行一空。 傅高义老先生德高望重，是倡导美国应以更理性和平衡方式思考中国的主要支持者。是中国的知己而不是中国的敌人。他于2020年在美国去世，享年90岁。 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:2:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"版本 《邓小平时代》是一本面向大众的通俗读物。书很厚，大陆版全书700多页，定价88元，有点小贵。 即使大陆版相比港版略有删节，但大陆版的内容还是让人直呼大胆，能够在中国大陆出版我觉得也是一种奇迹。 大陆版可以在图书馆借到，港版可以下载到手机上看。我粗略的比较了一下大陆版和港版，只有第20章：北京删节较多，其它基本无异。 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:3:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"邓小平——改革开放的总设计师 邓小平有一句经典的话：“摸着石头过河。“ 最初实行改革开放时，他也没有想好伟大宏图。他是实干家，不搞花架子，讲话通俗易懂，集中注意力解决实际问题。与其说他是改革开放的总设计师，不如说是改革开放的总经理，带着北京的领导班子，带领全国人民，披荆斩棘，野蛮生长，开拓出自己的一条道路。 邓小平上台时，中国是一个“烂摊子”，国家仍因“文革”的混乱而步履蹒跚。工业、农业、教育、社会制度、科技、经济、外交…中国全方位落后。但是邓小平是一位出色的改革家，他和其它领导人找到了一条富国强民的道路，提出了改革开放，引领了中国的根本转型。书中称之为自两千多年前汉帝国形成以来，中国最根本的变化。 借鉴书中观点，我把邓小平的伟大贡献概括如下： 改革开放使中国开放拥抱世界，使中国富起来了，国际地位大大提高，从“亚洲文明的中心”走向“世界大国”。同时国内的开放程度也大大提高，中国更像一个整体了。 邓小平维护了党的集体领导，化解了像东欧剧变、苏联解体等对中国的冲击，拯救国家于危难之中。 促使教育、科技业的发展，如恢复高考，善待科技工作者，向国外派遣大量留学生，这是他刚上台就在做的事情。为未来培养了人才。 促进外交，与日、美等多国建立友好关系，结束了毛时代的外交僵局。帮助中国实现现代化。赢得和平发展的环境。 但也留下了许多问题： 全民社会保障和公共医疗欠佳。 腐败问题，这是高速发展的社会不可避免的。 法治建设。 环境问题等。 这些问题都受到了继任的领导人的重视，正在一点一点解决。生长在这个时代我感到非常幸运，看到自己的国家由飞速发展，变为精细提高人民的生活水平。现在在习近平总书记领导下，中国已经成长的非常健壮了，希望在未来能创造出更多奇迹！ ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:4:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["书影记录"],"content":"梳理中国现代史 在《如何阅读一本书》中提到了一种阅读方法：主题阅读。简单来说，就是如果你对一类问题很感兴趣，那就针对这类问题去找几本书阅读。这种阅读的效率被认为是最高的。中国的现代史（1949年新中国成立至今这一段历史）我们好像都了解的不多，也比较感兴趣。读了几本书后，对中国现代史作一个简单梳理： 1949年：毛主席在全国人民的热烈欢呼下在北京天安门宣布新中国成立。 未完待续 ","date":"2022-03-18","objectID":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/:5:0","tags":null,"title":"《邓小平时代》——改革开放的总设计师","uri":"/posts/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E7%9A%84%E6%80%BB%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/assign-cookies/ ","date":"2022-03-18","objectID":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/:1:0","tags":null,"title":"Leetcode455:分发饼干——排序、贪心","uri":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题解 为了满足更多的孩子，应该把孩子的胃口从小到大排序，尽量先满足胃口小的孩子。（因为如果胃口小的孩子都满足不了，肯定也满足不了胃口大的孩子） 然后对于每个胃口小的孩子，找到一个能刚好满足他的饼干。 思路很简单，我是个菜鸡，看了题解才想出来qwq 这是我第一次写的代码： class Solution { public: int findContentChildren(vector\u003cint\u003e\u0026 g, vector\u003cint\u003e\u0026 s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int cnt = 0; for(int i=0;i\u003cg.size();i++){ for(int j=0;j\u003cs.size();j++){ if(s[j]\u003e=g[i]){ cnt+=1; s[j]=0; break; } } } return cnt; } }; i和j分别是孩子和饼干的指针，由于j指针有回溯，所以效率很低。776ms 改进一下： class Solution { public: int findContentChildren(vector\u003cint\u003e\u0026 g, vector\u003cint\u003e\u0026 s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int cnt = 0; int j = 0; for(int i=0;i\u003cg.size();i++){ while(j\u003cs.size()){ if(s[j]\u003e=g[i]){ cnt++; s[j]=0; break; }else{ j++; } } } return cnt; } }; 如果饼干不能满足小胃口的孩子，那么大胃口的孩子肯定也满足不了。不让j指针回溯，效率一下子提上来了，20ms 时间复杂度：O(mlogm+nlogn)主要是排序的时间复杂度。 空间复杂度：O(logm+logn)主要是排序的空间复杂度。 ","date":"2022-03-18","objectID":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/:2:0","tags":null,"title":"Leetcode455:分发饼干——排序、贪心","uri":"/posts/leetcode455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ ","date":"2022-03-16","objectID":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"Leetcode160:相交链表——哈希、双指针","uri":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 法一：哈希表 先把一个链表放到哈希表里，再遍历另一个链表。 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { unordered_set\u003cListNode *\u003e visited; ListNode *temp = headA; while (temp != nullptr) { visited.insert(temp); temp = temp-\u003enext; } temp = headB; while (temp != nullptr) { if (visited.count(temp)) { return temp; } temp = temp-\u003enext; } return nullptr; } }; 时间复杂度O(m+n) 空间复杂度O(m) 法二：双指针 这个方法还是很巧妙的！ 两个指针分别指向headA和headB，然后同时同速向后移动，A指针到结尾了就转移到headB，B指针到结尾了就转移到headA。 如果两个链表相交，那一定可以在第二次遍历时指向同一个节点。如果不相交，一定会同时指向nullptr。 详情请看官方题解的证明，不难理解。 自己写的垃圾代码： class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA; ListNode *B = headB; while(headA!=nullptr || headB!=nullptr){ if(A==B){ return A; } if(A==nullptr){ A = headB; }else{ A = A-\u003enext; } if(B==nullptr){ B = headA; }else{ B = B-\u003enext; } } return nullptr; } }; 时间复杂度O(m+n) 空间复杂度O(1) 看到一条评论： 错的人就算走过了对方的路也还是会错过😔 这题我希望大家都返回true 蚌埠住了兄弟们，刷个算法题都能emo。 ","date":"2022-03-16","objectID":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"Leetcode160:相交链表——哈希、双指针","uri":"/posts/leetcode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["技能分享"],"content":"为什么安装sqlserver 上数据库系统概论需要用到数据库，按道理来说应该使用开源的mysql，但老师说因为学校用的是sqlserver，我们考试也用这个，所以我也就得用。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:1:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法一：云数据库（❌ 在mac上直接安装微软的产品，想都别想～所以我首先把注意力放在了云上。众所周知，像阿里云、腾讯云等服务商经常有云数据库优惠活动，购买一个1核1G的mysql数据库一年的时间也用不到10元，性价比拉满。 但是sqlserver数据库贵的要死啊，可能是因为比较小众而且微软要从中赚授权费吧。 于是我又想到了微软自家不是有个云平台Azure吗，以前白嫖过他家的服务器，体验蛮不错。满怀期待登上去看，需要外币信用卡才能注册，对国内用户极不友好。 正当我灰心丧气打算关闭页面时，突然发现Azure有学生套餐！看了下介绍，好像福利挺多的，优惠时间也蛮长，在我的印象中国外这种大厂还是很大气的。然后我就兴高采烈的用学校邮箱注册了学生账户（不需要外币信用卡）。进去一看，哟吼～，产品还挺多，有一堆不认识的。我赶紧搞了一个sqlserver，过程也并不复杂，唯一的缺点是服务器只能选择在美国东部，裸连速度很慢。不过我有代理，供学习使用应该够了。 气人的是，过了两天微软给我发邮件，说我的学生账户可以使用的免费额度没了…白嫖失败。对于穷学生来说，这个法子行不通。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:2:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法二：在本地安装（❌ 我发现sqlserver可以使用docker安装。我对docker印象蛮好的，认为它可以解决大多环境问题。 我的本来想法是这个方案应该非常easy，两步就能搞定，第一步安装docker，第二步run个镜像就能用了。但是，在m1的mac上，docker已经不是原来的那个docker了。 安装docker desktop确实非常方便，只要在官网下载，然后点下一步就能装好，比windows方便多了（在win上你得先跑一个linux虚拟机）。 第二步拉取镜像，跑容器发现跑不起来，会报错，怀疑是m1芯片问题。 为了确认我不是个例，我还去dockerhub看了下，果然评论里都是说这个问题的。它就是不支持m1芯片。 从此之后，我再也不吹docker了，看来它并不能解决所有环境问题。 有人倒是成功了，先跑一个pd虚拟机，再在虚拟机里跑docker，搁这套娃呢？看来在本地安装是指望不上了。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:3:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"法三：云服务器上使用docker（勉强✅ 不能在m1的mac上的docker里安装，在传统的linux上总可以安装吧？ 这个方案确实可行，但也遇到了小坑。 众所周知，便宜点云服务器有很多，10多块钱就能搞一个1核2G的linux云服务器。执行和法二相同的操作： sudo docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=密码\" -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2019-latest 没报错，看来要成功了？真是踏破铁鞋无觅处，得来全不费功夫呀，哈哈～ 然后再打docker ps -a，看下容器跑起来没有。结果发现没有，看来高兴早了qwq。 为什么呢，打docker logs 容器ID看下原因，他娘的，说内存至少要2000mb才能运行。 我的云服务器内存就是2G，实际使用时系统和其他服务会占用一些内存，所以留给sqlserver的内存肯定不足2G了。但我还是抱着侥幸心理，在docker启动容器的命令里分配了2000mb的内存，仍然不行，我试了阿里云，腾讯云的1核2G轻量化应用服务器，都是不行的。 组里面有个2核4G的腾讯云轻量化应用服务器，可以运行！但这服务器是组里的…算了，直接拿来用吧。 麻烦就是端口开不了，自己电脑的navicat连不上，只能ssh到服务器上用命令行工具。 哭了，折腾两节课也没能很好解决这个问题。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:4:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["技能分享"],"content":"总结 如果说windows能做100%的事情，那么M1 Mac 只能做80%。但是我还是会选择m1 mac，因为在它能做的事情范围之内，你能体验到极致的丝滑。 ","date":"2022-03-16","objectID":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/:5:0","tags":null,"title":"mac m1 安装sqlserver踩坑经历","uri":"/posts/macm1%E5%AE%89%E8%A3%85sqlserver%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"},{"categories":["刷题"],"content":"一件事情只有做了一段时间之后才能找到方向。前段时间随便找了一些题刷，开始逐渐了解数据结构和算法。最近在知乎上看到一篇文章，列举了400道数据结构入门题目，感觉找到了方向。 所以从今天开始进入新的刷题阶段。 题单在此：https://www.zhihu.com/question/399753856/answer/2311845630 不一定非要按照这个顺序把所有题目刷完，但是有了这个题单作指导，思路会清晰很多。 别的不多说了，总之坚持把这件事情做下去吧✊。 ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 https://leetcode-cn.com/problems/reverse-linked-list/ ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 假设链表为 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e null 要把它改为 null \u003c- 1 \u003c- 2 \u003c- 3 \u003c- 4 伪代码： ListNode reverseList(ListNode head){ 前一个节点 = null; 当前节点 = head; while(当前节点不为空){ 当前节点.next = 上一个节点; 前一个节点 = 当前节点; 当前节点 = 下一个节点; } } 代码： class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-14","objectID":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:2:0","tags":null,"title":"Leetcode206:反转链表","uri":"/posts/leetcode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"题目 [15. 三数之和] 难度中等4464收藏分享切换为英文接收动态反馈 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示： 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 ","date":"2022-03-13","objectID":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/:1:0","tags":null,"title":"三数之和——双指针——好难","uri":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/"},{"categories":["刷题"],"content":"题解 参考官方题解 思路可以很快确定，难点在于精确调控指针。所以我调了三个小时的代码才通过…可能我单纯就是菜qwq 首先我们想到用三个循环暴力把这些三元组找出来，然后再对结果去重。（话说c++对二维向量去重我也不会呀qwq）那么有没有不需去重的办法呢？ 当然有了，且看如下伪代码： nums.sort() // 对nums排序,使得三元组(a,b,c)满足a\u003c=b\u003c=c for first = 0 .. n-1 // 只有和上一次枚举的元素不相同，我们才会进行枚举 if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then for third = second+1 .. n-1 if third == second+1 or nums[third] != nums[third-1] then // 判断是否有 a+b+c==0 check(first, second, third) 这样保证了两点： 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素，且不与上一个枚举到的元素重复。 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素，且不与上一个枚举到的元素重复。 不懂的话可以看看官方题解，再找一个数组，比如[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]在纸上画一画。 双指针 假设三元组为(a,b,c)。当a确定时，这里的双指针就是b和c，双指针用到了如下性质： 在三重枚举的过程中，当a确定时，b增大，c减小。c不用回溯。 我写不下去了…其实我理解的很烂 那直接上我的代码吧： class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(),nums.end()); // 排序 int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e res; int first,second,third; // 定义三个“指针” for(first=0;first\u003cn;first++){ if(first==0 || nums[first]!=nums[first-1]){ // 这里有个巧妙的地方， // 先判断first==0，如果成立，不用继续判断，数组不会越界 third = n-1; // 当first+1时，才回溯third for(second=first+1;second\u003cn;second++){ if(second==first+1 || nums[second]!=nums[second-1]){ while(second\u003cthird \u0026\u0026 nums[first]+nums[second]+nums[third]\u003e0){ third = third-1; } if (second == third) {// 指针不能重合 break; } if(nums[first]+nums[second]+nums[third]==0){ res.push_back({nums[first],nums[second],nums[third]}); } } } } } return res; } }; 感觉这个过程还蛮复杂的，可能过一段时间再看会清晰一点。 ","date":"2022-03-13","objectID":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/:2:0","tags":null,"title":"三数之和——双指针——好难","uri":"/posts/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E5%A5%BD%E9%9A%BE/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ [102. 二叉树的层序遍历] 难度中等1216收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:1:0","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"题解 这道题的技术点有两个，一是把树状结构转化成数组结构，这个在数据结构里学过，用队列就可以轻松实现。二是要把这个二叉树分层，对于我来说这是一个难点。 我自己的思路是先实现第一步，在一维数组vector\u003cint\u003e v里储存一棵完全二叉树，然后用函数get_n(int index)确定下标为index的节点所在的层数。最后组织成提交所用的格式。 然鹅，我调了两个小时代码只过了11/34 qwq。 代码不能白写，先贴上： // 错误代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int get_n(int index){ int n = 1; while(pow(2,n)-2 \u003c index){ n++; } return n; } vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { if(root==nullptr){ return {}; } vector\u003cint\u003e v; queue\u003cTreeNode*\u003e q; q.push(root); v.push_back(root-\u003eval); while(!q.empty()){ TreeNode* node = q.front(); q.pop(); if(node-\u003eleft){ q.push(node-\u003eleft); v.push_back((node-\u003eleft)-\u003eval); }else{ v.push_back(-1111); } if(node-\u003eright){ q.push(node-\u003eright); v.push_back((node-\u003eright)-\u003eval); }else{ v.push_back(-1111); } } int n=get_n(v.size()-1); //层数 for(int i=0;i\u003cv.size();i++){ cout \u003c\u003c v[i] \u003c\u003c \" \"; } vector\u003cvector\u003cint\u003e\u003e res(n-1); for(int i=0;i\u003cv.size()\u0026\u0026get_n(i)\u003cn;i++){ if(v[i]!=-1111){ res[get_n(i)-1].push_back(v[i]); } } return res; } }; ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:2:0","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"官方题解的骚操作 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 先看一种朴素的方法（虽然是“朴素”的方法，但也比我的方法要巧妙，它在进行广度优先搜索时就解决了层数的问题）： 然后针对这题，可以进行如下优化，概括来说就是每次拓展一层的节点（“拓展”这个词用的真好）： 数学证明，其实这个也很容易想通： 代码： class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector \u003cvector \u003cint\u003e\u003e ret; if (!root) { return ret; } queue \u003cTreeNode*\u003e q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector \u003cint\u003e ()); // 先往ret里压一个空vector for (int i = 1; i \u003c= currentLevelSize; ++i) { auto node = q.front(); q.pop(); // q.fron()取第一个元素，q.pop()删除第一个元素 ret.back().push_back(node-\u003eval); // ret.back()取到最后一个vector，再往里push_back if (node-\u003eleft) q.push(node-\u003eleft); if (node-\u003eright) q.push(node-\u003eright); } } return ret; } }; 复杂度分析 记树上所有节点的个数为 n。 时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。 空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。 这代码写的也很beautiful啊，真是太tm妙啦！ ","date":"2022-03-11","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/:2:1","tags":null,"title":"二叉树的层序遍历——太tm妙啦","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A4%AAtm%E5%A6%99%E5%95%A6/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/pascals-triangle/ [118. 杨辉三角] 难度简单708收藏分享切换为英文接收动态反馈 给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 提示: 1 \u003c= numRows \u003c= 30 ","date":"2022-03-10","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"杨辉三角——数组、动态规划","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 找规律，第i行第j个数等于第i-1行第j-1个数加第i-1行第j个数，即res[i][j]=res[i-1][j-1]+res[i][j]。 一开始我弄错一个变量，导致数组越界，找了半天都没找出来，我还以为是c++的问题，就换了python写，python的报错比较友好，终于让我发现了错误的地方。 所以python代码： class Solution: def generate(self, numRows: int) -\u003e List[List[int]]: res = [[] for i in range(0,numRows)] res[0].append(1) if numRows==1: return res; for i in range(1,numRows): for j in range(0,i+1): if j==0 or j==i: res[i].append(1) else: # print(i,res) res[i].append(res[i-1][j-1]+res[i-1][j]) return res c艹代码： class Solution { public: vector\u003cvector\u003cint\u003e\u003e generate(int numRows) { vector\u003cvector\u003cint\u003e\u003e res(numRows); res[0].push_back(1); if(numRows==1){ return res; } for(int i=1;i\u003cnumRows;i++){ for(int j=0;j\u003ci+1;j++){ if(j==0 || j==i){ res[i].push_back(1); } else{ res[i].push_back(res[i-1][j-1]+res[i-1][j]); } } } return res; } }; ","date":"2022-03-10","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"杨辉三角——数组、动态规划","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 本题目来自：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 121. 买卖股票的最佳时机 难度简单2177收藏分享切换为英文接收动态反馈 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 \u003c= prices.length \u003c= 105 0 \u003c= prices[i] \u003c= 104 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"暴力法 超时，不必多说。 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { int max = 0; for( int i=0;i\u003cprices.size()-2;i++){ for(int j=i+1;j\u003cprices.size()-1;j++){ if(prices[j]-prices[i]\u003emax){ max = prices[j]-prices[i]; } } } return max; } }; 时间复杂度O(n^2)，空间复杂度O(1) ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"动态规划 假设我们有穿越时空的能力，再假设我们决定在第i天卖出，那么只要知道在0~i天的最低价，再穿越回去购买股票，就能获得最大收益了。 创建一个dp[i]数组，表示在第i天卖出时的最低价。 然后再根据dp[i]数组，找到收益最大的那一天，即确定prices[i]-dp[i]的最大值。 //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i \u003c prices.length; i++) { dp[i] = (dp[i - 1] \u003c prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) \u003e max ? prices[i] - dp[i] : max; } return max; // 参考https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/930057 这个代码还可以进一步优化，因为我们只关注最大值，所以可以不用把所有数据都存到数组里。维护一个minprice和maxprofit变量即可。 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for(int price:prices){ minprice = min(price, minprice); maxprofit = max(maxprofit, price-minprice); } return maxprofit; } }; 这样只要遍历一遍数组，时间复杂度O(n)，空间复杂度O(1)。 ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:2","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"其他小问题 1e9表示1*10^9。在算法题中常用来赋一个非常大的值。为什么不用1e10呢？因为int类型中1e10会溢出。 详情可以参考：http://t.csdn.cn/rItZr ","date":"2022-03-09","objectID":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","tags":null,"title":"买卖股票的最佳时机——数组、动态规划","uri":"/posts/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题","技能分享"],"content":"2022年我才搞懂这个！ ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:1:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"比较 传递方式 函数定义 函数调用 函数内对a修改的影响 值传递 fun(int a) fun(x) 外部x不变 指针传递 fun(int *a) fun(\u0026x) 外部x同步更改 引用传递 fun(int \u0026a) fun(x) 外部x同步更改 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:2:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"值传递 值传递是最常用的一种方式。它就是从函数外拷贝到函数内。 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:3:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"指针传递 指针传递跟值传递其实差不多，只是传递的内容从一个值换成了指针。定义函数的时候要写成fun(int *a)，函数内的a就是一个int类型指针要使用a对象的话就得写成*a。 在函数外如果定义一个int b=1，想把它传到函数里的话需要用到取地址符\u0026，像这样写fun(\u0026b)。 示例： #include \u003cstdio.h\u003e void swap(int *a, int *b){ printf(\"swap enter\\n\"); printf(\"a = %d, ptr = %p\\n\", *a, a); printf(\"b = %d, ptr = %p\\n\", *a, b); int tmp = *b; *b = *a; *a = tmp; printf(\"a = %d, ptr = %p\\n\", *a, a); printf(\"b = %d, ptr = %p\\n\", *b, b); printf(\"swap leave\\n\"); } int main() { int x = 1; int y = 2; printf(\"x = %d, ptr = %p\\n\", x, \u0026x); printf(\"y = %d, ptr = %p\\n\", y, \u0026y); swap(\u0026x, \u0026y); printf(\"x = %d, ptr = %p\\n\", x, \u0026x); printf(\"y = %d, ptr = %p\\n\", y, \u0026y); return 0; } 结果： x = 1, ptr = 000000000022FE4C y = 2, ptr = 000000000022FE48 swap enter a = 1, ptr = 000000000022FE4C b = 1, ptr = 000000000022FE48 a = 2, ptr = 000000000022FE4C b = 1, ptr = 000000000022FE48 swap leave x = 2, ptr = 000000000022FE4C y = 1, ptr = 000000000022FE48 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:4:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"引用传递 在定义的时候形参前要加一个\u0026，这个不是取地址符，而是一个记号。（这就是c语言贼tm绕人的地方qwq）比如int fun(int \u0026a)。 调用函数时参数前不需要加任何记号，比如int a=10，fun(a)。 在函数内使用的时候不用加任何东西，直接用即可，比如a=20。 函数内和函数外a的值会同步改变。 示例： class Solution { public: void preorder(TreeNode *root, vector\u003cint\u003e \u0026res){ //这里res前要加一个\u0026 if (root == nullptr){ return; } res.push_back(root-\u003eval); preorder(root-\u003eleft, res); // res可以直接访问到对象内容，且函数内外指向同一个对象 preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; //创建res对象 preorder(root, res); return res; } }; ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:5:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题","技能分享"],"content":"参考资料 以上我自己的总结是非常简单的，仅能保证我在做题时看懂题解，但其实这里面还有很多细节没提到。学到现在终于能体会到当年为什么老师说c语言的指针很难了。 参考csdn文章：http://t.csdn.cn/suCK6 ","date":"2022-03-07","objectID":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:6:0","tags":null,"title":"C语言中值传递、指针传递和引用传递","uri":"/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["刷题"],"content":"题目 前序遍历：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 中序遍历：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 后序遍历：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 树的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题解 ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:0","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"前序遍历 前序遍历的顺序是：根 -\u003e 左 -\u003e 右。（这个顺序一开始还被我记错了qwq） 用递归的方式很简单： class Solution { public: void preorder(TreeNode *root, vector\u003cint\u003e \u0026res){ if (root == nullptr){ return; } res.push_back(root-\u003eval); preorder(root-\u003eleft, res); preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; preorder(root, res); return res; } }; 递归的本质是使用了栈。如果不想用递归，也可以显式地使用栈来做。但是看懂了递归后再看这种方法会觉得脑子疼。 ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:1","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"中序遍历 改一下输出顺序就可以啦。 inorder(node-\u003eleft, res); res.push_back(node-\u003eval); inorder(node-\u003eright, res); ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:2","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"后序遍历 postorder(node-\u003eleft, res); postorder(node-\u003eright, res); res.push_back(node-\u003eval); 话说今天是思美节诶，图书馆的女生打扮的都好漂亮呀～祝节日快乐！ ","date":"2022-03-07","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:2:3","tags":null,"title":"二叉树的前中后序遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["刷题"],"content":"题目 本题来自：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ [350. 两个数组的交集 II] 难度简单670收藏分享切换为英文接收动态反馈 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 *进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ ","date":"2022-03-06","objectID":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"两个数组的交集——数组、哈希、双指针","uri":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 用hashmap解决。今天忙着训练模型，懒得写题解了。 class Solution { public: vector\u003cint\u003e intersect(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { if (nums1.size() \u003e nums2.size()) { return intersect(nums2, nums1); } unordered_map \u003cint, int\u003e m; for (int num : nums1) { ++m[num]; } vector\u003cint\u003e intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 回答一下进阶的那几个问题吧： 已经排好序的话，用双指针做比较好。 用小的数组产生hashmap比较好。 存在磁盘上，每次只能读一部分数据，就不能排序了，得用方法1. ","date":"2022-03-06","objectID":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"两个数组的交集——数组、哈希、双指针","uri":"/posts/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 题目来自：https://leetcode-cn.com/problems/linked-list-cycle/ 141. 环形链表 难度简单1376收藏分享切换为英文接收动态反馈 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 \u003c= Node.val \u003c= 105 pos 为 -1 或者链表中的一个 有效索引 。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题解 虽然上学期学完了数据结构，还拿到了90+的成绩，但我一行代码都没有写过，只会纸上谈兵是不行的。 参考作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"方法一：哈希表 最容易想到的方法，就是遍历这个链表，如果发现某个节点曾经被遍历过了，那么这就是环形链表。判断某个节点是否被遍历过可以用hashset。 代码： class Solution { public: bool hasCycle(ListNode *head) { unordered_set\u003cListNode*\u003e seen; while (head != nullptr) { if (seen.count(head)) { return true; } seen.insert(head); head = head-\u003enext; } return false; } }; 这个代码我是写不出来的，只能先抄题解。有一点不明白的是，unordered_set\u003cListNode*\u003e seen;这一行为什么\u003cListNode\u003e后要加个* ？*加在前面表示定义指针，加在后面表示什么呢？知道的可以在评论区给我留言。 因为只遍历一次，时间复杂度：O(N) 。要开辟哈希表，空间复杂度O(N)。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:1","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"方法二：快慢指针 这个方法很巧妙，leetcode给的解释非常易懂，还有演示视频。 本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 细节:为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？ 观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。 当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码： class Solution { public: bool hasCycle(ListNode* head) { if (head == nullptr || head-\u003enext == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-\u003enext; while (slow != fast) { if (fast == nullptr || fast-\u003enext == nullptr) { return false; } slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } return true; } }; 其实这个代码有点啰嗦。 时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。 当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。 空间复杂度：O(1)。因为只使用了两个指针的额外空间。 [lostBookBoy]问了一个问题：“为什么慢指针每次只移动一步，而快指针每次移动两步而不是其他步？” [洛阳令]的回答：“这里的慢1快2还是有些讲究的，要是慢一快三未必可以解。快减慢等于1是一定有解的。可以将环理解为一个整数加法群，只有差为一才一定有解。” ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:2","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"其它方法： 看了评论区，各路大神各显神通。有的在遍历的时候把链表节点的值改成'bjfuvth'，再遇到就说明有环，这样就不用哈希了。还有跑了很多遍代码发现这题的链表最多有8029个节点，跑完8029个后如果还没结束就说明有环。哈哈哈，为了能过一道题真是无所不用其极。 这是一道很简单的题，做出来可能只需要5分钟，但是在整理这道题时我花了1个小时，学习就是这个样子，不怕折腾。 ","date":"2022-03-05","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/:2:3","tags":null,"title":"环形链表——哈希、链表、双指针","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["刷题"],"content":"题目 该题来自：https://leetcode-cn.com/problems/merge-sorted-array/ 88. 合并两个有序数组 难度简单1308收藏分享切换为英文接收动态反馈 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 **注意：**最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 \u003c= m, n \u003c= 200 1 \u003c= m + n \u003c= 200 -109 \u003c= nums1[i], nums2[j] \u003c= 109 ","date":"2022-03-04","objectID":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/:1:0","tags":null,"title":"合并两个有序数组——数组、双指针、排序——这题的题解绝了","uri":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/"},{"categories":["刷题"],"content":"题解 法一：直接合并后用sort()排序 本来以为会禁用STL，但是竟然没有，这种方法能过也是出乎我的意料。代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { for(int i=m;i\u003cm+n;i++){ nums1[i] = nums2[i-m]; } sort(nums1.begin(),nums1.end()); } }; 而且还超过了百分之百的用户，笑死，赶紧截图纪念。 sort()函数可以套用快速排序的时间复杂度和空间复杂度，都为O((m+n)log(m+n))。 法二：双指针 利用一个重要性质：nums1和nums2都是有序数组。 用两个指针p1和p2分别指向nums1和num2的头部，然后比较nums[p1]和nums[p2]，将较小的那个数的指针（比如p1）往后移（p1++）。有点像归并排序。 这个图非常生动形象： 代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 \u003c m || p2 \u003c n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] \u003c nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 两指针最多移动m+n次，因此时间复杂度O(m+n)。为防止覆盖，需要新建m+n长度的数组，因此空间复杂度为O(m+n)。 法三：逆向双指针 怎么样不建立新的数组，直接利用nums1后面空余的部分呢？我们想到了让p1和p2两指针从后向前遍历，每次取最大的那个数放在nums1的最后面。 但是有一个前提，在从后向前填的过程中会不会覆盖nums1前面的数字呢？答案是不会，下面证明： 在遍历的任一时刻，nums1数组中有m-p1-1个元素被放入nums1的最后面，nums2数组中有n-p2-1个元素被放入nums1的最后面。而在指针p1的后面，nums1数组有m+n-p1-1个位置。 由于 $$ m+n-p1-1 \u003e= m-p1-1+n-p2-1 $$ 等价于 $$ p2\u003e-1 $$ 永远成立。所以不会被覆盖。 代码： class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 \u003e= 0 || p2 \u003e= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] \u003e nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 看完这个题解我真是觉得太牛逼了。 时间复杂度O(m+n)，因为不需要额外数组，所以空间复杂度O(1)。 ","date":"2022-03-04","objectID":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/:2:0","tags":null,"title":"合并两个有序数组——数组、双指针、排序——这题的题解绝了","uri":"/posts/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8E%92%E5%BA%8F%E8%BF%99%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%E7%BB%9D%E4%BA%86/"},{"categories":["刷题"],"content":" 该题目来自：https://leetcode-cn.com/problems/valid-sudoku/ ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:0:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题目 36. 有效的数独 难度中等786收藏分享切换为英文接收动态反馈 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：true 示例 2： 输入：board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字（1-9）或者 '.' ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:1:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题解 呜呜呜，像我这种臭鱼烂虾也配做出leetcode中等难度的题了吗？ 我的方法，分别扫描行、扫描列、扫描九宫格，三次遍历得出结果： class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { unordered_set\u003cint\u003e hashset; // 扫描行 for(int i=0;i\u003c9;i++){ for(int j=0;j\u003c9;j++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } hashset.clear(); } // 扫描列 for(int j=0;j\u003c9;j++){ for(int i=0;i\u003c9;i++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } hashset.clear(); } // 扫描九宫格 for(int m=0;m\u003c3;m++){ for(int n=0;n\u003c3;n++){ //拆成3*3的九宫格 for(int i=m*3;i\u003c(m+1)*3;i++){ for(int j=n*3;j\u003c(n+1)*3;j++){ if(board[i][j]!='.'){ if(hashset.find(board[i][j])!=hashset.end()){ // cout \u003c\u003c \"出问题了\" \u003c\u003c i \u003c\u003c j \u003c\u003c endl; return false; } hashset.insert(board[i][j]); } } } hashset.clear(); } } return true; } }; 大佬的方法，一次遍历就行了： class Solution { public: bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) { int rows[9][9]; int columns[9][9]; int subboxes[3][3][9]; memset(rows,0,sizeof(rows)); memset(columns,0,sizeof(columns)); memset(subboxes,0,sizeof(subboxes)); for (int i = 0; i \u003c 9; i++) { for (int j = 0; j \u003c 9; j++) { char c = board[i][j]; if (c != '.') { int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; subboxes[i / 3][j / 3][index]++; if (rows[i][index] \u003e 1 || columns[j][index] \u003e 1 || subboxes[i / 3][j / 3][index] \u003e 1) { return false; } } } } return true; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode-solution-50m6/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 节省遍历次数的关键是创建了三个数组， rows[i][index]记录当前数字index在第i行出现的次数。 columns[j][index]记录当前数字index在第j列出现的次数。 subboxes[i/3][j/3][index]记录当前数字index在第[i/3][j/3]个九宫格中出现的次数。 因为有确定的遍历次数和确定的数组大小，所以时间和空间复杂度都是O(1) ","date":"2022-03-03","objectID":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/:2:0","tags":null,"title":"有效的数独——数组、哈希表、矩阵","uri":"/posts/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"题目 该题目来自：https://leetcode-cn.com/problems/two-sum/ 1. 两数之和 难度简单13591收藏分享切换为英文接收动态反馈 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ ","date":"2022-03-02","objectID":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/:1:0","tags":null,"title":"由和找到两数——数组、哈希表","uri":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["刷题"],"content":"题解 最简单的暴力： class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { for(int i=0;i\u003cnums.size()-1;i++){ for(int j=i+1;j\u003cnums.size();j++){ if(nums[i] + nums[j] == target){ return {i, j}; } } } return {}; } }; 时间复杂度：O(N^2) 空间复杂度：O(1) 哈希表： 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以优化的地方就是对于每个元素x，寻找target-x可以改用哈希表寻找，速度可以从O(N)降到O(1)。 只遍历一遍nums数组，对于每个x，寻找target-x是否在哈希表中，如果不在就把x插入到哈希表中。 class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { unordered_map\u003cint, int\u003e hashtable; for (int i = 0; i \u003c nums.size(); ++i) { auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) { return {it-\u003esecond, i}; } hashtable[nums[i]] = i; } return {}; } }; 时间复杂度：O(N) 空间复杂度：O(N) 代码解释： hashtable: 由键-值组成（都是int类型）在这道题里键是nums[i]，值是索引i。 it-\u003esecond: it是迭代器，it-\u003esecond表示访问值，同理it-\u003efirst访问键，也可以写成(*it).second，(*it).first。 ","date":"2022-03-02","objectID":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/:2:0","tags":null,"title":"由和找到两数——数组、哈希表","uri":"/posts/%E7%94%B1%E5%92%8C%E6%89%BE%E5%88%B0%E4%B8%A4%E6%95%B0%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"categories":["技能分享"],"content":"yolov5训练自己的目标检测模型 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:0:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"yolov5 yolo是当前最火的目标检测模型之一，效果很好速度很快，也很适合小白上手。yolov5是yolo的第五代模型。 项目地址：https://github.com/ultralytics/yolov5 克隆下来之后，用pycharm打开，选择3.8版本的python解释器，自动安装依赖。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:1:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"制作数据集 数据集在线打标网站：https://www.makesense.ai/ 打标完成后可以下载符合yolo格式的txt文件。 然后需要对数据集进行组织。 我的数据集目录如下： screwdata ├── images │ ├── test │ │ ├── 若干测试图片.jpg │ └── train │ ├── 若干训练图片.jpg └── labels ├── test │ ├── 若干测试图片的标签.txt ├── train │ ├── 若干训练图片的标签.txt 注意：images目录下的图片文件名需和labels目录下的文件名保持一致（后缀名不同） 其中测试/训练图片的标签文件为文本文件，其格式如下： 0 0.991121 0.932710 0.017757 0.059813 0表示类别，这里我只用到一个类别，后面四个数字表示矩形选框四个顶点的位置。 还需准备一个yaml配置文件： # screwdata.yamltrain:/Users/sunbaile/yolov5/screw/images/train# 训练集pathval:/Users/sunbaile/yolov5/screw/images/test# 验证集path# Classesnc:1names:['screw_missing']# class names","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:2:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"训练 在yolov5根目录下有train.py文件，修改其data字段： parser.add_argument('--data', type=str, default=ROOT / 'data/screwdata.yaml', help='dataset.yaml path') # screwdata.yaml就是前面配置的数据集配置文件 右键运行即可开始训练，训练结果会保存到runs/train目录下。 可以使用colab提供的免费gpu算力进行训练，亲测很好用： https://colab.research.google.com/ 训练完把权重下载下来即可。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:3:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"推理 负责推理的文件是detect.py。 使用命令行工具进行推理，在终端键入： python detect.py --source 图片路径 --weights 权重路径 举个例子： python detect.py --source /Users/sunbaile/yolov5/screw/images/test/CPU风扇-缺2颗螺丝2.jpg --weights /Users/sunbaile/yolov5/runs/train/exp/weights/best.pt --conf-thres 0.5 # 这里我加了一个conf-thres 0.5 表示置信度高于0.5才标记 推理结果保存在runs/detect/exp 效果不错！ ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:4:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["技能分享"],"content":"参考资料 目标检测 YOLOv5 开源代码项目调试与讲解实战【土堆 x 布尔艺数】: https://www.bilibili.com/video/BV1tf4y1t7ru?p=8\u0026spm_id_from=333.1007.top_right_bar_window_history.content.click 感谢土老师的教学视频。 ","date":"2022-02-28","objectID":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/:5:0","tags":null,"title":"Yolov5训练自己的目标检测模型","uri":"/posts/yolov5%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["刷题"],"content":"题目 来自：https://leetcode-cn.com/problems/maximum-subarray/ 53. 最大子数组和 难度简单4424收藏分享切换为英文接收动态反馈 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 ","date":"2022-02-28","objectID":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/:1:0","tags":null,"title":"最大子数组和——动态规划、分治","uri":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/"},{"categories":["刷题"],"content":"题解 法一：动态规划 用一个数组f[i]表示以第i个元素结尾的具有最大和的连续子数组，i从0开始。有如下式子： f[i] = max( f[i-1]+nums[i] , nums[i] ) 这样就可以递推求出所有的f[i]啦。代码如下： class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { int f[100001]; f[0] = nums[0]; int max_num = f[0]; for(int i=1;i\u003cnums.size();i++){ f[i] = max(f[i-1]+nums[i], nums[i]); max_num = max(max_num, f[i]); } return max_num; } }; 我这里写的很简陋，力扣官方给的题解说的很清楚：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/ 法二：分治 因为用法一把这题过了，懒得看法二了… ","date":"2022-02-28","objectID":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/:2:0","tags":null,"title":"最大子数组和——动态规划、分治","uri":"/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%B2%BB/"},{"categories":["刷题"],"content":"题目 该题来自：https://leetcode-cn.com/problems/contains-duplicate/ [217. 存在重复元素] 难度简单635收藏分享切换为英文接收动态反馈 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1] 输出：true 示例 2： 输入：nums = [1,2,3,4] 输出：false 示例 3： 输入：nums = [1,1,1,3,3,4,3,2,4,2] 输出：true 提示： 1 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 ","date":"2022-02-26","objectID":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/:1:0","tags":null,"title":"存在重复元素——排序、哈希","uri":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"categories":["刷题"],"content":"题解 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode-sol-iedd/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 法一：最慢的方法，把nums中的每个元素都拿出来，遍历nums数组找一下看有没有跟它相同的元素。时间复杂度O(n^2) 法二：用sort函数排个序，相同的元素会被排到一块儿，遍历一遍nums数组就找到了。思路很简单，但还是不够优雅。时间复杂度O(nlogn) 补充一下c++中的sort函数： sort(first_pointer,first_pointer+n,cmp) 该函数可以给数组，或者链表list、向量排序。 实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。 此函数有3个参数： 参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。 参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。 参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。 代码： class Solution { public: bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i \u003c n - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; } }; 法三（最优）：将nums数组中的每个元素插入哈希表，如果发现已存在，则说明有重复。时间复杂度O(N) 代码： class Solution { public: bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { unordered_set\u003cint\u003e s; for (int x: nums) { if (s.find(x) != s.end()) { return true; } s.insert(x); } return false; } }; ","date":"2022-02-26","objectID":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/:2:0","tags":null,"title":"存在重复元素——排序、哈希","uri":"/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"categories":["刷题"],"content":"题目 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-the-town-judge 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么： 小镇法官不会信任任何人。 每个人（除了小镇法官）都信任这位小镇法官。 只有一个人同时满足属性 1 和属性 2 。 给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。 如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。 示例 1： 输入：n = 2, trust = [[1,2]] 输出：2 示例 2： 输入：n = 3, trust = [[1,3],[2,3]] 输出：3 示例 3： 输入：n = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 ","date":"2022-02-25","objectID":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/:1:0","tags":null,"title":"找到小镇的法官——图论入门","uri":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/"},{"categories":["刷题"],"content":"题解 先吐槽一下：今天是开学第五天，是我第五次来图书馆。没办法，像我这种生活极不充实的人就只能在图书馆消磨时光。 回到正题：这是一道图论入门题目。把小镇上的每个人作为一个节点，信任关系作为边，那么所谓的“法官”其实就是出度为0，入度为n-1的节点。所以解体思路就是通过遍历trust数组把每个节点的出度和入度统计出来就可以啦。 代码： class Solution { public: int findJudge(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 trust) { vector\u003cint\u003e inDegrees(n + 1); vector\u003cint\u003e outDegrees(n + 1); for (auto\u0026 edge : trust) { int x = edge[0], y = edge[1]; ++inDegrees[y]; ++outDegrees[x]; } for (int i = 1; i \u003c= n; ++i) { if (inDegrees[i] == n - 1 \u0026\u0026 outDegrees[i] == 0) { return i; } } return -1; } }; 其中auto的意思是自动确定变量类型。关于“\u0026”的用法我还没搞明白。 ","date":"2022-02-25","objectID":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/:2:0","tags":null,"title":"找到小镇的法官——图论入门","uri":"/posts/%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/"},{"categories":["刷题"],"content":" 完全背包问题和01背包问题的区别就是完全背包问题不限制物体的数量。 题目链接：https://www.acwing.com/problem/content/3/ 有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。 第 ii 种物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目 输入格式 第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0\u003cN,V≤10000\u003cN,V≤1000 0\u003cvi,wi≤10000\u003cvi,wi≤1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 10 ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题解 参考作者：Charles__ 链接：https://www.acwing.com/solution/content/5345/ 来源：AcWing 在01背包问题中，有一段判断装不装该物品的代码： for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { // 当前背包容量装不进第i个物品，则价值等于前i-1个物品 if(j \u003c v[i]) f[i][j] = f[i - 1][j]; // 能装，需进行决策是否选择第i个物品 else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } 我们可以用一个0到1的k循环改写，k的物理意义是物品的数量： for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=m;j++) { for(int k = 0 ; k*v[i]\u003c=j\u0026\u0026k\u003c=1 ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } } 当k=0时，f[i][j] = f[i-1][j]; 当k=1时（k*v[i]\u003c=j的约束条件保证背包可以装得下）， f[i][j] =max(f[i][j],f[i-1][j-v[i]]+w[i]) =max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 这样我们就可以推广01背包问题到完全背包问题啦，完全背包问题的答案如下： #include\u003ciostream\u003eusing namespace std; const int N = 1010; int f[N][N]; int v[N],w[N]; int main() { int n,m; cin\u003e\u003en\u003e\u003em; for(int i = 1 ; i \u003c= n ;i ++) { cin\u003e\u003ev[i]\u003e\u003ew[i]; } for(int i = 1 ; i\u003c=n ;i++) for(int j = 0 ; j\u003c=m ;j++) { for(int k = 0 ; k*v[i]\u003c=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } cout\u003c\u003cf[n][m]\u003c\u003cendl; } but，这样写性能貌似不太行啊，还得优化： 大佬通过数学推导，把循环都给破解了，核心代码优化成这样： for(int i = 1 ; i \u003c=n ;i++) for(int j = 0 ; j \u003c=m ;j++) { f[i][j] = f[i-1][j]; if(j-v[i]\u003e=0) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } 后面还能继续优化！但是到这里这道题已经能ac了，我这个懒逼就不继续思考了。 最终代码： #include \u003ciostream\u003e using namespace std; const int MAXN = 1005; int v[MAXN]; // 体积 int w[MAXN]; // 价值 int f[MAXN][MAXN]; // f[i][j], j体积下前i个物品的最大价值 int main(){ int n,m; cin \u003e\u003e n \u003e\u003e m; for(int i=1;i\u003c=n;i++){ cin \u003e\u003e v[i] \u003e\u003e w[i]; } for(int i = 1 ; i \u003c=n ;i++) for(int j = 0 ; j \u003c=m ;j++) { f[i][j] = f[i-1][j]; if(j-v[i]\u003e=0) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } cout \u003c\u003c f[n][m] \u003c\u003c endl; return 0; } ","date":"2022-02-23","objectID":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"完全背包问题——动态规划——这道题解是认真写的qwq","uri":"/posts/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":" 题目来自：https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=UwJf7O4w1mYDi1yfimoQC3A85cwxyluK0ixh0ZlBDLqKKVOlEWEHJVbdE4OlzzVr\u0026search_content=%E8%83%8C%E5%8C%85 有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 ii 件物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0\u003cN,V≤10000\u003cN,V≤1000 0\u003cvi,wi≤10000\u003cvi,wi≤1000 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 难度：简单 时/空限制：1s / 64MB 总通过数：95474 总尝试数：158804 来源：背包九讲 , 模板题 算法标签 题解 #include\u003cbits/stdc++.h\u003e using namespace std; const int MAXN = 1005; int v[MAXN]; // 体积 int w[MAXN]; // 价值 int f[MAXN][MAXN]; // f[i][j], j体积下前i个物品的最大价值 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= m; j++) { // 当前背包容量装不进第i个物品，则价值等于前i-1个物品 if(j \u003c v[i]) f[i][j] = f[i - 1][j]; // 能装，需进行决策是否选择第i个物品 else f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } cout \u003c\u003c f[n][m] \u003c\u003c endl; return 0; } 作者：深蓝 链接：https://www.acwing.com/solution/content/1374/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 感想 01背包问题可以衍生出很多题目，是很重要的问题。 核心公式 // 状态转移方程 dp[i][k] = max(value[i] + dp[i-1][k-weight[i]], dp[i-1][k]) 理解： 看这个博客讲的特别好https://www.cnblogs.com/kkbill/p/12081172.html ","date":"2022-02-22","objectID":"/posts/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"01背包问题——动态规划","uri":"/posts/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":" 洛谷P1359 租用游艇 https://www.luogu.com.cn/problem/solution/P1359 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"题目描述 长江游艇俱乐部在长江上设置了 nn 个游艇出租站 1,2,\\cdots,n1,2,⋯,n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 ii 到游艇出租站 jj 之间的租金为 r(i,j)r(i,j)（1\\le i\\lt j\\le n1≤i\u003cj≤n）。试设计一个算法，计算出从游艇出租站 11 到游艇出租站 nn 所需的最少租金。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输入格式 第一行中有一个正整数 nn，表示有 nn 个游艇出租站。接下来的 n-1n−1 行是一个半矩阵 r(i,j)r(i,j)（1\\le i\u003cj\\le n1≤i\u003cj≤n）。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输出格式 输出计算出的从游艇出租站 11 到游艇出租站 nn 所需的最少租金。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"输入输出样例 输入 #1复制 3 5 15 7 输出 #1复制 12 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:4:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"说明/提示 n\\le 200n≤200，保证计算过程中任何时刻数值都不超过 10^6106。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:5:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"解法 #include\u003ciostream\u003e#include\u003ccmath\u003eusing namespace std; int a[201][201],i,j,n,dp[201]; int main(){ cin\u003e\u003en; for(i=1;i\u003cn;i++){ for(j=i+1;j\u003c=n;j++) cin\u003e\u003ea[i][j]; dp[i]=1e9;//初始化数组dp，使它 } for(i=n-1;i\u003e=1;i--)//跑n上流的中转站 for(j=i+1;j\u003c=n;j++)//跑i下流的所有中转站 dp[i]=min(dp[i],a[i][j]+dp[j]);//记录 cout\u003c\u003cdp[1]; return 0; } ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:6:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["刷题"],"content":"感受 第一次做动态规划，没啥思路，代码是复制别人的题解，代码很巧妙，当n=3时，dp[3]=0，从后往前找最短路径，使得代码很简洁。 ","date":"2022-02-21","objectID":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:0","tags":null,"title":"租用游艇——动态规划","uri":"/posts/%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["随笔杂记"],"content":"今天是大二下学期开学第一天。恭喜我，又是孤单一人了。既然是一个人，那就要自己对自己好好负责咯，一个人的话，立的flag其实更能坚持下去！ ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:0:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"把自己打扮的干净整洁 把自己打扮的干净整洁是我这学期立的第一个flag。每次我从学校回家时我妈都会说一句：“你怎么搞糟的这么脏！” 上学期我确实不注重卫生，一天只刷一次牙，洗脸不用毛巾也不用洗面奶，内衣攒够一盆才洗…不脏才怪，我才20岁，看起来却像28岁，走进店里营业员叫我 “先生您好”。造成这个的原因有两个，一方面是我缺少生活经验，另一方面是我太懒。 用白泥面膜，好好洗脸。 衣服挂在衣柜里，不要随便扔床上或者板凳上。 勤打热水，勤洗衣服。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:1:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"做算法题 每次一想到算法我都特别愧疚。大一没进入acm社团，大二csp认证没考过，数据结构学的也一般。算法可能是区分普通程序员和高级程序员的最重要指标，可我却一次又一次错过提升算法能力的机会。 定个小目标： 每次去图书馆自习的时候做一道算法题。 这个目标只要稍微踮一踮脚尖就能够得到，我不想把目标定的太高让自己很快就放弃。为什么是去图书馆呢？因为这学期课很少，不在上课的话，我基本都会去图书馆，在图书馆呆的时间应该会非常长。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:2:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"继续锻炼 我还记得我上大学第一堂体育课，那个教篮球的白发苍苍的老教练跟我们说：“大学四年，你呆的最多的地方应该是图书馆和体育场。” 如果图书馆能按去的次数评等级的话，那我一定是黄金vip。体育场也要坚持去呀。表哥是我非常崇拜的人，他也鼓励我让我多锻炼。我最喜欢的锻炼就是跑步，跑步的时候大脑放空，跑完3公里，大汗淋漓，感觉自己的身心都得到了净化，感觉自己更强了，更有力量了，就像被充了电一样。 这学期的目标是跑150公里。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:3:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"读书并写读书笔记 这一年要读25本书。 读书既是对自己长期的投资，也是消磨时间的好方法。光读书不做笔记就像光吃饭不消化一样没用，不能陷入只读书的死循环。一本书带给人的影响是暂时的，读完之后记忆会慢慢淡忘，但是一旦拿起笔记录下来，那书中的知识才会悄无声息的变成自己的知识。书读的好，不代表读书笔记写的好，但读书笔记写的好，书读的一定好。因此，我以后要花很多精力放在写读书笔记上面，力求写出高质量的读书笔记。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:4:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["随笔杂记"],"content":"背单词 这个就没啥好说的，以后读论文，写论文都是全英文，英文太重要了。况且英语也不是一天两天学成的，每天背单词就对了。另外，用百词斩太被动了，墨墨背单词比较主动，更有用。 ","date":"2022-02-21","objectID":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/:5:0","tags":null,"title":"又到了立flag的时候啦","uri":"/posts/%E5%8F%88%E5%88%B0%E4%BA%86%E7%AB%8Bflag%E7%9A%84%E6%97%B6%E5%80%99%E5%95%A6/"},{"categories":["书影记录"],"content":"雪国 雪国是远离繁华都市，如世外桃源一般的地方。在小说的开头写道： 穿过县界长长的隧道，便是雪国。 夜空下一片白茫茫。 主人公岛村每年都会独自来雪国度假，在这里他结识了一个叫驹子的姑娘，岛村被驹子的活泼美丽打动，两人情投意合，开始交往。同时另一个叫叶子的姑娘，她纯粹空灵的气质，更让岛村着迷。故事的情节非常简单，就连故事的背景雪国都是白茫茫一片，十分纯净的，但是作者通过对故事片段细腻的描写表达出那种感伤的美让人印象深刻。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"川端康成 作者川端康成的一生命途多舛，2岁丧父，3岁丧母，10岁姐姐去世，15岁祖父去世，世上再无亲人。因此他的文学作品多带有淡泊的感伤色彩和物哀美。1968年，以《雪国》《古都》《千只鹤》三部代表作获得诺贝尔文学奖。初读《雪国》，想起这是一本诺奖作品，还有点儿生畏，但又一想，我阅读文学作品毕竟不是做高考阅读题，不需要一字一句斟酌，只要用心去感受就可以了，便放下心来开始阅读。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"驹子和叶子 驹子是一个活泼可爱，敢爱敢恨的女孩。文中不乏对她美貌的描写，比如： ​ 玲珑而悬直的鼻梁，虽嫌单薄些，但在下方搭配着的小巧的紧闭的柔唇，却苑如美极了的水蛭环节，光滑而伸缩自如，在默默无言中也有一种动的感觉。如果嘴唇起了皱纹，或者色泽不好，就会显得不洁净。她的嘴唇却不是这样，而是滋润光泽的。两只眼晴，眼梢不翘起也不垂下，简直像有意描直了似的，虽逗人发笑，却恰到好处地镶嵌在两道微微下弯的浓密的短眉毛下。颧骨稍耸的圆脸，轮廓一般，但肤色恰似在白瓷上抹了一层淡淡的胭脂。脖颈底下的肌肉尚未丰满。她虽算不上是个美人，但比谁都要显得洁净。 ​ 对一个当过舞伎的女子来说她的胸脯算是有点挺的。 她爱上了来自东京的岛村后，不顾一切的接近他，调皮又任性。比如常在醉酒后闯入岛村的屋子： 但是，没过十分钟，驹子就拖着碎乱的脚步走了进来。 “刚才那孩子送什么来没有？” “送来了。” “是吗？”她快活地眯缝着一只眼睛说，“唔，真痛快。我说去叫酒，就偷偷地溜了出来。被掌柜发现，挨了一顿骂。酒真好呢，即使挨骂，我也不在乎。啊，真讨厌，一来到这里就醉了。我还得去啊。” 大胆的表达自己的情感，敢爱敢恨： “才不呢。我才不干这种可怜巴巴的事。那种给你太太看见也无所谓的信，我才不写呢。那样做多可怜啊！我用不着顾忌谁而撒谎呀！” 驹子抢着反驳，语气非常激烈。岛村低下了头。 电影《雪国》\" 电影《雪国》 而叶子的形象是更加纯净的，空灵的，虚幻的。 ​ 黄昏的景色在镜后移动着。也就是说，镜面映现的虚像与镜后的实物在晃动，好像电影里的叠影一样。出场人物和背景没有任何联系。而且人物是一种透明的幻象，景物则是在夜霭中的朦胧暗流，两者消融在一起，描绘出一个超脱人世的象征世界。特别是当山野里的灯火映照在姑娘的脸上时，那种无法形容的美，使岛村的心都几乎为之颤动。 ​ 在遥远的山巅上空，还淡淡地残留着晚霞的余晖。透过车窗玻璃看见的景物轮廓，退到远方，却没有消逝，但已经黯然失色。尽管火车继续往前奔驰，在他看来，山野那平凡的姿态显得更加平凡。由于什么东西都不十分惹他注目，他内心反而好像隐隐地存在着一股巨大的感情激流。这自然是由于镜中浮现出姑娘的脸的缘故。只有身影映在窗玻璃上的部分，遮住了窗外的暮景，然而，景色却在姑娘的轮廓周围不断地移动，使人觉得姑娘的脸也像是透明的。是不是真的透明呢？这是一种错觉。因为从姑娘面影后面不停地掠过的暮景，仿佛是从她脸的前面流过。定睛细看，却又扑朔迷离。 ​ 车厢里也不太明亮。窗玻璃上的映像，不像真的镜子那样清晰。没有反光。这使岛村看得入了神，他渐渐地忘却了镜子的存在，只觉得姑娘好像漂浮在流逝的暮景之中。 ​ 这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯火。灯火也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜光虫，妖艳而美丽。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"岛村 岛村是一个来自东京的富二代，他在东京有家室，但还是每年来到雪国这样一个偏僻的地方寻花问柳。可以把他理解为渣男。 岛村第一次见到驹子时，对她的第一印象是洁净，文中说： 女子给人的印象洁净得出奇，甚至令人想到她的脚趾弯里大概也是干净的。 但是当岛村第二次见到驹子时，她已经沦为了艺妓。岛村的反应是： 看到衣服下摆，岛村不由得一惊：她到底还是当艺妓了么？！ 在得到驹子的肉体之后，渣男岛村并没有满足，他开始想念得不到的叶子： 然而，一想起叶子在这家客栈里，不知为什么，岛村对找驹子也就有点拘束了。尽管驹子是爱他的，但他自己有一种空虚感，总把她的爱情看作是一种美的徒劳。即使那样，驹子对生存的渴望反而像赤裸的肌肤，触到了他的身上。他可怜驹子，也可怜自己。他似乎觉得叶子的慧眼放射出一种像是看透这种情况的光芒。他也被这个女子吸引了。 川端康成揭露了男人怪癖的一面，男人想要自己的女人对自己一个人有百种风情，却对除了自己以外的人敬而远之。他既渴望热情奔放的肉体，又渴望纯洁无暇的灵魂。在小说中，驹子就是热情奔放的肉体，叶子是纯洁无暇的灵魂。 但是纯洁无暇的灵魂可能仅存在于想象之中吧，连故事中的叶子，最后也被大火烧死了。 ","date":"2022-02-13","objectID":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"《雪国》读书笔记","uri":"/posts/%E9%9B%AA%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"记录寒假学做饭 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:0","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"故事起因 放假前刷到b站一个热门视频，惊呼：“做饭竟然这么简单？” 再想到假期在家要天天忍受我妈做的“没有技巧，全是感情”的饭，嘴里的口水从眼睛里流了出来😭。反正我在家也很闲，那就立个学做饭的flag吧！💪 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:1","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"1.家庭烤肉 其实这个不是自己做的是我姐做的，我只是想把它放在第一位撑撑场子… 在青岛上学过的太穷酸了，回家后吃这一顿真是解了大馋😋 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:2","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"2.自制盖浇饭 一顿烤肉带来的美味可不止一顿烤肉。剩下的鸡翅跟浸着鲜肥汤汁的青菜一起铺在剩米饭上，放微波炉热一分钟又是绝佳美味。 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:3","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"3.溏心鸡蛋 别嘲讽我不会做饭，这不从头学着嘛。万事开头难，我可不想一开头就被打倒，就挑了个简单的溏心鸡蛋做。不过话说回来，溏心鸡蛋真的好简单，记住开水煮6分钟，我一次就成功啦，一下子做饭就有信心了。 （ps：记得吃溏心蛋要买无菌鸡蛋） ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:4","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"4.面包夹煎鸡蛋 把面包和鸡蛋放进锅里一起煎，面包焦了，鸡蛋还没熟透！不过咬下去外焦里嫩，别有一番风味，这算是成功了还是失败了呢？ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:5","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"5.煎牛排 真不是我煎得好，是必胜客的速食牛排牛逼。😂 早上花五分钟煎个西冷牛排，看它在锅里发生梅拉德反应，真是能唤醒一天的活力呢！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:6","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"6.鸡蛋酱 鸡蛋+豆瓣酱，第一次吃美艳！第二次吃腻死了qwq 你要是问我为啥总是跟鸡蛋过不去，我的回答是因为我在跟这个视频学…5天60颗鸡蛋，13个难度19种吃法，尽管收藏，我还能卷自己 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:7","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"谁还不是个小馋猫呢？ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:8","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"7.羊肉串 参考这个视频大厨分享烤串店火了20年的秘制调料配方，免费分享大家，太受用了 前一天晚上我就开始腌羊肉，加了不少调料。记得最清楚的是加鸡蛋和淀粉是为了让羊肉滑腻，烤的时候不容易变柴。 第二天跟基友去买菜，顺便整个活儿 中午烤串，没想到第一次做竟然这么成功！跟烧烤店味道一样，而且自己做的串更大更爽，吃起来嘎嘎香。 ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:9","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"8.西红柿鸡蛋方便面 请我姐吃旋转小火锅，她答应给我做一顿早餐。做什么呢，就做西红柿鸡蛋方便面吧。 这碗面煮的绝了，汤汁不浓不淡，面条不硬不糊，鸡蛋圆滚滚的也很可爱。真是把方便面的价值都榨干啦。 再看看我做的，汤不是太多就是太少，厨艺有待加强！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:10","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"下雪啦！ 雪景好好看呀，就是太冷了… ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:11","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"9.火锅 那么冷的天，最幸福的事情当然是吃热腾腾的火锅呀。底料用牛骨汤+海底捞清油火锅底料，味道应该是鲜味不是辣味吧？ 艹，好辣啊。全家就我一个人吃到最后qwq ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:12","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["随笔杂记"],"content":"10.烤鸡翅 空气炸锅到货啦，第一件事当然是拿来烤鸡翅咯。 不得不说，空气炸锅烤鸡翅真的超级无敌方便。鸡翅直接买超市腌好的，放在锡纸上丢进空气炸锅200度烤18分钟就可以啦。吃完连锅都不用洗！ ","date":"2022-02-02","objectID":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/:0:13","tags":null,"title":"记录寒假学做饭","uri":"/posts/%E8%AE%B0%E5%BD%95%E5%AF%92%E5%81%87%E5%AD%A6%E5%81%9A%E9%A5%AD/"},{"categories":["书影记录"],"content":"半泽直树 半泽直树是日本电视剧《半泽直树》中的主人公。半泽的家族经营了一家小公司，在半泽年幼时，日本遇到了经济泡沫，公司急需贷款，但银行对此不但见死不救，还落井下石，逼死了半泽的父亲。大学毕业后，半泽竟选择进入银行工作，立志要找到害死父亲的人，并完成复仇。电视剧的主要讲述的，就是半泽如何传奇般的一步一步完成自己的复仇计划的故事。剧中有很多半泽直怼上司的剧情，让人看了大呼过瘾，半泽直树也被网友称为“最强打工人”。 ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人物塑造 半泽直树：在职场上，半泽是一个十分有魄力、有胆识的好员工。同时，他也是个顾家爱老婆的好男人。他有很多好品质，剧中突出表现的，是他敢于挑战权威，说白了就是敢于跟领导硬刚。半泽有一句经典台词： 以牙还牙，加倍奉还！ 眼看着自己的父亲被逼死，年幼的半泽心里埋下了仇恨的种子。电视剧把人物塑造的非常立体，之后半泽做的每一个决定，都有背景故事支持。 两个基友：其中一个基友渡真利长得好帅。另一个基友近藤是一个更贴近生活的形象，在工作上受尽了挫折，差点精神分裂。当受到诱惑时，心中的正义也没能战胜邪恶。 大和田常务：为人圆滑，城府很深，经典的上司形象。记住这个演员叫香川照之，演的非常好！ ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情思考 前方轻微剧透 这里主要讨论第一季最后的结局： 我想说的是：意料之外，情理之中。古人说，**木秀于林，风必摧之；堆出于岸，流必湍之，行高于人，众必非之。**半泽的表现太过于惹人眼球，对行长来说是一个威胁，必然要给他一个下马威。 另一方面，半泽并不完全是正义的化身，他为了实现自己的复仇，也用了很多见不得人的手段。半泽说：“以牙还牙，加倍奉还”。他这么说，最后也确实做到了。这样的剧情确实让人热血沸腾，看完之后我也想学半泽去狠狠地锤自己的上司。但我们毕竟不是半泽，只是普通人，现实中这么做肯定是会死得很惨的qwq。而且我们当今社会，提倡的也不是“以牙还牙，加倍奉还”，而是“毋忘前耻，振兴中华”。导演让半泽说出这样的台词，只是让观众爽一爽罢了，这样的价值观是不被提倡的。 但是我们作为打工人，就该替上司背锅吗？就该被踩在脚下不反击吗？当然不是，马克思告诉我们，当遇到不平等的待遇时，工人们要联合起来伸张正义。半泽的做法不可复制，但是半泽的精神值得我们奉为圭秀。加油吧，打工人！ ","date":"2022-02-01","objectID":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《半泽直树》观后有感","uri":"/posts/%E5%8D%8A%E6%B3%BD%E7%9B%B4%E6%A0%91%E8%A7%82%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"为什么抛弃wordpress选择hugo 不用买服务器了 wordpress经常奔溃，易受攻击 hugo编译速度真tm快 有一款钟爱的hugo主题 ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:1","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"文章迁移 文章迁移使用一个hexo插件（你没看错，就是hexo插件）。 首先新建一个hexo博客（用完就可以删了）。 $ hexo init \u003cfolder\u003e $ cd \u003cfolder\u003e $ npm install 再安装 hexo-migrator-wordpress 插件。 $ npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”) 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 $ hexo migrate wordpress \u003csource\u003e 文章很快就能出现在source/_posts目录下，转换效果特别棒。 ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:2","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"修改文章的属性 刚迁移完的每篇文章都有yaml配置，像这样： title:年度总结tags:[]id:'1191'categories:- - 生活date:2022-01-21 11:35:06其实直接丢到hugo的posts文件夹里也没问题，但咱最好还是自己改一下。比如改成这样： author: sunbaile categories: - 随笔杂记 date: 2022-01-21 11:35:06 draft: false title: 年度总结 写了一个python脚本，100多篇文章，1秒钟全搞定（写脚本写了一下午qwq)： import os import yaml import re path = \"/Users/sunbaile/myBlog/content/posts\" # path = \"/Users/sunbaile/myBlog/python脚本\" cnt = 0 for file in os.listdir(path): if file[-3:]==\".md\" : #判断是否为md文件 cnt += 1 print(cnt,file) with open(os.path.join(path,file),\"r+\") as f: all_text = f.read() yaml_text = re.findall(\"---([\\s\\S]*?)---\",all_text)[0] #找到yaml字符串 old_dic = yaml.load(yaml_text) # 用yaml库转字典对象 # print(\"categories:\",old_dic[\"categories\"]) new_dic = { \"title\": old_dic[\"title\"], \"author\": \"sunbaile\", \"draft\": False, \"categories\": old_dic['categories'], \"date\": old_dic[\"date\"] } # print(\"new_dic\",new_dic) yaml_res = yaml.dump(new_dic,allow_unicode=True) #用yaml库将字典解析为yaml字符串 # print(\"***\",yaml_res,\"***\") res = all_text.replace(yaml_text,\"\\n\"+yaml_res) with open(os.path.join(path,file),\"w+\") as f: f.write(res) ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:3","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"图片迁移 如果你打算用github+jsdelivr做图床，迁移图片更简单。思路就是先从服务器上把wordpress的wp-content目录（里面有个uploads文件夹存了你所有的图片）下载下来，然后原封不动的丢到github仓库里，最后把文章中的路径改一下就可以啦。 注意：每张图片都是由固定链接+路径+名字组成。 比如说原来文章的图片链接是这样的： ![](https://www.leyoubaloy.xyz/wp-content/uploads/2021/06/728da9773912b31b0c11b3568418367adab4e154.jpg) 或者是这样的： ![](/wp-content/uploads/2021/02/image-1-1024x431.png) 要替换成这样： ![](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/mypic/wp-content/uploads/2021/06/728da9773912b31b0c11b3568418367adab4e154.jpg) 和这样 ![](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/mypic/wp-content/uploads/2021/02/image-1-1024x431.png) 那肯定还是用python脚本啦，python，yyds! import os import re path = \"/Users/sunbaile/myBlog/content/posts\" # path = \"/Users/sunbaile/myBlog/python脚本\" cnt = 0 for file in os.listdir(path): if file[-3:]==\".md\" : cnt += 1 print(cnt,file) with open(os.path.join(path,file),\"r+\") as f: all_text = f.read() res = re.sub(\"\\((\\/wp-content\\/uploads)\",\"(https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/mypic/wp-content/uploads/\",all_text) res = res.replace(\"www.leyoubaloy.xyz\",\"cdn.jsdelivr.net/gh/leyouBaloy/mypic\") with open(os.path.join(path,file),\"w+\") as f: f.write(res) ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:4","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"视频教程： ","date":"2022-01-28","objectID":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/:0:5","tags":null,"title":"从wordpress迁移到hugo过程分享","uri":"/posts/%E4%BB%8Ewordpress%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"categories":["技能分享"],"content":"需求 很简单，就是想在gitee上一提交代码，服务器就自动执行一个sh脚本。脚本的内容就是把代码拉取下来。gitee webhook和sh脚本都好办，关键是如何让服务器监听webhook发来的请求。 在网上一搜，各路大神各显神通，有用jenkins的，有用php的，还有travis CI…各位大佬，我就想实现一个简单的小功能，用这么牛逼的工具真没必要qwq（求饶 终于在谷歌上（百度真的搜不到）搜到一个用nodejs解决的，确实很方便。原博主写的很好，但是有几个小坑，我在这里提醒一下。 版权声明：CSDN博主「如风521」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_31667715/article/details/100117028 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:1","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"什么是webhook webhook也叫钩子。粗浅的来说，就是你写一个小脚本，每次提交代码的时候，让gitee或者github帮你执行一下。重点是这个脚本是你自己编写的，但不是你自己执行的，是GitHub或者gitee帮你执行的。就像在钩子上放个东西，让人家帮你拉一下，所以叫钩子。 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:2","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"环境 Git ，这个服务器上肯定要装的 nodejs ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:3","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"配置公钥 配了公钥后，你打git clone (repo地址)就不用输入密码了。这个很简单，网上教程很多。 有个小坑：配完公钥后git仓库地址一定要用ssh，而不是https 成功的结果就是你打git clone的时候不用输入密码了 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:4","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"用nodejs监听web-hooks服务 创建目录，用npm初始化，下载插件gitee-webhook-handler（ps:用了nodejs才发现它有很多好用的插件： mkdir /usr/soft/web_hooks #创建目录 cd /usr/soft/web_hooks npm init npm install gitee-webhook-handler --save 创建js文件，按照自己的需求修改： var http = require('http') var createHandler = require('gitee-webhook-handler') var handler = createHandler({ path: '/webhooks_push', secret: '654321'}) //post 所需要用到的密码，自己设置，跟下面对应就行 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) { resp += buffer.toString(); }); child.stdout.on('end', function() { callback (resp) }); } handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('Push Hook', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); var name = event.payload.repository.name //这个name是仓库的名字 if (name === \"Gitee FeedBack\" || name === \"xaiweb\") { run_cmd('sh', ['/www/xaiweb/pull.sh'], function (text) {// 需要执行的脚本位置 console.log(text) }); }else { console.log(\"unknow repository name:\" + name); } }) try { http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6666) // 服务监听的端口，可以自行修改 }catch(err){ console.error('Error:', err.message) } 原博主的这里的name没有定义，看日志才发现问题。 还有个小坑，如果你用gitee的话，push代码和点击“测试”的时候name的值是不一样的。前者是\"Gitee FeedBack\"，后者是仓库名。（我的仓库名xaiweb gitee和github应该也不一样，总之，测试的时候多看日志，就能发现问题。（日志下面有 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:5","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"启动服务 下载forever，这个能解决node服务自动停掉的问题。-g是全局安装 npm install -g forever 把nodejs目录下的forever软链接到系统的/usr/bin目录下，这样就能全局访问了 ln -s /usr/local/node(这里可能不一样)/lib/node_modules/forever/bin/forever /usr/bin/forever 不知道nodejs目录在哪的打whereis node或者which node试试，注意，这样找到的目录可能不是原始目录，而是软连接目录。 启动： forever start -l ./forever.log -o ./out.log -e ./err.log webhook.js #第一次启动 forever start -a -l ./forever.log -o ./out.log -e ./err.log webhook.js #之后再启动打这个 这里给两个forever常用命令 forever list #列出服务，能看到日志在哪 forever stop + id或文件名 #停止服务 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:6","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"nginx反向代理 location ^~ /webhooks_push { proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:6666; } 如果你不会nginx也没啥问题，直接用ip:6666也行 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:7","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"gitee配置 密码就是跟上面那个对应的。 大功告成。 ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:8","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["技能分享"],"content":"1月31日补充 如果用GitHub： //webhook.js var http = require('http') var createHandler = require('github-webhook-handler') var handler = createHandler({ path: '/', secret: '密码' }) // 上面的 secret 保持和 GitHub 后台设置的一致 function run_cmd(cmd, args, callback) { var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function (buffer) { resp += buffer.toString(); }); child.stdout.on('end', function () { callback(resp) }); } http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6666) handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('push', function (event) { console.log('Received a push event form %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./pull.sh', event.payload.repository.name], function (text) { console.log(text) }); }) 请求：http://ip:6666/ content type: application/json ","date":"2022-01-25","objectID":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/:0:9","tags":null,"title":"gitee/github webhooks+nodejs实现自动拉取代码","uri":"/posts/gitee-webhooks+nodejs%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"categories":["随笔杂记"],"content":"读书和锻炼 书大概看了15本。书\\影评10个。 书看的多没用，写书评才是有用的，明年多写书评。 跑步202公里。明年继续。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"明年的计划 没什么计划， 就是继续读书、继续锻炼。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"大学 唯读书和锻炼二事不可辜负。 ","date":"2022-01-21","objectID":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"年度总结","uri":"/posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["书影记录"],"content":"明天也是小春日和 英子内心一直有一个田园梦，他的丈夫修一是建筑师，年轻时工作十分忙碌，但她始终支持丈夫的志愿。退休后，修一履行他的承诺，带着英子乔迁田野，在这里植树，建屋，耕作。 “小春日和”在日语中意指“晚秋到初冬里阳光和煦的好天气”。本书介绍了相伴走过近六十年的老人，在以自然为友，彼此相伴的每一天里，都是小春日和。 春有枝头新绿，秋有红叶满园，夏天茂盛的枝叶遮挡住阳光，带来纯天然的清凉，冬天落叶覆地，暖阳西照。一年四季，这片树林静静地守护着津端一家。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:1","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"“吃”是人生最重要的部分 英子女士记得小时候母亲经常亲手为家里人做面包等美味，并教导自己的女儿：“民以食为天，‘吃‘是人生中最重要的部分“。“吃”不仅是生活中最重要的部分，也是本书最重要的部分。在本书的众多插图中，一半以上都是跟“吃”有关的。 春天里，修一先生亲手用月桂熏制培根，伴随着四溢的香气与客人高谈畅饮；夏天，早餐的主食是刚从菜园采摘的玉米，放在庭前的七厘炭炉烤熟，再配上新鲜的蔬菜鸡肉沙拉，格外好吃；秋天，秋栗做成的栗金团味道自然甘怡，炖的烂熟的牛肉是滋补暖身的佳肴；到了冬天，先过新年再过生日，餐桌摆上了堪称豪华的料理，有烤全鸡、水果沙拉、年节菜和杂煮，每天都在吃大餐。除此之外，四季之中还有拌入艾草的捣年糕，鲜红欲滴的草莓酱，清凉爽口的大麦茶，看到就想流口水的梅干，别有一番风味的柚饼子和修一先生最爱的帕玛森干酪咸饼干。所有的美食都是亲手烹饪，厨具叮叮当当的声音是生活最美妙的伴奏。 春季大餐的必备菜是修一先生亲手熏制的培根。经历过无数次失败后，他终于摸索出了制作方法。往砖块搭成的熏炉里加入炭火，吊三块猪肉，用月桂等熏烤，有时会换种香叶，并没有特别的独家秘方。客人们伴着熏烤时飘出的香气畅饮高谈，正是所谓 “男人间的待客之道”。 美食与生活密不可分，会制作美食的人一定是会享受生活的人。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:2","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"可爱的修一先生 喜欢记录自己的生活： 修一先生非常擅于整理归纳，所做记录之详细，更是体现出他身为建筑师的职业素养。 是一个细心的“理工男”： 英子女士的性格粗枝大叶，修一先生却是个标准的“理科生”，凡事讲求细节，连文件夹封皮的颜色都十分讲究。 对新鲜事物永保热情： 修一先生永远保持着对外界新事物的热情。除了喜欢驾驶帆船，他在日本大地震发生后，曾坚持收集相关报道并剪辑成册；他还想淘一个工台，把粗木加工成器皿，把“自娱自乐”对精神发挥到极致。 认真的做每一件事： 英子女士笑着说：“修一打的邮包整齐漂亮，我就没那么细心了。““这个要放进去吗那个怎么弄？”修一先生边跟英子女士。确认，边细致地打包。 … ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:3","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["书影记录"],"content":"宁静的生活，时间一晃而过 穿林而过的秋风渐带凉意，夫妇二人开始更换家中的起居用品。为即将到来的冬天做准备。 橱柜里摆放的玻璃器皿换成了稳重而温润的陶器，床单、靠垫套则从棉麻布换成了蓬松柔软的毛织品。整间居室更显温暖舒适，老两口可以安心度过整个冬天。 从高高的东窗射人的晨光不知不觉落下，时间一晃就过去了。 ","date":"2022-01-17","objectID":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/:0:4","tags":null,"title":"《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴","uri":"/posts/%E6%98%8E%E5%A4%A9%E4%B9%9F%E6%98%AF%E5%B0%8F%E6%98%A5%E6%97%A5%E5%92%8C%E9%82%A3%E5%B9%B6%E4%B8%8D%E8%80%80%E7%9C%BC%E7%9A%84%E5%88%9D%E5%86%AC%E6%9A%96%E9%98%B3%E6%81%B0%E4%BC%BC%E4%BD%A0%E6%97%A5%E5%A4%8D%E4%B8%80%E6%97%A5%E6%9C%80%E9%95%BF%E6%83%85%E7%9A%84%E9%99%AA%E4%BC%B4/"},{"categories":["随笔杂记"],"content":"今天跟基友探店，找到一家主机游戏。 我俩对着超大屏幕玩双人成行玩一个小时笑一个小时。 老板说别人玩这个都对骂，就你俩一直笑。 我跟老板说这才是男人的默契。 去你妈的腾讯游戏，什么是游戏？这TM才叫游戏！ 不比女朋友好玩一百倍？ ","date":"2022-01-15","objectID":"/posts/%E8%B7%9F%E5%9F%BA%E5%8F%8B%E7%8E%A9%E5%8F%8C%E4%BA%BA%E6%88%90%E8%A1%8C%E8%BF%99%E8%BE%88%E5%AD%90%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E8%BF%87/:0:0","tags":null,"title":"跟基友玩双人成行这辈子没这么开心过","uri":"/posts/%E8%B7%9F%E5%9F%BA%E5%8F%8B%E7%8E%A9%E5%8F%8C%E4%BA%BA%E6%88%90%E8%A1%8C%E8%BF%99%E8%BE%88%E5%AD%90%E6%B2%A1%E8%BF%99%E4%B9%88%E5%BC%80%E5%BF%83%E8%BF%87/"},{"categories":["随笔杂记"],"content":"2020期末复习有感： 每门课复习时都要有一个抓手，这个抓手一定要足够可靠可信赖，它是你复习最主要的线索，当你把这条线索都走一遍后你要能自信的说你复习完了。 什么可以成为抓手呢？比如每次布置的作业，最好每次都自己写，写完不要随便一夹，要装订成册。再比如课本，平时就要通读，复习的时候再重新捋一遍。 这学期的线代和数电就没有抓手，复习的时候非常痛苦。手边的复习资料很多（没读过的课本，不配套的试卷，乱七八糟的习题），但很乱，不知道看哪一个，感觉知识点都是碎的，复习起来很没有动力，根本坐不住。这样复习不仅低效，而且很容易放弃。最后还是拿了别人的习题来当抓手。 ","date":"2022-01-15","objectID":"/posts/%E6%8A%8A%E5%8A%9F%E5%A4%AB%E7%94%A8%E5%9C%A8%E5%B9%B3%E6%97%B6/:0:0","tags":null,"title":"把功夫用在平时","uri":"/posts/%E6%8A%8A%E5%8A%9F%E5%A4%AB%E7%94%A8%E5%9C%A8%E5%B9%B3%E6%97%B6/"},{"categories":["随笔杂记"],"content":"十分精美的证书+《深度学习》+一双蓝色的袜子+单片机身份卡 最最最帅的就是这个单片机身份卡，太你妈的炸裂帅了 说实话，我真没给百度做过什么事情，以后也很难，有点愧对百度。 ","date":"2022-01-14","objectID":"/posts/%E7%99%BE%E5%BA%A6%E5%AF%84%E7%9A%84%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A4%BC%E5%93%81%E6%83%8A%E5%96%9C/:0:0","tags":null,"title":"百度寄的证书和礼品，惊喜！","uri":"/posts/%E7%99%BE%E5%BA%A6%E5%AF%84%E7%9A%84%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A4%BC%E5%93%81%E6%83%8A%E5%96%9C/"},{"categories":["随笔杂记"],"content":"今年过年早，复习周被压缩到了元旦三天，接下来一个星期要考5门试。分别是大物、线代、数电、英语、Java。后两者还好说，比较容易复习。前三者真是让我苦不堪言，尤其是线代，复习到现在已经非常疲惫了，但还是心里没底，还好复习时有秀儿陪着我，不然我真撂挑子不干了。 看来功夫还是得用在平时。50个学时以上的课，一定要好好做平时作业qwq ","date":"2022-01-05","objectID":"/posts/%E5%A4%8D%E4%B9%A0%E5%91%A8%E8%8B%A6%E4%B8%8D%E5%A0%AA%E8%A8%80/:0:0","tags":null,"title":"复习周苦不堪言","uri":"/posts/%E5%A4%8D%E4%B9%A0%E5%91%A8%E8%8B%A6%E4%B8%8D%E5%A0%AA%E8%A8%80/"},{"categories":["书影记录"],"content":"图书简介 《史蒂夫·乔布斯传》是美国作家沃尔特·艾萨克森为苹果公司创始人史蒂夫·乔布斯所作的传记，记录了乔布斯从童年开始，到卸任苹果公司CEO所发生的故事。该书是乔布斯唯一授权的传记，但乔布斯从未干涉艾萨克森的写作，甚至乔布斯从来没有阅读过本书，因此相比于其他名人的传记，本书更加客观真实。它为我们提供了一个毫无掩饰的视角，充分展现了一个“伟大的乔布斯”和“讨厌的乔布斯”。有人说，天才在左，疯子在右，这两种属性是如何在缠绕在同一人身上的呢？想知道的话就翻开这本书吧。 我非常崇拜乔布斯，因此阅读这本书给我的感觉就像是在知心的朋友进行一场畅快的交谈。我要把打动我的句子记录下来： ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"摘抄及感想 “如果你不忙着求生，你就在忙着求死” 你必须不断地去推动创新。迪伦本来可以一直唱抗议歌曲，可能会赚很多钱，但是他没有那么做。他必须向前走，1965年在民谣中融入电子音乐元素时，他疏远了很多人。1966年的欧洲巡演是他的巅峰。他会先上台演奏原声吉他，观众非常喜欢。然后他会带出The Band乐队，他们都演奏电子乐器，观众有时候就会喝倒彩。有一次他正要唱《像一块滚石》，观众中有人高喊“叛徒”，迪伦说：“搞他妈个震耳欲聋！”他们真那样做了。披头士乐队也一样。他们一直演变、前行、改进他们的艺术。那就是我一直试图做的事情——不断前进。否则，就如迪伦所说，如果你不忙着求生，你就在忙着求死。 乔布斯的一个商业原则就是：永远不要害怕内部相残。他说：“与其被别人取代，不如自己取代自己。”（If you don’t cannibalize yourself，someone else will.）所以，即使iPhone的出现会蚕食iPod的销售，或者iPad影响了笔记本电脑的销售，都没有阻碍他的想法。 迪伦是乔布斯最喜欢的歌手，迪伦的歌曲一直在革新，苹果公司也一直在革新。iPod曾是苹果最成功的产品，但当乔布斯意识到iPod会被手机取代后，他做出了iPhone取代了自己的iPod。有人说，革别人的命容易，革自己的命难。我们见过太多取得了成功后就固步自封的例子，而苹果公司却能一往无前，与其让别人革自己的命，不如自己革自己的命。 “人们不知道想要什么，直到你把它摆在他们面前” 有些人说：“消费者想要什么就给他们什么。”但那不是我的方式。我们的责任是提前一步搞清楚他们将来想要什么。我记得亨利·福特曾说过，“如果我最初问消费者他们想要什么，他们应该是会告诉我，‘要一匹更快的马！’”人们不知道想要什么，直到你把它摆在他们面前。 这是乔布斯最经典的话之一。亨利·福特造出汽车之前，人们只知道骑马。乔布斯造出iPhone之前，人们也没有使用触摸屏的需求。乔布斯的伟大之处就是他总是能洞见未来，没有需求就创造需求，这可不是一般人具有的天赋。 有一次在他进行深度麻醉时，胸科医生要往他脸上戴麻醉面罩。乔布斯把面罩扯掉，嘟囔着说他讨厌这个面罩的设计，拒绝戴它。虽然他几乎无法说话，但他还是命令医生拿来五种不同的面罩，选出一个他喜欢的。 这是乔布斯在接受癌症治疗的时候发生的故事。可以看出乔布斯的完美主义已经深入骨髓，甚至把设计看作比生命还重要。 “你是想卖一辈子糖水呢，还是想抓住机会来改变世界？\" 斯卡利后来讲述了接下来那个最为激动人心的时刻，“史蒂夫低着头，看着自己的脚。在一段沉重的、尴尬的沉默之后，他向我抛出了一个问题，让我几天都无法释怀，‘你是想卖一辈子糖水呢，还是想抓住机会来改变世界？’” 斯卡利回忆说，感觉就像有人往他的肚子上狠狠揍了一拳，除了默许，他无言以对。人人都曾怀揣过伟大的梦想的火种，但大多数人都被世俗浇灭到奄奄一息了。乔布斯是少数保留火种的人之一，他想拉斯卡利入伙，用一句\"你是想一辈子糖水呢，还是想抓住机会来改变世界？“唤醒了斯卡利的内心的火种，就像是用一根火炬点燃了另一根火炬。 他拒绝使用CEO专有车位，却霸占了残疾人停车位。他希望被（他自己和其他人）看成一个愿意为1美元年薪工作的人，却又希望得到大笔的期权。从一名反主流文化的叛逆者变为一名商业创业者，他自身充满了矛盾。他希望在心灵上得到的启迪和感悟，与他通过股票和期权获得的财富并无关联。 读到这段话，我太感同身受了。我想问问读者，你觉得你是一个矛盾的人吗？你活成了自己讨厌的人吗？我的回答是：既是，也不是。你不得不承认你的目光有限，思想在变，当年你认为对的事，现在不一定认为是对的。 他说：“当1999年Adobe背叛了我们之后，我的第一个想法就是，在我们所涉足的任何领域，必须要同时控制硬件和软件，否则我们迟早要受制于人。” 你一定有过类似的经历，你把事情交给别人来做，结果别人不付吹灰之力把它搞砸了…很多优秀的程序都是一个牛逼的程序员自己开发出来的，因为这样才能保证作品有完美的整体性，而合作往往只能做出中规中矩的作品。 “我们苹果的员工已经忘记了自己是谁。要回想起你是谁的方法之一，就是要想起你的偶像是谁。这就是那次宣传活动的缘起。” 我们喜欢在QQ空间里发自己的偶像，不就是为了给自己打标签吗？你想成为一个什么样的人，回答这个问题的参考资料首先是你的偶像。 “Windows赢了。”他说，“很不幸，它打败了Mac，打败了Unix，打败了OS/2。一个低劣产品胜出了。” 乔布斯说这句话的时候特别的无奈。哈哈，正义并不总是能战胜邪恶。 “我们相信，苹果有道德责任让色情远离iPhone，”乔布斯在回复一位消费者的邮件中写道，“需要色情的人可以用安卓。” 乔布斯坚持把苹果打造成有道德有底线的公司，并且尽可能避开政治斗争、地域歧视。在隐私保护、无障碍功能上，苹果一直都是行业标杆。虽然苹果公司位于美国，但它是属于全世界的财富。 Mac发布当天，来自《大众科学》（Popular Science）的一位记者问乔布斯做过什么类型的市场调研工作。乔布斯语带嘲讽地回应：“亚历山大·格雷厄姆·贝尔在发明电话之前做过任何市场调研吗？” 取得成功后，把自己跟先贤贝尔相提并论，我就喜欢他这种拽拽的样子。人生得意须尽欢，当我得意的时候我也要这样拽一下。 ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"苹果的产品 苹果是以产品为核心的。苹果产品的设计简洁为原则，简洁是为了实用，而不是牺牲实用性才做到的简洁。苹果的产品能让人一眼看出使用逻辑，一个5岁的孩子不用教就能学会玩iPad，这正是苹果的目的。不仅是实用，还要尽可能的优雅，在各方面注入美学。这样的产品能让人产生使用的欲望，而不是为了生计不得不去使用的工具，苹果想让使用他们产品的顾客的生活变得美好，而不是变得繁琐。 初上手苹果的产品，你并不觉得它很惊艳，苹果的确不会像其他品牌那样制造噱头去吸引你。但当你实际使用一段时间，当你沉浸在丝滑的交互中，再把它与其它产品比较时，你会发现其它产品是多么幼稚。苹果就像是一位特别可靠的父亲，他为你考虑到了处处细节，让你有足够的舒适感和安全感，同时又在用他的魅力激发你的创造力。它的惊艳是落到实处的，一直使用你就会一直被惊艳。 ","date":"2021-12-16","objectID":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"《史蒂夫·乔布斯传》读书笔记","uri":"/posts/%E5%8F%B2%E8%92%82%E5%A4%AB%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"起因 从大一我刚做昕哥的学生开始，他就建议刚学完c程序设计的我趁热打铁，去考一个ccf csp认证。我当时对算法不感兴趣，也没参加acm，就没有关注这个认证。 结果没想到昕哥主持了今年的csp认证，考点就在我们学校。昕哥当然首先拉我们参加，还说给我们报销费用，让我们先垫着。（估计是不会给报销了qwq）这怎么好拒绝呢，考一个试试！ ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考前 在考试前一周，我甚至对这个考试一无所知。直到前三天，我才多方面打听到了ccf csp认证没有通过/不通过的概念，只有分数。一共五道题，满分500分，每年的平均分在150分左右。往年在青岛大学有考点，但在咱们学校举办的次数很少。我知道自己就是去考着玩的，但还是花了点时间准备一下。 我做了往年的题目，发现这题目出的还挺有意思。第一题一般是热身题，很easy。第二题也不难，用暴力方法可以做到70分，拿满分需要用到一些算法。第三题是阅读理解题，特别长，但也不涉及很多算法。第四题和第五题会考到树、图等数据结构，第五题就是究极难题了，很少有人能做出来。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考中 中午没睡觉，从1:30考到5:30，四个小时注意力集中。这酸爽，就好像是做了一晚上的噩梦一样。 考完特别的累，晚上又去考英语六级模拟，考完腰就顶不住了。 但是我特别享受考试的过程！ 无论是在准备考试，还是正式考试，我都特别享受那种专注的感觉。绞尽脑汁，花了好长时间，写出了代码，提交拿到了分数的那种喜悦，真是太棒了，就好像是一口气看完一本悬疑小说！ 我觉得这才是本科生该干的事情。一个人，一台电脑，就能在图书馆呆一晚上。比起做项目来说，这是非常舒服的事情，做项目不仅累，而且要操心的事情特别多，更可怕的是还要忍受傻逼队友。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"考后 我特别想把对算法的研究继续下去，就怕客观条件不足，我自己意志力又不够强，坚持不下去。 我觉得我要继续研究算法，就是要多做题，搞算法的离开了做题都是扯淡，只有做题是实在的。 真的真的希望我能渐次下去。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"参加ccf csp认证考试有感","uri":"/posts/%E5%8F%82%E5%8A%A0ccf-csp%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"包含几乎所有课堂上讲的题目 ","date":"2021-12-01","objectID":"/posts/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"数值计算方法","uri":"/posts/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"今天在线上听了西交的孟德宇教授的小讲座，非常亲切朴实，真正的打动了我。 如何写好论文 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:0","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"细节，careful 仔细画每一幅图 不要有typo（词句小错误） 不要用长句 避免过度修饰，冗长 至少修改30遍 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:1","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"逻辑通顺 写提纲 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:2","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"理论、实验点支撑 支撑什么观点？从哪些角度？ ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:3","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"讲一个合理的故事，前呼后应，自圆其说 拍电影 宁浩《疯狂的石头》、《疯狂的赛车》、《我不是药神》 张艺谋《影》（不讲逻辑） 拒绝言过其实、过度包装、前言不搭后语 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:4","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"花时间认真挑选研究方向，科研问题 拒绝incremental（灌水，小改动） Large margin策略，从0到1，从粗糙到细致 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:5","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"理解，深刻，洞察（insight） ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:6","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"不必随大流，make difference 《Embedded vision summit 2018》 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:7","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"深入思考，长远打算 小问题 本质性，创新性，冷门性，可用性 考虑好未来系统框架 一个好的论文一定是小的，朴素的 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:8","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"四个建议 多做报告、精心准备报告slides 参与社交活动 三句话概括自己的研究方向 让外行人理解 大智若愚、大道至简 拒绝诱惑、不要以功利的目标做科研、不要丢失情怀 ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:9","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["笔记"],"content":"举重若轻、游刃有余 当成一种体验而去好好感受 无为而无不为 讲一个能够满足和感动自己的故事！ ","date":"2021-11-24","objectID":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/:0:10","tags":null,"title":"讲一个能满足和感动自己的故事！","uri":"/posts/%E8%AE%B2%E4%B8%80%E4%B8%AA%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%92%8C%E6%84%9F%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["技能分享"],"content":"起因 傻逼Mac，每次开屏幕都要重新输入账号密码运营商连接校园网，所以我想办法用脚本去实现连接校园网的操作。 mac可以直接运行shell脚本，写一个超级简单的脚本放在桌面，每次点一下就可以自动连接校园网了。 ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:1:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"第一步 从GitHub上下载一段自动连接校园网的python代码，地址：https://github.com/UPCUnofficial/UPCNet 然后解压，修改其中config.py文件。 在config.py文件下输入学号、密码和运营商编号，然后运行 python3 NetworkAuth.py 运营商对应编号： default -\u003e 校园网 unicom -\u003e 联通 cmcc -\u003e 移动 ctcc -\u003e 电信 local -\u003e 校园内网 再用终端cd进入该文件夹，pip install 所依赖的库。 运行代码。(以上所述在readme里都有） python3 NetworkAuth.py 成功啦！ ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:2:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"第二步 用文本编辑器创建一个文件，里面打上这行代码： python 你的路径/NetworkAuth.py 将文件重命名为XXXX.sh 然后右键—\u003e打开方式—\u003e其它—\u003e所有应用程序—\u003e终端 然后把它放在桌面，每次等连上wifi后点一下就能连接校园网啦。 ","date":"2021-11-24","objectID":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/:3:0","tags":null,"title":"Mac上自动连接校园网的脚本","uri":"/posts/mac%E4%B8%8A%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E8%84%9A%E6%9C%AC/"},{"categories":["技能分享"],"content":"问题描述 如图，有一天在push的时候要求输入Username和Password，输入了GitHub登录名和密码后，提示“鉴权失败”。 ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:1","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"解决方案 看它给的提示，Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. 2020年7月，我们宣布打算要求对所有经过身份验证的Git操作使用基于令牌的身份验证（例如，个人访问、OAuth或GitHub应用程序安装令牌）。从2021年8月13日开始，在GitHub.com上验证Git操作时，我们将不再接受帐户密码。 也就是说输入的Password不是登录密码，而是这个Access Token！另外，Username也不是用户名，而是登录邮箱。 获取个人Access Token的方法：https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 记得一定要把repo的权限勾选上 ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:2","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"在命令行上使用令牌 一旦您拥有了令牌，在通过HTTPS执行Git操作时，您可以输入令牌而不是密码。 例如，在命令行中，您将输入以下内容： $ git clone https://github.com/username/repo.git Username: your_username Password: your_token ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["技能分享"],"content":"后续 怎么把Access Token添加到环境变量里呢？ ","date":"2021-11-21","objectID":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:1","tags":null,"title":"github推送出现fatal:\"XXX\" 鉴权失败解决方案","uri":"/posts/github%E6%8E%A8%E9%80%81%E5%87%BA%E7%8E%B0fatalxxx-%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["随笔杂记"],"content":"我的第一台macbook 犹豫了一年，终于在2021年11月份买了这台m1版本的macbook air。非常感谢我哥借给我不敢想象的8k块。 精准 在很多人眼里macbook只是个花瓶，不能打游戏，不能装专业软件，价格还死贵。但是在我眼里，它精准的满足了我的需求： 不打游戏 轻薄的机身、超长的续航，我可以带出去一整天（这个很重要！ 堪比pro的性能 类unix系统，舒服使用终端 没有风扇，安静写代码 非常出色的屏幕，长时间看都不累 基本适配软件开发所需的软件 恰到好处的装逼 实际上，这台m1的MacBook Air可能是苹果最具性价比的电脑之一，学生党完全可以考虑入手！ 优雅 对于计算机专业的学生来说，电脑就是老婆。而这台macbook就如一个俄罗斯美人，不仅干活猛，还好看。希望使用这台优雅的电脑能帮助我改掉以前在windows上养成的坏习惯，比如资料胡乱放。 ","date":"2021-11-14","objectID":"/posts/%E7%B2%BE%E5%87%86%E8%80%8C%E4%BC%98%E9%9B%85macbook-air/:0:0","tags":null,"title":"精准而优雅——MacBook Air","uri":"/posts/%E7%B2%BE%E5%87%86%E8%80%8C%E4%BC%98%E9%9B%85macbook-air/"},{"categories":["技能分享"],"content":"网上教程大多都是说下载微软雅黑字体到系统文件夹，然后更改matplotlib的配置文件。实际操作过程发现更改系统文件夹需要权限，而且matplotlib的配置文件也和网上说的不一样。 后来参考了：https://www.cnblogs.com/cymwill/p/10554916.html ","date":"2021-11-12","objectID":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:0","tags":null,"title":"macOS下matplotlib无法显示中文字体问题解决","uri":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"解决方法 找到字体路径 import matplotlib print(matplotlib.matplotlib_fname()) 进入该路径然后编辑文件matplotlibrc可以直接在最下面加上三行： font.family: sans-serif font.sans-serif: Arial Unicode MS, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif axes.unicode_minus: False 然后把~/.matplotlib目录下的两个文件删除掉（缓存文件可以放心删）：  rm -rf ~/.matplotlib/* 重启python，并引入字体 plt.rcParams[‘font.sans-serif’] = [‘Arial Unicode MS’] 即可解决中文及负号无法正常解决的问题。 ","date":"2021-11-12","objectID":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":null,"title":"macOS下matplotlib无法显示中文字体问题解决","uri":"/posts/macos%E4%B8%8Bmatplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"如下图，在英语朗读视频中添加文稿可以让刘老师清晰地看到你读的每一个单词，更准确地判断你的朗读水平，从而对你进行更好的指导。那么如何在英语朗读视频中添加文稿呢？ 你所需要用到的工具是剪辑软件，下面推荐几个很好用的剪辑软件： ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:0:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"1.剪映（电脑和手机） 你可以把你的视频直接拖拽到导轨上，然后再把文稿以图片也拖拽进来。控制好每张图片时间区间，使其与你的视频对应。不到五分钟，你就可以处理完你的视频。 剪完后，点右上角导出视频，你可以像我一样使用下图的参数，这样你能得到一个清晰度够用但是占用内存特别小的视频。 剪映的下载地址（官方）：https://lv.ulikecam.com/?_s=4 在剪辑时，运用分割、分离、变速、快捷键等技巧会让视频更完美，你可以在b站学习这些知识。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:1:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"2.花瓣剪辑（手机） 用手机也可以剪辑。花瓣剪辑是华为手机自带的剪辑软件。操作逻辑和剪映一样。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:2:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"3.Premiere（电脑） ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:3:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"4.final cut pro（苹果电脑） ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:4:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"5.iMovie(ipad) ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:5:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["技能分享"],"content":"…… 工具其实都一样，选择一个称手的就好。 ","date":"2021-11-04","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/:6:0","tags":null,"title":"如何在英语朗读视频中添加文稿","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%9C%97%E8%AF%BB%E8%A7%86%E9%A2%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E7%A8%BF/"},{"categories":["随笔杂记"],"content":"大一的时候，看到这个社团感觉就很对胃口，想加入。但是Linux自由软件协会太低调了，那年的百团大战我都没找到摊位。 大二阴差阳错，我直接从局外人成了会长。 起因是我当了飞桨领航团团长，要借一个社团办线下活动，没人愿意跟我合作。 陈荣灿学长跟我都是李昕老师的学生，我问他可不可以合作办一个活动，他说正好现在社团换届，直接把会长给我了。 现实真的比小说还魔幻，小说是讲逻辑的，现实不讲逻辑。 换届现场 我还把王文婕、廖集秀拉来了。很多事情有女生来做的话是很合适的。还拉了一个刘原歌，他对学校的部门事务比较了解。 然后就顺理成章的搞了百团大战活动，搞活动之前我还被社团管理部的老师约谈，因为学校不允许和外部企业合作，让我避讳“百度”。我照做了，不过从此之后我也下定决心不想再给百度干活了。 然后紧接着下周就要准备新生见面会。由我来主持，顺便讲一节课。 我对待这次见面会＋课程，是非常认真的。因为我真的把这次当成很好的锻炼机会。为了准备这个，确实花费了一些心血，开始前可以说是寝食难安。 现场的效果很不错。我真的没想到能来这么多人（94个），教室快坐满了，室友和同学很给面子，都来了。 我表现的也很不错，讲了一节课，全称吹牛逼吹得都很流畅。 为一件事准备的越多，收获的也越多。不能做“佛系青年”，不愿意挑战自己。也不要给自己增加焦虑，什么都想做好，搞太大压力。要践行一种中庸之道，有的放矢，分清主次。 这两周我太累了，同时收获也太多了。 ","date":"2021-10-30","objectID":"/posts/linux%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%8D%8F%E4%BC%9A%E8%BF%8E%E6%96%B0%E7%BB%93%E6%9D%9F%E6%9C%89%E6%84%9F/:0:0","tags":null,"title":"Linux自由软件协会迎新结束有感","uri":"/posts/linux%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%8D%8F%E4%BC%9A%E8%BF%8E%E6%96%B0%E7%BB%93%E6%9D%9F%E6%9C%89%E6%84%9F/"},{"categories":["技能分享"],"content":"思路 先安装Python版本管理器pyenv 再用Pyenv安装Python ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:1","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"安装pyenv 标准安装：找到项目地址pyenv/pyenv: Simple Python version management (github.com) 先git clone，再配环境变量。 作者还提供了一个自动安装的脚本，只需一行命令。 失败！因为国内云主机墙了github（真是emo了 我的方法： 参考https://blog.csdn.net/m0_37616927/article/details/108770185 从gitee上下载pyenv: git clone https://gitee.com/ibuki_fuuko/pyenv.git ~/.pyenv 会把pyenv下载到当前用户的～/.pyenv目录下 再把以下内容加到~/.bashrc 里，没有就新建 export PATH=~/.pyenv/bin:$PATH export PYENV_ROOT=~/.pyenv eval “$(pyenv init -)” 激活 source .bashrc 安装成功，可以看到pyenv提供可安装的python版本 pyenv install –list ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:2","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"安装python 标准思路：直接pyenv install 3.7.5 就能一键安装Python了 失败！因为Python镜像默认是从官网下的，国内网络上不去（再次emo 这之后我就开始瞎捣鼓了，参考： https://blog.csdn.net/yxiaom/article/details/103468954 找了一个国内的镜像地址： http://npm.taobao.org/mirrors/python/ 安装Python之前需要安装很多依赖，多用apt装一装 最后查看一下已安装的Python版本 pyenv versions 然后设置默认版本，这样你打python的时候默认使用这个版本 pyenv global 版本号 最离谱的是，我尝试这个命令没有成功，什么都没做，到第二天居然可以了（第三次emo 没想到在linux上装Python比在Windows上难的多，win上装一个anaconda就能解决所有问题 ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:3","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["技能分享"],"content":"懒人方案 装一个宝塔面板，安装Python就比较方便了，但是也失去了学习的价值 ","date":"2021-10-30","objectID":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/:0:4","tags":null,"title":"ubuntu安装Python3的曲折之路","uri":"/posts/ubuntu%E5%AE%89%E8%A3%85python3%E7%9A%84%E6%9B%B2%E6%8A%98%E4%B9%8B%E8%B7%AF/"},{"categories":["书影记录"],"content":"时间 2021年国庆期间，10月3日至5日。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:1:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第一站：翡翠谷 翡翠谷是一个很经典的景点。据说是1988年有36位来自上海的青年男女邂逅于这条峡谷，当时景区尚未开发，他们一路上互相搀扶，克服重重困难，最后有10队成了情侣，所以翡翠谷又名情人谷。 翡翠谷是一条长长的峡谷，一路走进去有很多大大小小的水潭，潭水清澈见底，都是碧绿颜色。但是碧绿程度不一样，有的颜色深，有的颜色浅，像是不同品种的翡翠，因此得名翡翠谷。 此景点对体力的消耗很小，如果你像我一样第二天准备爬黄山，第一天很适合来翡翠谷转一转。最大的缺点就是只有一条路，走进去之后还得原路返回。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:2:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第二站：黄山 首先，对于黄山我是怀着一颗敬畏之心的。记得小学时学过一篇课文，专门讲黄山的奇石，如今亲眼看见，说实话，还真是没那个想象力。但我仍然抱着一颗欣赏的态度去品味黄山的风景。 我们的路线是：汤口镇住宿=\u003e景交车上山=\u003e慈光阁=\u003e坐玉屏索道上山=\u003e莲花亭，迎客松=\u003e一线天=\u003e白云宾馆=\u003e光明顶=\u003e白云宾馆=\u003e坐网红小火车（缆车）=\u003e西海大峡谷（没有游玩）=\u003e网红小火车=\u003e白云宾馆=\u003e第二次上光明顶=\u003e观石亭（观87红楼梦飞来石）=\u003e白鹅岭=\u003e一路走下山去 我们没有按旅行团规划的路线走，中间想去一次西海大峡谷，但是坐了网红小火车去了之后感觉没有体力游玩了，于是原路返回。没有爬黄山最高峰莲花峰，但是爬了两次光明顶。 下山后，大多数人走路都不太正常，一瘸一拐的。我和我妈看到人们踉踉跄跄的样子都觉得很好笑。 可能是一天时间比较短参观景点少，也可能是国庆节人太多心烦意乱，下山回来后，很多旅客都觉得黄山的风景没有想象中那么震撼，有点失望。但我觉得，这次开了一个好头，赶上了大晴天，我的体力也完全够用。黄山是举世闻名的大景点，以后可以再来。 迎客松 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:3:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"第三站：宏村 宏村真是太美了（至少从外面看很美）。整个村子被大山包围起来，有碧水萦回，徽派建筑粉墙黛瓦，就像是一幅水墨画。人在地上走，就像是人在画中游。 参观宏村让我了解了徽州文化。徽州到处是山，不能耕作，所以人们行商，后来发展壮大，成为古代的商业中心。徽商的足迹遍布全国，他们赚的盆满钵满，回到家乡建起了独具特色的徽派建筑。士、农、工、商，商是社会的最底层，徽商结交名人，捐钱买官，但还是会受到歧视。徽商重视教育、讲究商业道德、有爱国精神，真是非常值得现在的企业学习。 宏村里面是商业化的，很多麦糕点的店铺，路过门口的时候还有店员往你手里塞糕点，让你试吃。走一圈下来能吃个半饱。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:4:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"其它 还去了一趟谢裕大茶叶博物馆，本质上来说，这个博物馆其实就是搞营销卖茶叶的。但是在里面可以听到很不错的讲解，还会被邀请到房间里白嫖喝茶，一分钱不花也没关系。 回来的路上发生一件胆战心惊的事情。国庆节路上比较堵，连服务区都进不去，大家都很焦躁。因为一些小事，乘客、送行导游和司机吵了起来。最可怕的是这司机也是个暴脾气，直接在高速路上停车要把这个乘客赶下去。好在其它人劝架，把风波平了下去。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:5:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["书影记录"],"content":"总结 同样一辆车，同样的旅游路线，心态不同，收获也不同。在回来的路上，我听到身边有乘客在抱怨说这三天一点也不好玩，坐了好长时间车玩的还不开心。我想说的是，我很开心，我开心的原因有两个，一是我很清楚我出行的目的，就是为了脱离舒适区，去感受不一样的风景，接触不一样的人，学习不一样的文化。这个目的已经达到了。二是我善于发现美丽，所以我能拍出很好看的照骗，发到朋友圈里让大家给我点赞。所以我很开心。 最后还是建议大家不要在国庆节来黄山，人真的很多。 ","date":"2021-10-06","objectID":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/:6:0","tags":null,"title":"黄山归来不看岳——黄山之旅","uri":"/posts/%E9%BB%84%E5%B1%B1%E5%BD%92%E6%9D%A5%E4%B8%8D%E7%9C%8B%E5%B2%B3%E9%BB%84%E5%B1%B1%E4%B9%8B%E6%97%85/"},{"categories":["刷题"],"content":"获奖名单： 排名不分先后，恭喜以上获奖同学。 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:1:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["刷题"],"content":"领奖须知： **第一步：**扫描二维码，注册飞桨人工智能训练平台aistudio（需要手机号） **第二步：**在gitee开源社区上为首家开源国产深度学习框架paddle paddle点个star（如果没有账号，请注册一个） **第三步：**将您的aistudio注册手机号和gitee注册手机号（或邮箱）填入在线表格：【腾讯文档】百度飞桨ai知识竞赛获奖名单https://docs.qq.com/sheet/DY1JBVkR3dmtaR2d1 **第四步：**加qq群：931294105 与群主孙百乐联系领取奖品 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:2:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["刷题"],"content":"其它说明 若想更换奖品，请自行联系其他获奖者，并在备注中写清楚“与XXX更换” 小度雨伞暂时没有到货，请获奖同学等待一段时间 ","date":"2021-09-29","objectID":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/:3:0","tags":null,"title":"全国高校AI知识竞赛UPC赛区获奖通知","uri":"/posts/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1ai%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9Bupc%E8%B5%9B%E5%8C%BA%E8%8E%B7%E5%A5%96%E9%80%9A%E7%9F%A5/"},{"categories":["技能分享"],"content":"现在主流浏览器的安全机制就是对非https和localhost的ip拒绝调用摄像头和麦克风。在设置里无法直接更改权限。 其实这是因为浏览器不支持http：IP开头的路径，认为这个路径不安全 浏览器只支持file:,https:,http://localhost， ","date":"2021-09-23","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/:0:0","tags":null,"title":"浏览器不支持getUserMedia","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/"},{"categories":["技能分享"],"content":"解决方法 chrome 地址栏输入：chrome://flags/#unsafely-treat-insecure-origin-as-secure 然后就ok了 ","date":"2021-09-23","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/:0:1","tags":null,"title":"浏览器不支持getUserMedia","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getusermedia/"},{"categories":["技能分享"],"content":"思路 安装snap 安装certbot 自动配置nginx 完事儿了，确实很方便。具体执行语句访问 https://certbot.eff.org/ 按下图选择环境后就能看到所有执行语句 踩过的坑 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:0","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"配置nginx的时候报错如图 报错的意思就是说，在nginx的配置文件中server_name字段不正确。我把它修改成了aiupc.xyz，仍然报错。 后来问了我哥，才知道nginx配置文件最底下有一行： wordpress真正的配置文件其实是在/usr/local/nginx/conf/vhost文件夹里。把这个里面的server_name改一下就OK了。 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:1","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"server_name不能随意 server_name = aiupc.xyz 和 server_name = www.aiupc.xyz 是不一样的，弄混的话会导致站点一些图片链接浏览器不予显示。 我的解决方案：nginx配置server_name = www.aiupc.xyz，server_name = aiupc.xyz, 域名解析aiupc.xyz和www.aiupc.xyz， certbot给aiupc.xyz和www.aiupc.xyz都申请证书， wordpress后台设置里url写https://www.aiupc.xyz， 这样，在浏览器中打aiupc.xyz也会跳转到www.aiupc.xyz 的，这个问题应该已经彻底解决了。 ","date":"2021-09-08","objectID":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/:0:2","tags":null,"title":"certbot自动配置nginx给wordpress站点加https","uri":"/posts/certbot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEnginx%E7%BB%99wordpress%E7%AB%99%E7%82%B9%E5%8A%A0https/"},{"categories":["技能分享"],"content":"图像 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:0","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"位图（raster graphics)和矢量图（vector graphics) 位图是有像素的，色彩丰富。矢量图放大不会失真。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:1","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"通道 单通道 灰度图，每个像素点只有一个值表示，如果图像的深度是4-(256 = 2_2_2*2)，那么他的像素值0(黑)~255(白)； 三通道 也就是通过见到的彩色图，每个像素点有三个值表示，如果图像深度是4-(256 = 2_2_2*2),那么他的像素值有红(0~255)、绿(0~255)、蓝(0~255)叠加表示，色彩更加艳丽; 四通道 四通道：也就是在三通道图像基础上加上透明程度，Alpha色彩空间，如果图像深度是4-(256 = 2_2_2*2),那么0是完全透明，255是完全不透明；png图像是四通道。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:2","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"读取图片（numpy的array) import matplotlib.image as mpimg im = mpimg.imread(fname) 读取一张200*200的png图像 im.shape() \u003e\u003e (200, 200, 4) 表示像素是200*200，有四个通道 数组是这个样子： im[0]矩阵，长为200, 宽为4，自己体会一下。 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:3","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"显示图片 import numpy as np import matplotlib.pyplot as plt plt.imshow(arr) #根据像素绘制图片 origin表示渐变程度 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:4","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"numpy.array 的shape属性理解 二维情况 \u003e\u003e\u003e import numpy as np \u003e\u003e\u003e y = np.array([[1,2,3],[4,5,6]]) \u003e\u003e\u003e print(y) [[1 2 3] [4 5 6]] \u003e\u003e\u003e print(y.shape) (2, 3) \u003e\u003e\u003e print(y.shape[0]) 2 \u003e\u003e\u003e print(y.shape[1]) 3 可以看到y是一个两行三列的二维数组，y.shape[0]代表行数，y.shape[1]代表列数。 三维情况 \u003e\u003e\u003e x = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[0,1,2]],[[3,4,5],[6,7,8]]]) \u003e\u003e\u003e\u003e print(x) [[[1 2 3] [4 5 6]] [[7 8 9] [0 1 2]] [[3 4 5] [6 7 8]]] \u003e\u003e\u003e print(x.shape) (3, 2, 3) \u003e\u003e\u003e print(x.shape[0]) 3 \u003e\u003e\u003e print(x.shape[1]) 2 \u003e\u003e\u003e print(x.shape[2]) 3 可以看到x是一个包含了3个两行三列的二维数组的三维数组，x.shape[0]代表包含二维数组的个数，x.shape[1]表示二维数组的行数，x.shape[2]表示二维数组的列数。 总结 可以看到，shape[0]表示最外围的数组的维数，shape[1]表示次外围的数组的维数，数字不断增大，维数由外到内。 ———————————————— 版权声明：本文为CSDN博主「Lavi_qq_2910138025」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/liuweiyuxiang/article/details/79384435 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:5","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"numpy的梯度函数np.gradient(f) np.gradient(f):用于计算数组f中元素的梯度，当f为多维时，返回每个维度的梯度。 一维 a = np.random.randint(0,20,(5,))\u003e\u003earray([10, 0, 7, 0, 19]) np.gradient(a)\u003e\u003earray([-10. , -1.5, 0. , 6. , 19. ]) 由梯度计算公式得到梯度计算结果: -10=（0-10）/1 -1.5=（7-10）/2 二维 c = np.random.randint(0,50,(3,5)) \u003e\u003earray([[25, 49, 14, 13, 20], [43, 6, 13, 15, 24], [ 9, 2, 7, 5, 36]]) np.gradient(c) \u003e\u003e[array([[ 18. , -43. , -1. , 2. , 4. ], [ -8. , -23.5, -3.5, -4. , 8. ], [-34. , -4. , -6. , -10. , 12. ]]), array([[ 24. , -5.5, -18. , 3. , 7. ], [-37. , -15. , 4.5, 5.5, 9. ], [ -7. , -1. , 1.5, 14.5, 31. ]])] 对于二维数组，任意一个元素的梯度存在两个方向，所以求得的梯度为两个数组对象，第一个数组表示最外层维度的梯度值，第二个数组表示第二层维度的梯度值。 对于n维数组，gradient函数会生成n个数组，每个数组代表元素在第n个维度的梯度变化值，梯度反应了元素的变化率，尤其是我们在进行图像，声音等数据处理，梯度有助于帮助我们发现图像和声音的边缘，在那些变化不是很平缓的地方，可以很容易的发现。 ———————————————— 版权声明：本文为CSDN博主「June �」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/MachineLearner/article/details/104403097 ","date":"2021-08-29","objectID":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/:0:6","tags":null,"title":"对图像操作","uri":"/posts/%E5%AF%B9%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"},{"categories":["技能分享"],"content":"创建虚拟环境 conda create -n 名字 python=3.8 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:1","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"进入虚拟环境 conda activate 名字 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:2","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"退出虚拟环境 conda deactivate ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:3","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"删除虚拟环境 conda remove -n 名字 --all ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:4","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"查看环境下已有安装包 conda list ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:5","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"查看已有虚拟环境 conda-env list ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:6","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"jupyter notebook使用虚拟环境 安装一个库 pip install ipykernel 往kernel里写入虚拟环境 python -m ipykernel install --user --name 环境名字 --display-name 显式的名字 a 虚拟环境里没有notebook，安装一下 pip install notebook 启动 ipython notebook 在Notebook里更换环境： Kernel =\u003e Change kernel =\u003e 环境名 ","date":"2021-08-29","objectID":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:7","tags":null,"title":"Conda 配置虚拟环境","uri":"/posts/conda-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":["技能分享"],"content":"安装 参考地址：paddlepaddle.org.cn/install/quick?docurl=/documentation/docs/zh/install/docker/linux-docker.html 先安装docker，参考官网 拉取镜像： docker pull registry.baidubce.com/paddlepaddle/paddle:2.1.2-jupyter 运行容器 docker run -d -p 8080:80 --rm --env USER_PASSWD=sbl -v /root/jupyter_docker:/home/paddle registry.baidubce.com/paddlepaddle/paddle:2.1.2-jupyter # -d表示后台运行 # -p端口，指定宿主机的8080端口映射到容器内80端口 # --rm运行完删除容器 # USER_PASSWD=密码 # -v挂载，对应容器内的jupyter目录 这里有个坑，访问ip地址:8080进入notebook的时候，还有一个账号，默认是paddle ","date":"2021-08-29","objectID":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/:0:1","tags":null,"title":"jupyter-paddle使用docker安装","uri":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/"},{"categories":["技能分享"],"content":"容器内安装dlib 更新apt: 在安装 g++ 等工具时 会提示 Unable to locate package build-essential，这种情况下先执行 sudo apt-get update 更新一下， 更新完。继续 sudo apt-get install build-essential 使用apt安装依赖： `sudo apt-get install build-essential cmake` `sudo apt-get install libgtk-3-dev` `sudo apt-get install libboost-all-dev` pip安装 dlib pip install dlib 作者：花花儿 链接：https://www.zhihu.com/question/34524316/answer/182278536 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-08-29","objectID":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/:0:2","tags":null,"title":"jupyter-paddle使用docker安装","uri":"/posts/jupyter-paddle%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85/"},{"categories":["随笔杂记"],"content":" 现在距离开学没几天了，暑假在一起玩的朋友、同学都纷纷开学了，就剩我一个人呆在家越来越无聊。在家里呆腻了，我就在晚上出去走走。一路向西，或一路向北，不到穷尽不回头。这是我第一次用自己的脚步丈量我的家乡城市——蚌埠。 我是一个路痴，我觉得我之所以会成为路痴，不是因为我天生缺少方向感，也不是因为我不出门，而是因为我那疼我的父母。从小到大，去任何地方都是我父母带着我去。去北师大附中上学，去文化广场补课，去百货大楼买衣服，去高铁南站坐车…父母不能送我的，就告诉我坐哪辆公交车，到哪个路口向哪拐弯。我也没有自己在城里溜达的爱好，连东南西北都分不清，更别说弄清楚方位了。 虽然我是土生土长的蚌埠人，对蚌埠的很多地方都特别眼熟，但是在我脑中没有形成空间记忆，不知道这些地方之间的位置关系。总的来说，就是我对这个城市的记忆是碎片化的。  前面说过，这几天我特别闲，就骑了个共享电瓶车自己到外面溜达。第一天，我往北走。先走到红鼎会所，再走到宏业路，看到了财经大学、第二人民医院还有我高考的地方铁路中学，最后到了我的母校师范附属小学，在对面的大润发里买了点吃的。回来的时候我换了条路，故意绕的远一点，走风景不错的环湖西路回家。 第二天，我一路向西。先到了银泰、万达，再到张公山公园，过了桥，还是张公山公园，继续向前就能一路到达北师大附中，但是实在是太远了，而且过于荒凉，我就没去。回来的时候我走的是涂山路，经过了传说中的“田家炳中学”，再经过文化广场，拐两个弯到慕远学校，又回到了东海大道上。 这两天溜达的过程中，我看到了好多好多记忆中熟悉的地点。直到今天，我才彻底弄明白它们到底在哪里。 我家对面的东海大道，可真算蚌埠市的脸面，它连接了太多地方，这些地方承载了我这18年来所有的回忆。如果我是宋冬野，我也能为东海大道写出这样的词： “让我再看你一眼，从南到北。”  我的家乡蚌埠，就让我在离开你之前，重新认识你吧！ ","date":"2021-08-27","objectID":"/posts/%E5%86%8D%E8%AE%A4%E8%AF%86%E6%88%91%E7%9A%84%E5%AE%B6%E4%B9%A1%E8%9A%8C%E5%9F%A0/:0:0","tags":null,"title":"再认识我的家乡——蚌埠","uri":"/posts/%E5%86%8D%E8%AE%A4%E8%AF%86%E6%88%91%E7%9A%84%E5%AE%B6%E4%B9%A1%E8%9A%8C%E5%9F%A0/"},{"categories":["笔记"],"content":"python中与时间相关的标准库有三个： time datetime calendar 吐槽：真tm傻逼，时间也要用三个库？搞得我现在都不会 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:0","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"时区坑 查看时间的方式有很多 法一： from datetime import datetime print(datetime.now()) 在windows上输出2021-08-22 15:04:09.958720，没问题 法二： import time localtime = time.localtime(time.time()) print(\"本地时间为 :\", localtime) 本地时间为 : time.struct_time(tm_year=2021, tm_mon=8, tm_mday=22, tm_hour=15, tm_min=5, tm_sec=20, tm_wday=6, tm_yday=234, tm_isdst=0)，没问题 注意：可是到了linux上都不对 GMT 时间：格林威治时间，基准时间 UTC 时间：Coordinated Universal Time，全球协调时间，更精准的基准时间，与 GMT 基本等同 CST 中国基准时间：为 UTC 时间 + 8 小时，即 UTC 时间的 0 点对应于中国基准时间的 8 点，即为一般称为东八区的时间 在我的linux机器的shell里打date，可以显示正确CST的时间，但是在python里用上述两种方法，时区都是GMT，写程序的时候一直都没发现，真是害惨我了。 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:1","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"datetime引入 datetime下有个类名字还叫datetime，所以你得这样写代码 import datetime datetime.datetime.now() 或者 from datetime import datetime datetime.now() 哇这真是太傻逼的，python这么好用的语言也有反人类的时候。 ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:2","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["笔记"],"content":"python获取当前时间（CST时间） 很简单，如果你发现你用datetime获取到的是UTC时间，就把他加上8小时就是CST时间了 import datetime,timedelta localtime = datetime.now()+timedelta(hours=8) 获取小时（格式化字符串） import datetime,timedelta localtime = datetime.now()+timedelta(hours=8) print(localtime.strftime(\"%H\")) ","date":"2021-08-22","objectID":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/:0:3","tags":null,"title":"python时间遇到的坑","uri":"/posts/python%E6%97%B6%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"categories":["书影记录"],"content":"一句话概述  《人类简史》在2012年以希伯来文出版。本书从人类的起源开始谈，谈到人类的认知革命、农业革命、再谈到人类的融合统一、科学革命，最后谈一谈人类的未来。构造了一个横跨人类历史的巨大历史框架。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介  作者是以色列年轻人尤瓦尔·赫拉利（出书时不到40岁），现在是牛津大学历史学博士。简史三部曲《人类简史》、《未来简史》、《今日简史》都出自他笔下。（这三本书都是畅销书，在书店里常看到~） ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"语言特色  本书的可读性非常强！读的时候感觉就像在听作者侃侃而谈，很有趣，完全不像教科书那样枯燥。作者是江湖派，书中观点尖锐，但有理有据，让人受震撼的同时又觉得很有道理。真是“听君一席话，胜读十年书！”  该书中文版所参照的英文版，加入了很多中国元素，是作者特地为中国读者“量身定做”的。这位译者林俊宏先生也是旷达敏捷，文笔生动晓畅，翻译后的语言生动，比喻贴切，对中国读者非常友好。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"收获和感想  看这本书的第一感受就是满足了好奇心，知道了很多有趣但貌似没用的知识。收获很大，但是具体收获到了什么，说不清楚。就好比贾宝玉经常说他悟了，但林黛玉问他悟到了什么，他说不上来。可谓是：“此中有真意，欲辨已忘言”。  但仔细想一想，收获有两个方面：第一、补充知识。《人类简史》为我构建了一个宏大的，关于全人类历史的知识框架。从原始社会，到农业革命，到科学革命到工业革命再到现代最后到未来，人类经历了若干个时代，进入每个时代的原因是什么，每个时代是什么样子，各什么特点，都在这本书里有论述，解决了很多以前产生过但是懒得去查的问题。比如，什么是帝国主义？这个经常在新闻里听到，但是读这本后我才弄懂是什么意思。  **第二、拓宽思维。**除了客观的历史陈述之外，作者还提供了独到的观点，让我大呼“卧槽，说的好几把对！” 印象最深刻的是，作者认为人类可能并不是一直在进步的，比如农业革命之后，人类从采集狩猎的生活变成了定居种地的生活。农民比原始人工作时间更长，干的活更多，还要被统治阶级压迫。和家禽住在一起更容易得疾病，饮食过度单一导致营养不良。从DNA的角度看，人口增加，DNA复制的越来越多，这是DNA的胜利。但是从个人的角度看，每个人的生活质量都下降了，农业革命可能是史上最大的一桩骗局。与其说人类驯服了小麦，不如说小麦驯服了人类。  作者尤瓦尔·赫拉利知识广博，旁征博引，串联起不同的地区，不同的时代，从多学科的角度描述现象，解释原因。读完这本书之后，有个很深切的感受，就是认清了自己的无知与傲慢，我们所处的时代其实并没什么特别之处，它仅仅只是人类历史的一个阶段。而人类历史也只是地球这个星球漫长演化过程的冰山一角。罗翔老师说，“读万卷书” 是为和古人对话，走出时代的偏见。这本书，很好的帮助我走出时代的偏见。  另外，这本书提出的哲学问题，也引人深思。举个例子，人类存在的意义是什么，是追求快乐吗，追求的快乐是自由主义所说的感官快乐，还是佛教所说的无欲无求？想到最后就会发现人类的存在根本没有意义，既然没有意义我还存在干嘛，好烦，罢了罢了，别想乱七八糟的了，还是过好当下的生活吧！ ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人类的未来难以预料  在21世纪，自然法则开始被人类打破，而由智慧设计法则取而代之。这是人类最接近造物主神的一次。目前有三种方式可能让智慧设计取代自然选择：生物工程、仿生工程与无机生命工程。这三者的发展，都让未来不可想象。试想一下，如果未来诞生了基因和身体被改造的精英人类，他们看待普通人类，是不是像我们看待黑猩猩一样。他们和我们是一个物种吗，我们会奴役其它物种，而他们会奴役我们吗？  当然，以上是悲观看法。目前的人类技术发展趋势更多的是向乐观发展，人类最终会进入乌托邦还是地狱，谁也预测不了。但有一点是肯定是，就是未来人类的世界肯定有翻天覆地的变化。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:5","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"现在是最好的时代  现在是最好的时代，全球局势以和平为主，经济空前繁荣，大多数人拥有自由，环境也没有被严重破坏。无论你是有神论者，无神论者，种族主义者、资本主义者、共产主义者等等，都有追求自己想要生活的权利。中国在飞速的进步，谈到未来没有一个人不信心满满，要珍惜这个充满希望的时代。 ","date":"2021-08-16","objectID":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:6","tags":null,"title":"《人类简史》读后有感","uri":"/posts/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"这个星期我去了六次网吧，吃了三次炸鸡。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:0","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"网吧 虽然说我家里也有电脑，也能打lol，但就像是别人的女朋友总是比自己的女朋友好看一点，外面的电脑也比自己家的好玩一点。 现在好多网吧都倒闭了，剩下的经常爆满，我和刘金金金宇在三家网吧都充了钱，随时更换阵地。 打LOL终极魔典，一开始我两被敌人玩弄于股掌之间，然后我两玩弄敌人于股掌之间，再到后来我两被队友玩弄于股掌之间。 l4d2这个游戏，就是LOL的互补品，有的时候玩LOL玩得便秘，就拿这个游戏疏通一下。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:1","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"炸鸡 炸鸡配菠萝啤——金童玉女 炸鸡配可乐——两小无猜 单点炸鸡——玉体横陈 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:2","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["随笔杂记"],"content":"华莱士 别跟我说吃华莱士成喷射战士，上20块钱网吃20块钱华莱士不香么。它卖的确实是泻药，你看不起泻药？泻药也是药。治便秘，不含糖。 ","date":"2021-08-11","objectID":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/:0:3","tags":null,"title":"网吧＋炸鸡 yyds!","uri":"/posts/%E7%BD%91%E5%90%A7%E7%82%B8%E9%B8%A1-yyds/"},{"categories":["笔记"],"content":"安装python 1）安装依赖包 安装 “Development tools” 软件组： sudo yum groupinstall \"Development tools\" 因为 Python 3.7 源文件使用 zlib 格式打包，所以需要安装 zlib 软件包；Python 3.7 编译安装时需要使用 zlib 的头文件和链接库，所以需要安装 zlib 的头文件和链接库 zlib-devel 软件包： sudo yum -y install zlib zlib-devel Python 3 有个内置模块 ctypes，它是 Python 3 的外部函数库（Foreign function library），它需要使用系统外部函数库（libffi）的头文件和链接库，所以需要安装外部函数库（libffi）头文件和链接库 libffi-devel 软件包： sudo yum -y install libffi-devel 2）运行如下命令配置、编译、安装 Python 3.7 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz tar xJf Python-3.7.0.tar.xz cd Python-3.7.0 sudo ./configure sudo make sudo make install 如果在编译安装时提示 zipimport.ZipImportError: can’t decompress data; zlib not available 错误，请查看关于 zlib 的解决方法。 如果在编译安装时提示 ModuleNotFoundError: No module named ‘_ctypes’ 错误，请查看关于 ctypes 的解决方法。 3）安装完成后，Python 3.7 安装在了/usr/local文件夹中，可运行文件/usr/local/bin，库文件/usr/local/lib。因为 /usr/local/bin 在 Shell 路径中，所以可以直接在 Shell 中输入如下命令 python3 运行 Python 3.7 解释器。 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"升级sqllite3 亲测有效 [root@localhost /]# sqlite3 --version [root@localhost /]# wget https://www.sqlite.org/2019/sqlite-autoconf-3270200.tar.gz [root@localhost /]# tar -zxvf sqlite-autoconf-3270200.tar.gz [root@localhost /]# cd sqlite-autoconf-3270200 [root@localhost /]# ./configure --prefix=/usr/local [root@localhost /]# make [root@localhost /]# make install [root@localhost /]# find /usr/ -name sqlite3 ＃检查版本 ## 最新安装的sqlite3版本 [root@localhost /]## /usr/local/bin/sqlite3 --version 3.27.2 2019-02-25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0f6d7 [root@localhost /]# ## Centos7自带的sqlite3版本 [root@localhost /]# /usr/bin/sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 [root@djangoServer ~]# ## 可以看到sqlite3的版本还是旧版本，那么需要更新一下。 [root@localhost /]# sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 [root@localhost /]# ## 更改旧的sqlite3 [root@localhost /]# mv /usr/bin/sqlite3 /usr/bin/sqlite3_old ## 软链接将新的sqlite3设置到/usr/bin目录下 [root@localhost /]# ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3 ## 查看当前全局sqlite3的版本 [root@localhost /]# sqlite3 --version 3.27.2 2019-02-25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0f6d7 [root@localhost /]# ＃将路径传递给共享库 # 设置开机自启动执行，可以将下面的export语句写入 ~/.bashrc 文件中，如果如果你想立即生效，可以执行source 〜/.bashrc 将在每次启动终端时执行 [root@localhost /]# export LD_LIBRARY_PATH=\"/usr/local/lib\" ＃检查Python的SQLite3版本 [root@localhost /]# ipython3 Python 3.7.1 (default, May 3 2019, 09:55:04) Type 'copyright', 'credits' or 'license' for more information IPython 7.5.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import sqlite3 In [2]: sqlite3.sqlite_version Out[2]: '3.27.2' In [3]: exit ———————————————— 版权声明：本文为CSDN博主「Echo......」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_43883625/article/details/100709484 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"cron表达式 linux中cron表达式有五位数 （秒）[分 时 日 月 星期] （年） 秒和年都不是unix系统自带的 21 17 14 7 7 #在7月14日星期天17时21分执行，只执行一次 “*” 表示每一 20 * * * * #每小时的20分钟执行一次，一天执行24次 20,40 * * * * #每小时的20分钟，40分钟执行一次，一天执行48次 20-40 * * * * #每小时的20到40分钟执行，每分钟执行一次，闭区间，每小时执行21次 */2 * * * * #0,2,4,6...58分钟时执行 其它，在这里https://www.bilibili.com/video/BV19t411G7KU?from=search\u0026seid=1398478951454031547 有的时候，在crontab里必须把命令写全，路径要是绝对路径，例如： * * * * * /root/.pyenv/shims/python3.7 /home/mail.py » /home/mail.log ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"解压 filename.zip的解压: unzip filename.zip filename.tar.gz的解压: tar -zxvf filename.tar.gz 其中zxvf含义分别如下 z: gzip 压缩格式 x: extract　解压 v:　verbose　详细信息 f: file(file=archieve)　文件 ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"查看时间 date ","date":"2021-08-08","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"linux学习笔记","uri":"/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"models 写入新数据，返回此条新数据 `new_data = Queue.objects.create(**queue_dic)` 访问新写入数据的id字段 `new_data.id` 查询数据 查询一条数据 `student = Student.objects.get(name='django')` 查看字典类型 `student.__dict__(前后两个下划线)` 筛选多条数据 `student = Student.objects.filter(name='python')` 它返回的student是一个对象的列表，可以看的出来student[0]和上面的get方式返回的student的结果是一样的。 修改数据库 对单一数据修改 data = Queue.objects.filter(statue=-1)[0] data.score = points data.msg = errorLst data.statue = 1 data.save() 批量修改 Queue.objects.filter(id=1).update(username='nick',is_active=True) ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:1:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"screen 新建窗口 `screen -S 名称` 连接到窗口 `screen -r 名称` 强制连接 `screen -D -r 名称` 查看列表 `screen -ls` ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:2:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"python导包 导入上级目录的包 import sys sys.path.append(\"..\") import xxx **sys.path的作用：**当使用import语句导入模块时，解释器会搜索当前模块所在目录以及sys.path指定的路径去找需要import的模块，所以这里是直接把上级目录加到了sys.path里。 **“..”的含义：**等同于linux里的‘..’，表示当前工作目录的上级目录。实际上python中的‘.’也和linux中一致，表示当前目录。 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:3:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"django-crontab定时任务 django-crontab还挺方便的，但是不好使:https://www.jianshu.com/p/b1ac0d7ae20c django-crontab官网：django-crontab · PyPI cron表达式：https://cloud.tencent.com/developer/article/1343175 菜鸟教程linux：https://www.runoob.com/w3cnote/linux-crontab-tasks.html crontab -e #编写cron python3 manage.py crontab add python3 manage.py crontab remove python3 manage.py crontab show linux中cron表达式有五位数 （秒）[分 时 日 月 星期] （年） 秒和年都不是unix系统自带的 21 17 14 7 7 #在7月14日星期天17时21分执行，只执行一次 “*” 表示每一 20 * * * * #每小时的20分钟执行一次，一天执行24次 20,40 * * * * #每小时的20分钟，40分钟执行一次，一天执行48次 20-40 * * * * #每小时的20到40分钟执行，每分钟执行一次，闭区间，每小时执行21次 */2 * * * * #0,2,4,6...58分钟时执行 其它，在这里https://www.bilibili.com/video/BV19t411G7KU?from=search\u0026seid=1398478951454031547 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:4:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"在外部使用django的orm import sys import os from django.core.wsgi import get_wsgi_application sys.path.extend(['/autoReport',]) #修改django项目位置 os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\",\"autoReport.settings\") #修改自己的django项目名 application = get_wsgi_application() from home.models import Reportinfo ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:5:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["笔记"],"content":"部署 gunicron 安装 pip3 install gevent pip3 install gunicorn 配置文件，和settings.py放在同一目录 # gunicorn.py import logging import logging.handlers from logging.handlers import WatchedFileHandler import os import multiprocessing bind = '0.0.0.0:1234' #绑定ip和端口号 backlog = 512 #监听队列 chdir = '/autoReport' #gunicorn要切换到的目的工作目录 timeout = 30 #超时 worker_class = 'gevent' #使用gevent模式，还可以使用sync 模式，默认的是sync模式 workers = multiprocessing.cpu_count() * 2 + 1 #进程数 threads = 2 #指定每个进程开启的线程数 loglevel = 'info' #日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置 access_log_format = '%(t)s%(p)s%(h)s\"%(r)s\" %(s)s%(L)s%(b)s%(f)s\" \"%(a)s\"' #设置gunicorn访问日志格式，错误日志无法设置 \"\"\" 其每个选项的含义如下： h remote address l '-' u currently '-', may be user name in future releases t date of the request r status line (e.g. ``GET / HTTP/1.1``) s status b response length or '-' f referer a user agent T request time in seconds D request time in microseconds L request time in decimal seconds p process ID \"\"\" accesslog = \"/autoReport/gunicorn_access.log\" #访问日志文件 errorlog = \"/autoReport/gunicorn_error.log\" #错误日志文件 启动服务器 gunicorn -c ./autoReport/gunicorn_conf.py autoReport.wsgi:application 关闭 fuser -k 1234/tcp nginx 用宝塔 ","date":"2021-08-08","objectID":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/:6:0","tags":null,"title":"django笔记进阶","uri":"/posts/django%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6/"},{"categories":["技能分享"],"content":"QQ邮箱设置 ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:1","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"python代码 import json import requests import smtplib from email.mime.text import MIMEText from email.utils import formataddr import re #发邮件 def mail(my_sender,my_user,subject,msg_text): my_pass = 'XXXX' # 发件人邮箱密码 ret = 1 try: msg = MIMEText(msg_text, 'html', 'utf-8') msg['From'] = formataddr([\"XXX\", my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['To'] = formataddr([\"收件人昵称\", my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['Subject'] = subject # 邮件的主题，也可以说是标题 server = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender, [my_user, ], msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret = 0 return ret ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:2","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"时间判断 import datetime # 范围时间 d_time = datetime.datetime.strptime(str(datetime.datetime.now().date())+'9:30', '%Y-%m-%d%H:%M') d_time1 = datetime.datetime.strptime(str(datetime.datetime.now().date())+'9:33', '%Y-%m-%d%H:%M') # 当前时间 n_time = datetime.datetime.now() # 判断当前时间是否在范围时间内 if n_time \u003e d_time and n_time\u003cd_time1: pass ","date":"2021-08-08","objectID":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/:0:3","tags":null,"title":"python发邮件","uri":"/posts/python%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"categories":["技能分享"],"content":"vscode的这个ssh remote插件真是让我又爱又恨，本来用着好好的，今天突然连不上远程服务器了。看控制台，唯一能看懂的就是这一句“试图写入的管道不存在。”在网上找了好久，总共有四五种解决方法，没有一种是管用的。 ","date":"2021-08-03","objectID":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/:0:0","tags":null,"title":"win10 vscode remote ssh \\\"试图写入的管道不存在\\\"相关报错解决","uri":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"categories":["技能分享"],"content":"解决方法 在ssh配置文件目录下`C:\\Users\\sunbaile\\.ssh` 有两个文件。`config```是配置文件，另一个```known_hosts`是出问题的文件。 编辑`known_hosts`，把出错的那个主机ip那一行记录的信息删了。 然后我发现虽然没有报错了，还是连不上去。 重启一下电脑，竟然就连上去了。 草拟吗windows 每次都会遇到不明不白的环境问题，然后忙了大半天，不明不白的解决了qwq ","date":"2021-08-03","objectID":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/:0:1","tags":null,"title":"win10 vscode remote ssh \\\"试图写入的管道不存在\\\"相关报错解决","uri":"/posts/win10-vscode-remote-ssh-%5C%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8%5C%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"categories":["笔记"],"content":"NGINX ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"nginx常用命令 whereis nginx #找到nginx目录 cd /usr/local/nginx/sbin #sbin是存放命令的目录 ./nginx #启动nginx ./nginx -s stop #停止 ./nginx -s quit #优雅退出 ./nginx -s reload #重新加载配置文件（常用 ps auxgrep nginx #查看Nginx进程 ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置文件 # /usr/sbin/nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 配置文件解释参考： https://blog.csdn.net/tjcyjd/article/details/50695922 ","date":"2021-08-02","objectID":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"NGINX学习笔记","uri":"/posts/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"老同学没有忘记 高中同学感情很深，分别一年，互相想念。我才刚到家两天，泽枫，国荣，宇龙都发消息给我找我出去玩。我对高三博雅班的同学没有任何好感，但是对以前二班的同学我很愿意继续相处。 ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:1","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"张宇龙的升学宴 一个五河的小伙子，我高中的好兄弟。今年复读一年考上北京的对外经贸大学，大喜，十分热情的邀请我去五河县他家里吃席。 同去的还有一年没见的二班同学，刘星宇、周锐、叶雨辰。见了面我们几个老二班人聊得很开心，大家变化都不大。刘星宇还是那个吃货，复读一年考上安徽大学。周锐在西北农林科技大学大展身手，也是很牛的。叶雨辰去了北外，性取向仍然不明确。周锐和叶雨辰不知道啥时候能公开在一起（调皮） 去五河的路上还有一个小插曲，就是我们四个理科生全部理解错了张宇龙的意思，买错了票，坐错了车。而文科生都买对票了。哈哈哈太有趣了。 我跟他们在一起真的很舒服，说了好多有趣的话，之前没发现我口才这么好哈哈哈哈（自夸） ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:2","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"张宇龙 张宇龙我最佩服的是他的胸怀，他有真正男人的胸怀，以天下为己任，信仰共产党，热爱祖国热爱人民。他是优秀的文科生，跟浮躁的理科生是完全不同的。 我跟他兴趣爱好，家庭环境差别很大，但是我两就是很能聊得来。我对他感兴趣，他也对我感兴趣，这个朋友是要好好处的。 ","date":"2021-08-01","objectID":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/:0:3","tags":null,"title":"和老同学的难得一见","uri":"/posts/%E5%92%8C%E8%80%81%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9A%BE%E5%BE%97%E4%B8%80%E8%A7%81/"},{"categories":["随笔杂记"],"content":"型号LG 29wk500，入门级带鱼屏 ","date":"2021-07-30","objectID":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/:0:1","tags":null,"title":"带鱼屏真是太太太爽爽爽啦","uri":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/"},{"categories":["随笔杂记"],"content":"真沉浸感！ ","date":"2021-07-30","objectID":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/:0:2","tags":null,"title":"带鱼屏真是太太太爽爽爽啦","uri":"/posts/%E5%B8%A6%E9%B1%BC%E5%B1%8F%E7%9C%9F%E6%98%AF%E5%A4%AA%E5%A4%AA%E5%A4%AA%E7%88%BD%E7%88%BD%E7%88%BD%E5%95%A6/"},{"categories":["笔记"],"content":"展示  概括来说，就是用django开发的web项目。相当于一个学生管理系统＋评测系统，开发完成后部署。这个项目，在一起参与暑期实习的很多同学看来，应该是很牛很牛的项目了。牛在哪里呢？牛在我们真正把东西做出来，部署好，让每个人打开浏览器就能访问，让大家都能体验到我们做的这个项目是实实在在的，不是只会做ppt，纸上空谈。  我们也确实策划了很久，半个学期之前李昕老师就找我们就开始做了，受了老师很多指点，我们自己也很早开始学习相关知识。项目能做成这个样，既是意料之外，又是情理之中。 ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:1","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"组员  我们这一组四个人两男两女，真是默契到让好多人羡慕。整个小学期的开发过程真是行云流水，稳步推进，没遇到大的阻碍。每个人的分工明确，各自做各自的内容。组员之间没有交流障碍，互帮互助，氛围十分融洽。时不时开个玩笑，大家欢声笑语，没有压力。如果有任务没完成的，不用组长催，组员自己愿意留下来加班到11点。  我作为组长，不谦虚的说，我们组能这么默契，跟我的领导能力有一点关系的，哈哈哈。我自己超前学习，掌握大方向。平时布置任务就分工明确，分工合理。我跟组员相处很好，实习前特地请大家吃了顿火锅。实习结束后，大获成功，请大家喝了杯奶茶。我觉得一个做项目的小组，不应该是冷冰冰的，而应该是一起既能工作，又能吃喝玩乐。  徐朔，和我爱好相投，都对电子产品感兴趣，我两特别聊得来。解决问题的能力非常强，虽然有时有点不靠谱，但是是顶梁柱之一。  廖集秀，性格很好。虽然是后期加入的，但是很好学，很快就跟上了我们的进度。很负责，为了做好自己的内容主动加班，点赞。  王文婕，挺能干的，一个人，光是views.py里就写了700多行代码。性格比较活泼，活跃气氛很好。 ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:2","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"未来  我其实并不期望我们能把这个项目做得很大，像大创的项目概述里写的那样。只期望我们几个能一直进步，组里氛围依旧融洽，产品最终可以投入使用。也希望新的成员李传兰同学能很好融入我们。  就这样吧，来日方长，再接再厉！ ","date":"2021-07-28","objectID":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/:0:3","tags":null,"title":"暑期实习项目-onlinejudge在线测试平台","uri":"/posts/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE-onlinejudge%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"},{"categories":["笔记"],"content":"打开docker服务 systemctl start docker docker一直在后台运行 `docker run -dit judge:0.2 /bin/bash` 复制 `docker cp 容器id:容器内路径 目的主机路径` `docker cp /root/testPython/test01/ $(docker ps -q):/usr/src/app` `docker cp /root/testPython/judge_file_o.py $(docker ps -q):/usr/src/app/test01/judge` 容器外执行命令 `docker exec -it $(docker ps -q) /bin/bash -c \"python /usr/src/app/test01/judge/judge_file_o.py\"` 进入正在运行的容器 `docker exec -it $(docker ps -q) /bin/bash` `docker attach 容器id` 显示容器编号 `$(docker ps -q)` 将文件拷贝出来 `docker cp $(docker ps -q):/usr/src/app/test01/user/tmp.txt /root/testPython/` 强制删除容器 `docker rm -f $(docker ps -q)` 停止容器 docker stop 容器ID或容器名 优雅的停止容器 删除镜像 docker rmi -f 镜像id docker rmi -f $(docker images -aq) MySql同步数据 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"拉取 docker search mysql docker pull mysql:5.7 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"运行 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345 --name mysql01 mysql:5.7 -d后台运行 3306是容器外端口 -v数据挂载；本地：容器 要配密码，怎么配？在dockerhub上帮助文档 容器名 所选镜像 python操作数据库 `pip install mysqlclient` 使用mysqlclient，要自己写sql语句 conn= MySQLdb.connect( host='localhost', port = 3306, user='root', passwd='123456', db ='test', ) 数据库权限 mysql\u003eGRANTALLPRIVILEGESON*.*TO'root'@'%'IDENTIFIEDBY'123456'WITHGRANTOPTION;mysql\u003eflushprivileges;//其中各字符的含义：//*.*对任意数据库任意表有效//\"root\"\"123456\"是数据库用户名和密码//'%'允许访问数据库的IP地址，%意思是任意IP，也可以指定IP//flushprivileges刷新权限信息Dockerfile FROM # 基础镜像，当前新镜像是基于哪个镜像的 MAINTAINER # 镜像维护者的姓名混合邮箱地址 RUN # 容器构建时需要运行的命令 EXPOSE # 当前容器对外保留出的端口 WORKDIR # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 ENV # 用来在构建镜像过程中设置环境变量 ADD # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY # 类似ADD，拷贝文件和目录到镜像中！ VOLUME # 容器数据卷，用于数据保存和持久化工作 CMD # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最 后一个生效！ ENTRYPOINT # 指定一个容器启动时要运行的命令！和CMD一样 ONBUILD # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发 ","date":"2021-07-19","objectID":"/posts/docker%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"docker笔记","uri":"/posts/docker%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"这话我是故意这么说的。今天是7月17日，我“大病”一场，身体彻底垮了，才知道身体和健康是多么重要。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:0","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"胡吃海喝 昨天是军训结束的第一天，晚上正好是啤酒节开幕式，我和秋豪一起去逛逛。本来我是想在学校吃完再去的，但是秋豪兴致勃勃地对我说，咱们一定要出去再吃一次海鲜，如果你不跟我出去吃我立马回寝室学习。秋豪找了一家美团评分4.9的“金鱼村海鲜大排档”，离啤酒节不远。我想上次咱们去找海鲜大排档没有找到，这次也很想去尝尝，就同意了。 这家“金鱼村海鲜大排档”确实是大排档，但是价格比上次在店里吃的还贵，海鲜大咖没上次的海鲜品种多，味道也不如上次。吃饱之后，我们就去逛啤酒节了。 晚上睡觉吃了个西瓜（后来我才知道西瓜不能和海鲜一起吃），晚上啥事儿没有。我知道第二天早上可能会拉肚子，但是没想到会这么严重。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:1","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"被送去急诊 早上5点，肚子疼，拉了三次，吐了两次。实在受不了，孙萃骑着电驴把我送进校医院急诊。这两天看《红楼梦》，看到晴雯、黛玉都病死了，我也觉得我要不行了。 我当时疼的在床上打滚，萃萃帮我挂号，接吐，扶我去便检，真的好感动。我疼的大喊大叫，那种感觉最好一辈子都不要再有了，就好像有人在拧毛巾似的在拧你的胃，还拧了两三个小时！医生给我屁股上打了针麻醉，半个小时后才疼痛才慢慢缓解，我就立刻睡着了。 起来之后，发现帅帅来看我了，又感动一波。再过一会儿，桐桐、苏文、云川也来了，再感动一波。人家是事不过三，后来秋豪也来了，我绷不住了，吊完水我们一起回去的。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:2","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["随笔杂记"],"content":"身体最重要 好多年没这样酣畅淋漓的生病了，生病疼就不说了，浑身乏力，啥也干不了。花这些冤枉钱，还不如平时多买点水果吃。以前对饮食都不当回事儿，从这件事以后，我对我的饮食要多加小心了，尤其是辛辣油腻的食物。我现在看到大荤大肉就觉得恶心，这两天当素食主义者吧。 ","date":"2021-07-17","objectID":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/:0:3","tags":null,"title":"身体第一、健康第二","uri":"/posts/%E8%BA%AB%E4%BD%93%E7%AC%AC%E4%B8%80%E5%81%A5%E5%BA%B7%E7%AC%AC%E4%BA%8C/"},{"categories":["书影记录"],"content":"87版《红楼梦》  87红楼梦拍得是相当好的。小时候看不懂，不以为然。后来看了新版红楼梦（10版），才知道87版红楼梦是多么经典。导演王扶林拿捏了每一处细节，用高超的手法尽可能地还原了红楼梦原著。为拍摄此剧付出的代价也远高于现代拍摄的古装剧。演员也各个都是颜值天花板，看得好不过瘾！  看看拍这部剧的投资： 1984年9月10日，该剧在安徽黄山正式开机，录下了第一组镜头，1987年上半年完成拍摄，总投资为680万人民币。整个拍摄过程历时三年之久，剧组先后走遍全国10个省市的41个地区的219个景点，拍摄镜头近万个。（来自百度百科）  拍摄时王导采用军事化管理，全剧组一百多位演员每天早上要在北京圆明园练功。就连演丫鬟的都要学唱戏，学走路，还要求所有人熟读红楼梦。剧组在北京专门修了一座大观园用于拍摄，由于北京用地紧张，荣国府和宁国府建在河北。现在都是旅游景点。  据说当时拍摄用了三千套衣服，基本还原了曹雪芹原著。因为曹雪芹没有写完红楼梦，所以全剧的结尾是由各地红学家齐聚一堂商讨出来的，并非高鹗续本。 陈晓旭（饰演林黛玉）  主要演员的竞选很激烈，林黛玉组中陈晓旭胜出。陈晓旭面试的时候，把她14岁时写的一首诗《我是一朵柳絮》寄给王导： 我是一朵柳絮， 长大在美丽的春天里， 因为父母过早地把我遗弃， 我便和春风结成了知己。 我是一朵柳絮， 不要问我的家在哪里， 愿春风把我吹送到天涯海角， 我要给大地的角落带去春的消息。 我是一朵柳絮， 生来无忧又无虑， 我的爸爸是广阔的天空， 我的妈妈是无垠的大地。  生活中的陈晓旭就是把自己当成了林黛玉，演员和剧中人物的气质和性格如出一辙。  刚拍红楼梦时，大家对陈晓旭饰演的林黛玉不太满意。很多人认为剧中的林黛玉没有原著中“仙女”的感觉，说陈晓旭演把林黛玉演的太尖酸刻薄，无异于常人。但是后面大家渐渐发现，陈晓旭已经把林黛玉演到了极致。林黛玉就是这种任性可爱的角色。  晓旭拍完红楼梦三年就没有再拍戏，1999年落发出家，法号妙真。2007年香消玉殒，享年41岁。  张国荣拍完《霸王别姬》后深陷其中，难以从剧中人物程蝶衣走出来。红楼梦其它很多演员也是如此，比如陈晓旭、欧阳奋强（饰演黛玉）、张莉（饰演薛宝钗）。尽管荧幕已经结束了，但是荧幕中角色的灵魂和他们的灵魂相融，到底是现实还是荧幕？入戏太深，真真假假分不清楚。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:1:0","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"人物评价（仅个人观点 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:0","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第一代 贾母：一生享尽荣华富贵，对人情世故明澈洞察。是贾府的精神支柱，贾母没了之后贾府加速衰败。 贾敬：红楼梦化学家，炼丹给自己毒死了。本来考上清北了，但是人家不去。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:1","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第二代 贾政：典型严厉大父亲。本来能考清北，被保送普通一本。 贾赦：色批头子。 贾珍：色批三人组之一，跟儿媳妇偷情，无能之辈。 邢夫人：蠢女人。 王夫人：“吃斋念佛大善人”。（讽刺） 尤氏：软弱无能。被王熙凤骂作“锯了嘴的葫芦”。 赵姨娘：长得有几分姿色，但情商极低。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:2","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"第三代 贾琏：好色，但人家长得帅，被很多女人嫖过，天天惹凤凤生气。 宝玉：虽难得有怜惜女孩儿之心，模样俊俏得贾母喜爱，但毕竟是纨绔子弟，不谙世事，也没啥出息。 贾蓉：感觉是贾府唯一正常公子，能干事情，也会耍花招。 贾环：反面人物，猥琐小人。跟丫鬟赌钱赖账，故意把蜡油撒宝玉脸上。 贾芸：跟着贾芸学说话，白手起家赚大钱。 薛蟠：大傻逼，不过倒活的也挺自在，跟大帅哥柳湘莲拜把子。薛家一大祸害，后期怕老婆。 宝钗：富贵宝姐姐，大气端庄有才华，诗词百科全书。 史湘云：湘云小可爱，太妹性格，史家被抄之后就见不到了。最后在一艘船上沦为娼妓，跟这首诗一样凄凉： “寒塘渡鹤影，冷月葬花魂。” 湘云美颜暴击： 贾瑞：b站弹幕称red爷（瑞大爷），贾家远亲，癞蛤蟆想吃王熙凤，与其说被王熙凤整死，不如说自己痴情而死。 探春：有王熙凤的气魄，可惜赶上贾府衰败，后被太妃远嫁，不知结局如何。 黛玉：宝玉的学霸女友。冷艳孤高但可爱，多愁善感又专情。 最标志的古典美人之一，曹雪芹评价为： “两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。” “闲静时如姣花照水，行动处似弱柳扶风”。 下图林妹妹美颜暴击： 迎春：软弱无能。 元春：前额饱满，长得就很贵妃。心肠不太好，最后被皇上赐死（猜测）。 惜春：三春中只有惜春是东府姑娘，冷漠无情，与其它人划清界限，最后出家，结局算好的。 秦可卿：大美人，长得有点妖。据说是神仙，启蒙宝玉性教育。秦可卿之死是个谜。 王熙凤：“北大光华管理学毕业”，性格泼辣，口齿伶俐，办事得体，长得还漂亮。啥都能管，就是管不住老公。全剧的核心人物，几乎每一集出场，台词最多。演员邓婕老师也很牛。 凤姐美颜暴击： 林黛玉进贾府，影响最深刻的就是王熙凤，“未见其人先闻其声”，高中语文课本名场面。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:3","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"丫鬟 袭人：宝玉性教育启蒙，宝玉房里首席丫头，宝玉准未婚妾，每日寻宝任务，后期有点黑化。 晴雯：模样俊俏（有点像林妹妹），脾气刚烈，撕扇子经典桥段。最清白，最可爱，声音最好听，却被王夫人害死。 晴雯判词： “霁月难逢，彩云易散，心比天高，身为下贱，风流灵巧招人怨。寿夭多因诽谤生，多情公子空牵念。” 晴雯是为数不多死在曹雪芹笔下的红楼女子，从判词可以看出曹雪芹也很喜欢晴雯。 晴雯美颜暴击： 麝月：吵架吵不过了请叫麝月姐姐来帮忙。 平儿：真的好喜欢平儿，美人坯子，不卑不亢，王熙凤助理兼闺蜜兼情敌，王熙凤和贾琏每次吵架都是平儿背锅挨打，好心疼。 小红：红楼梦鸡汤主角，靠才华成功的励志人物典范之一。贾家被抄后意外遇见贾芸，很好的结局。 金钏：跟宝玉淘气，被“教子有方，心地善良”的王夫人逼死。 紫鹃：微胖的小可爱，跟了黛玉一辈子。 紫鹃美颜暴击： ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:4","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"其它人物 刘姥姥：看似小丑，实则精明。没多少人能比得上刘姥姥的。 贾雨村：“知恩图报贾雨村”。林黛玉老师，第一集带林黛玉进贾府，最后一集带忠顺王抄贾家。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:5","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"宝玉和黛玉  黛玉和宝玉的爱情故事太凄惨了，曹雪芹的《枉凝眉》写道： 一个是阆苑仙葩，一个是美玉无瑕 。若说没奇缘，今生偏又遇着他；若说有奇缘，如何心事终虚化？一个枉自嗟呀，一个空劳牵挂。一个是水中月，一个是镜中花。想眼中能有多少泪珠儿，怎经得秋流到冬尽，春流到夏！  宝玉和黛玉本是天造地设的一对，可惜覆巢之下安有完卵，贾府衰败已成定局。宝玉连林妹妹最后一面都没见到，只提着黛玉送的玻璃绣球灯出家去了。看到这里真绷不住了，我为宝黛一大哭！  黛玉的性格现代人看来是有缺陷的，太多愁善感、太悲观，啥事儿都往坏处去想，没有革命乐观主义精神，天天读诗经，西厢记那种闲书有啥用，不如学学马克思主义。（调皮 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:6","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"贾家被抄  贾家被抄，红楼一梦终破碎。原贾府常买卖丫鬟，现贾府的大小姐当成商品被贱卖。原刘姥姥向王熙凤下跪求施舍，现王熙凤向刘姥姥下跪求找巧姐。原宝玉戏说贾芸像他儿，现贾芸救宝玉出狱。史家出事，贾家没怎么帮忙，还怕惹上关系。现在贾家也出事了，贾家平日的那些至交要么落井下石，要么冷漠无视。来狱中看望的，仅有当年被贾府嫌弃的贾芸和刘姥姥！今昔对比，多么讽刺！  最后建议大家在b站看87版《红楼梦》电视剧，看弹幕真的特别有趣。 此文在迁移站点时图片全挂，现在是替换后的版本。 ","date":"2021-07-14","objectID":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/:2:7","tags":null,"title":"87《红楼梦》观之有感","uri":"/posts/87%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%A7%82%E4%B9%8B%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"阅读经历  学期初，室友刘桐荐此书，从图书馆借阅，全书600页。初捧读，爱不释手，觉此书为模仿红楼梦所著，多描写封建大家族男女情爱之事。期末，又有闲，再捧读。读罢，忽觉此书内涵之丰富，有深刻历史背景。  此书在文学上的地位虽比不上四大名著之一的《红楼梦》，但绝对算是一本旷世巨著。作为一个普通读者，浅读完毕，我是没有资格去“评判”这本书。但是每次阅读完一本经典，都是心灵的洗涤，有很多思考和感受，想尽可能记录下来。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"一句话概括内容  《京华烟云》故事始于1901年义和团运动，讫于上世纪30年代抗日战争，前后跨越30多年，借北平姚、曾、牛三大家族的悲欢离合和恩怨情仇反映了家国变迁和世道兴衰。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介  林语堂（1895年10月3日—1976年3月26日），和鲁迅同一时代。不是传统的中国文学家，多用英文写作，致力于把中国文化扬播四海。《京华烟云》这本书翻译的很不错，不知道译者是谁。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"随便写两句感想  在封建大家庭中，承担整个家庭顶梁柱的，固然是男性。但是家庭内部，维持着每一个细节的是女性。《红楼梦》和《京华烟云》，都是以女性为主要视角，讲述大家庭内部的故事。  书中让我印象最深刻的，就是对上个世纪初“封建”大家庭的生活图景的描绘。封建之所以打双引号，是因为自从辛亥革命清政府被推翻后，中国早不再是完全的“封建”。那个年代，大多数人还保持着“封建”的思想，但是又有各种新思想涌入国内，而北京，又是一个开放包容的城市。于是，各种文化交融在一起，产生了奇妙的化学反应。同一桌吃饭的人，服装都各有千秋，穿长衫的，穿西装的，穿旗袍的，穿裙褥的…如此有趣的时代。  下等人的生活，自然是劳苦乏味，也不值得描写。而上等人的生活，实在是精彩浪漫。一大家子住在香榭庭苑，没事儿就读书写字，吟诗作对。男人不必工作，女人也不用做家务，反正钱多的花不完。无聊了，就找几个朋友一起谈花饮月赋闲，或者和朋友一起外出登山揽胜，游山玩水。怕累？笑死，爷根本不走路，轿子直接给你抬到山顶。怕吃不好？笑死，直接给你在西湖游船上设宴，船头还有舞女吹箫助兴。少爷一方面都有自己的“青梅竹马”，另一方面没事儿的时候还能调戏调戏丫鬟。小姐也会向心上人暗送秋波，委婉表达爱意。男女之事，不是我们理解的“父母之命，媒妁之言”，而往往是少男少女先互相看上，有恋爱的意思了，才会有媒婆去提亲。这种婚姻一般也都是门当户对，幸福美满。什么是人上人？这才是人上人！  这本书有一位贯穿始终的女性人物，堪称男人心中的理想女性——姚木兰。她能满足你对“大家闺秀”的所有幻想。不仅长得好看，还特别聪明。这种“聪明”，是女性特有的聪明，能猜出人心思，会跟人聊天，还有一套化解夫妻矛盾的妙招。她有文化，能跟你品茗赏月，做风雅之事，但不露锋芒，不喧宾夺主。性格好，性格活泼，会吹口哨，时不时给你搞点小惊喜。感情专一，遵守儒家道德，安分守己，喜欢过平静日子。但所谓“理想”女性，只不过是男人心中的理想罢了，作为男人确实惋惜像木兰这种女子不能遇见。  书中写到抗日战争时期，日本人在中国犯下的种种罪行引起我心中强烈共鸣。我终于开始明白老一代人为什么那么痛恨日本。叫日本人“小日本鬼子”，是因为二战时日本人真的很矮，男人平均身高就1米5左右。他们粗俗野蛮，穷兵黩武，狂妄自大，收买培养中国汉奸，屠杀中国百姓，而且对于“性”，似乎永远不能满足，下至女童上至老妇都不放过。日本士兵是全世界士兵中最没有德行的，土匪好歹讲究仗义，只劫富不欺穷，而日本兵真的连土匪都不如。  《京华烟云》这本书是1939年出版的。那时的中国已经建立起抗日民族统一战线，全民族的抗日热情达到高潮，老一代腐败军阀大多已经被打倒。新一代年轻人怀着一腔报国热血，一批又一批参军加入抗日前线。小说的结尾中，木兰一行人逃亡内地，一路上收留了四个孤儿，这些孩子不是白收留的，他们生下来就怀着对日本的仇恨，未来也将成为抗战的栋梁。一路上不断有满载军人的卡车呼啸而过，他们都是自愿参军的年轻人，戴着钢盔在车上站的威风凛凛，向老百姓招手。军人得到民众的欢迎，开始唱出军哥，重复的句子是： “上战场 为家为国去打仗 山河不重光 誓不回家乡”  抗日战争胜利是1945年，本书出版日期比日本正式投降早了6年，但是对华夏文明知根知底的林语堂先生，已经预测战争的胜利者必然是中国，他知道中国人的血脉里，从古至今都流淌着不屈的血液。  此书原版林语堂先生用英文写作，为外国人了解中国作出巨大贡献。写在抗日战争时期，政治意义可能大于文学意义。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:4","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"随便说两句人物 木兰：前面说过了，想了解请看原著，千万别看电视剧。 姚老爷子：神人，信奉老庄哲学，看透一切。 曼娘：典型传统女性，终生保留贞操。 陈妈：典型中国母亲，倾其一生找寻儿子。 红玉：原型林黛玉！古典女性，多愁善感，殉情而死。 姚体仁：纨绔子弟。 孔立夫：赤子之心，有点看不透。 顺便画下人物关系： （仅部分） ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:5","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["书影记录"],"content":"最后  本书大部分片段的意境是宁静芬芳的味道，与《浮生六记》一样，让人向往以前人缓慢、舒适、宁静的生活。读书就是为了跨越时代的偏见，和古人对话，从现在浮躁的社会中获取一份心灵的安宁。 ","date":"2021-06-23","objectID":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/:0:6","tags":null,"title":"《京华烟云》读后有感","uri":"/posts/%E4%BA%AC%E5%8D%8E%E7%83%9F%E4%BA%91%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"起因  做大学物理大作业。张丽红老师给的课题很宽泛，做实物、写小论文都可以。我和何为就寻思着做一辆小车。本来想买树莓派，自己找配件，做一辆智能车，但是时间成本太高，于是就从淘宝上240块钱买了辆青少年编程学习玩具车。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:1","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"microbit单片机  微软搞的东西，面向青少年学习编程使用。上手十分简单，就真的是小学生的玩具。对于计算机专业的大学生来说毫无学习成本，编程完全可视化。在线编程地址：https://makecode.microbit.org/ microbit这个板子质量还是不错的，功能、接口也很多，实用性强。价格还好，100多块钱，比arduino贵不少，但是学生党可以接受。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:2","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"其它模块  电机、超声波模块、红外模块，车子底盘、还有一块电路板。基本都是淘宝卖家做好的成品，买回来花一个小时组装好就能玩了。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:3","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"演示效果  效果超好，红花在绿叶衬托下才好看，其它组几乎都搞的是综述、论文，只有我们组做出了实物。现场演示让老师赞不绝口，大大的表扬了我们。很开心，但是有点惭愧，其实我们买的都是成品组装的，没啥技术含量，没有那些搞论文的花时间多。有点愧不敢当。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:4","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"后续  男孩子对这种东西其实都蛮感兴趣的。以后可以结合咱们专业，拓展更高级的功能，比如计算机视觉。这个单片机用处也很大，可以拿来装在别的东西上。 ","date":"2021-06-21","objectID":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/:0:5","tags":null,"title":"大物大作业-microbit编程小车","uri":"/posts/%E5%A4%A7%E7%89%A9%E5%A4%A7%E4%BD%9C%E4%B8%9A-microbit%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%BD%A6/"},{"categories":["随笔杂记"],"content":"​ 毛主席在《恰同学少年》中说： “我最佩服的，是古希腊的斯巴达人，人数那么少，却能称霸希腊。为什么？因为他们不仅重视精神之文明，更崇尚野蛮之体魄。” ​ 说起锻炼，重要性不言而喻。锻炼可以减轻压力、可以增强自信、可以减肥、可以让人少生病…不要觉得锻炼浪费了你的时间，我认为锻炼实际上是一种稳赚不赔的投资。每天投资一个小时去锻炼，收获的是每天多两小时充沛的精力。有这两小时充沛的精力，可以做更多的事情，健身世界上成本最低的升值方式。 ​ 很多人都曾有过锻炼的冲动吧。总有那么一阵子，为了谈恋爱、减肥、打篮球等理由，突发奇想去锻炼身体。第一天踌躇满志，跑了3公里，发个朋友圈，感觉美好的未来就属于自己了。第二天跑2公里就累了，第三天找个理由就不想再坚持了…大家都知道锻炼是好的，但是坚持下来的人少之又少。 ​ 我很骄傲的一件事，就是我坚持每天锻炼，坚持了整整一学期。这一学期的每一天，我都去器械场做力量训练，还经常到操场跑步。风雨无阻，没有落下一天。我练习长跑，最长一次跑了6公里，配速5分钟，跑完15圈，大汗淋漓，压力彻底被释放了。我想：这么长的距离都跑下来了，还有什么事能难得倒我了呢？ ​ 能一直坚持，也是因为有人陪我一起坚持。最开始，我和舒成一起约好每天在操场见面，后来有一些同学加入我们，但都是浅尝辄止，断断续续，不能坚持。到期末，每天都能到场的，基本上还是我和舒成两人。”坚持“的品质多重要啊，曾国藩一生不断强调恒之重要性，他说： “凡人作一事，便须全副精神注在此一事，首尾不懈，不可见异思迁，做这样想那样，坐这山望那山。人而无恒，终身一无所成。” ​ 锻炼要坚持，写日记要坚持，背单词要坚持，敲代码要坚持…很多能力素养，都是靠坚持培养出来的。大家的聪明才智都差不多，但为什么最终有的人走得很远，而有的人半途而废呢？我想，恐怕唯“坚持”二字，非人皆有之！ ​ 毛主席年轻时最爱干的两件事：一是读书，二是锻炼。读书和锻炼二事，也是我的目标，是我在整个大学期间不懈的追求。 ","date":"2021-06-21","objectID":"/posts/%E9%87%8E%E8%9B%AE%E5%85%B6%E4%BD%93%E9%AD%84/:0:0","tags":null,"title":"“野蛮“其体魄！","uri":"/posts/%E9%87%8E%E8%9B%AE%E5%85%B6%E4%BD%93%E9%AD%84/"},{"categories":["笔记"],"content":"课程时长  这门课上的不长，就大半个学期。任课教师王老师，是一位教学经验丰富的老师。也是统计学方面的专家，跟着他学习，感觉在很短的时间内学到了很多知识。 ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"课程感受  “概率论与数理统计”实际上是两门课，“概率论”内容包括：随机事件与概率、随机变量及其分布、随机变量的数字特征、大数定律与中心极限定理。“数理统计”是以“概率论”知识为基础的，课程中学习的内容包括：数理统计初步、回归分析。 这是一门很明显的数学课程，用到了数学工具“微积分”，定理有严格的数学推导证明。但是，在“数理统计”这一块，在进行参数估计、假设检验、回归分析时，对于我们构建的模型，只讨论“好”还是“不好”的问题，而不是“对”、“不对”，这是与数学的区别。 这门课可以说是我们人工智能专业的核心课程。这学期我自学了一段时间机器学习，发现机器学习需要大量用到数理统计的知识。而且在课本《随机数据处理方法》中，我看到了像“极大似然估计”、“回归分析”、“正交试验”等名词在机器学习中出现。可惜的是，由于课时较短，书本上后面大部分内容都不在课程内容中，只能自学。  如果不是为了搞人工智能，我觉得这门课也很值得学习。因为它给我带来了看待世界的全新角度。自然界中的分子，原子，人类生产生活中的产品等等，这些东西都是大量的。那么对于大量的，有规律的数据，我们如何去研究它，找出它的规律，预测它的性质？这个问题，由这门学科给出了解答。我不得不佩服人类的智慧，人借助数学工具，总是能用“奇淫巧技”解决问题，并把技巧上升到如此美妙的数学理论。当然，我感觉这门学科还是有很大的完善空间的，尤其是现在进入大数据时代，这门课更应该被重视，理应会有更多人去研究，贡献新的研究成果，为构建完整的概率论与数理统计大厦添砖加瓦。 ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"总结  这门课还挺难的，希望考试能过，千万别挂了qwq ","date":"2021-06-17","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"《概率论与数理统计》结课总结","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":" 现在人工智能真是火到了极点，各个专业都想转行搞人工智能。作为本来就是人工智能专业的学生，更是要趁早开始。所以，大一下学期，在老师的指导，以及同学和合作下，我开始接触人工智能的学习。 ","date":"2021-06-13","objectID":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"本学期“人工智能”学习结束总结","uri":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/"},{"categories":["笔记"],"content":"学习资料 从机器学习开始： **《统计学习方法》**作者：李航 教科书/课本，理论性强，也很权威。分为监督学习和非监督学习两部分。b站有啃书指导，“深度之眼”有视频教程，github上有代码实现：https://github.com/Dod-o/Statistical-Learning-Method_Code 和鲸社区 在这个平台上参加校内数据分析竞赛，学习资料蛮不错的，貌似是翻译的kaggle？ 机器学习的算法很多，涉及到很多概率论知识（真的好多），对数学功底要求比较高。 然后是深度学习： 飞浆 真的好好用，可以直接运行。https://aistudio.baidu.com/aistudio/projectdetail/1855447?qq-pf-to=pcqq.group d2l 国外的，有中文版，外国人的教程读起来都挺难受的，不过很全。https://zh-v2.d2l.ai/chapter_preliminaries/linear-algebra.html 这学期只算是刚刚入门吧，连代码都没跑过。 半个月后开始暑假小学期，期待进入下一阶段！ ","date":"2021-06-13","objectID":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"本学期“人工智能”学习结束总结","uri":"/posts/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9D%9F%E6%80%BB%E7%BB%93/"},{"categories":["书影记录"],"content":"我用不到一周的时间读完了这本《消失的13级台阶》，这本书是典型的日系推理小说，作者高野和明用电影式的叙述手法，清晰地讲述了一起跨度长达10年并且牵涉到多起犯罪事件的故事。读完之后，我深感震撼，不仅仅是因为精彩的故事情节和出乎意料的结局，还因为本书揭露了深刻的社会现实问题，生活在阳光下的我们或许从未关注过的关于“死刑”问题。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"作者简介 高野和明 日本小说家、编剧。他从小立志当导演，小学六年级就开始自己制作电影。1989年赴美深造钻研电影制作，1991年回国后开始剧本创作。 高野和明的科幻小说《人类灭绝》一经出版，立即横扫日本推理作家协会奖、山田风太郎奖等多项大奖。 《消失的13级台阶》是高野和明的出道作，一举斩获第47届江户川乱步奖，得到日本著名推理小说家宫部美雪的极力推荐和评委的一致好评，引发读者广泛关注。 高野和明的小说读起来像电影，具有相当立体的画面感，戏剧张力十足，节奏明快，毫无冷场。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说的情节 一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记忆…… 死刑执行官南乡携手刚假释出狱的纯一调查，希望替这位丧失记忆的死刑犯洗清冤屈。但他们查到的唯一线索，就是树原亮记得自己曾“走在台阶上”。 距离树原亮被执行死刑的时间所剩无几，但这起案 件始终疑云重重，仅有的线索“台阶”仿佛也凭空消失了…… 情节大赞，如果你对推理小说感兴趣，喜欢惊险刺激的故事情节，这本书值得一读！个人认为，在故事情节方面，完全不输于大名鼎鼎的推理小说作家东野圭吾。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说描绘了哪类人群 在我们的生活中，有一些我们很少接触到的人。他们有着特殊的职业或者特殊的经历。小说描绘了检察官中森、管教官南乡、律师杉蒲、有犯罪前科的纯一和安藤以及他们的家属等人的生活情状，让我看到了社会的另一面。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"小说讨论的问题：死刑应不应该被废除？ 大家都知道，漂亮国废除了死刑，中国没有废除，而日本对待死刑是极为慎重的态度。全世界国家对死刑的态度不同，死刑是敏感话题之一，有的政客把自己对死刑的主张作为个人标签宣传。 小说中不同的人对死刑持有不同的态度： 对于管教官南乡来说，他亲手对两位罪犯执行了绞刑，这样的经历让他十分痛苦，甚至破坏了他圆满的家庭，他对死刑制度恨之入骨。 而身为杀人犯的三上纯一，却在小说末尾支持死刑。我认为他的观点实际上也是作者的观点。当犯罪发生后，必须要由第三方来“公正”的审判，惩罚的力度必须足够，因为人类在对待生死的问题上不可能保持理性，如果允许人们使用“私刑”，将“冤冤相报何时了”。 关于审判罪犯，自古以来争议就没有停止过，究竟什么样的法律是公正的？人类怎么才能克服感性，做出最理性的判决？到底是支持“报应刑论”还是“教育邢论”？这些问题，可能永远都不会有标准答案吧。 ","date":"2021-06-06","objectID":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:4","tags":null,"title":"《消失的13级台阶》读后感","uri":"/posts/%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"课程时长 离散数学上了大一上，大一下两个学期（貌似是80个学时。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"课程目录 总共四个篇章，分别是“集合论”、“数理逻辑”、“抽象代数”、“图论基础”。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"课程感悟 这是一门数学课，但是和数学分析、概率论又完全不同。离散数学研究的真的是离散的数学知识，与微积分完全无关。其中各个章节相关性不大，也有部分章节相关。 这门课程要求不高，难度不大，离散数学中出现的新概念非常多，书中有了大量的定义和定理，因此特别适合画思维导图学习。 考试题型一半是概念考察，另一半是证明考察。 上学期学了前两篇，没体会到这门课的精髓，下学期学后面两篇，感觉后面才是这门课的重点内容。 ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"思维导图 上下学期的思维导图我都画了，在QQ群里可以找到，但是我懒得扒拉了。 这里只展示下半学期的两篇。     ","date":"2021-05-29","objectID":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"离散数学结课总结+笔记","uri":"/posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93+%E7%AC%94%E8%AE%B0/"},{"categories":["随笔杂记"],"content":"上大学之后，我对好多东西都很感兴趣，都想亲自去尝试，但是我做事情往往只有三分钟热度，坚持不了多久就会放弃。这样，我的精力被严重分散，我所拥有的知识，虽然有广度，但是没有深度。我知道这样对我长期的发展很不好。 昨天和上海回来的表哥交流，他已经有将近10年的工作经验了，跟他聊天我获得的信息非常有价值。我知道现在互联网行业的残竞争残酷，大家都知道学计算机捞钱，于是都去学计算机，计算机这个江湖很大，其中有很多二五仔进入凑热闹，没过多久他们就会被浪潮淹没，被历史忘记。真正能从江湖中混出来的，勇立潮头的，只有一小部分有真本事的人。 如何让自己成为有“真本事”？我觉得所谓“真本事”，就是那种只有你会，别人都不会的本领。我想起来孙运雷老师给我们的建议，他见我们第一节课就说了一个“一万小时理论”，他说，如果你在一个领域内深耕1万小时，那你一定会成为这个领域的专家。我曾是他的学生，他曾是我的导师，他给我们的建议就是要沉下心来，专心致志地研究一个领域，做好一件事。这个观点，和我表格所传达的是一样的。总结成一句话，就是“宁可要深度，也不要广度。” 高中政治课本上介绍了“主要矛盾”和“次要矛盾”的关系： 在复杂事物发展过程中，处于支配地位，对事物发展起决定作用的矛盾，叫主要矛盾，其他处于从属地位、对事物发展不起决定作用的矛盾叫次要矛盾。主要矛盾和次要矛盾相互依赖、相互影响，在一定条件下可以相互转化。 现阶段，对于我来说，“次要矛盾”就是弹吉他、打篮球、吃饭、谈恋爱、穿衣服、人际关系、读乱七八糟的书、学乱七八糟的知识等等。 而主要矛盾，只有如下两个方面： 写代码 功课（数学分析，离散数学、概率论与数理统计等，其它水课不算） 花花世界迷人眼，找到自己的定位很重要，可能会决定一个人一生的命运。对主要矛盾和对次要矛盾分配的精力是不一样的，对待主要矛盾，要“精益求精”，要抓紧时间，抓住机会，舍得下大力气，下大功夫去解决；对待次要矛盾，要“锦上添花”，有时间就搞一搞，没时间也不强求，但是得养成良好的习惯定期去做，不能浅尝辄止。 主要矛盾就像是人长身体所需要的蛋白质，需要大量摄入；次要矛盾就像是维生素，人需要的量很少，但是如果一点都没有，就会得病。有的团学，走了极端路线，要么只关注主要矛盾，省略了次要矛盾；要么错把主要矛盾抛在一边，把次要矛盾当成了主要矛盾，这更不可取。现在的我，反对极端主义，支持全面发展、协调发展，要统筹规划，理清主次、抓大放小，坚持走一种“中庸之道”。 以上写的都蛮虚的，其实我今晚真正的感悟是：我觉得我代码写得太少了，这段时间研究django、数据库、前端等等乱七八糟的东西，看似学的很多，其实啥都没学会，等到写大作业的时候才发现自己写代码能力很差。李昕老师也强调多次，说大一要把写代码的功底打牢，我现在才意识到我有一点跑偏。 ","date":"2021-05-03","objectID":"/posts/%E7%90%86%E6%B8%85%E4%B8%BB%E6%AC%A1%E9%9B%86%E4%B8%AD%E7%B2%BE%E5%8A%9B%E8%A7%A3%E5%86%B3%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE/:0:0","tags":null,"title":"理清主次，集中精力解决“主要矛盾”。","uri":"/posts/%E7%90%86%E6%B8%85%E4%B8%BB%E6%AC%A1%E9%9B%86%E4%B8%AD%E7%B2%BE%E5%8A%9B%E8%A7%A3%E5%86%B3%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE/"},{"categories":["书影记录"],"content":"今天是世界读书日，我想给大家推荐一本《如何阅读一本书》。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"基本介绍 《如何阅读一本书》初版于1940年，1972年又大幅增订改写为新版，是一本有六十多年历史经典名著。作者是美国作家[莫提默·J·艾德勒]和[查尔斯·范多伦]，二者都参加过《大英百科全书》的编写工作。 如书名所见，这本书的主题就是教人如何阅读一本书。该书介绍了一系列阅读的规则（或者说方法、技巧，下面统称为规则），熟练运用这些规则，可以高效阅读任何一种类型的书。本书主要介绍了四个阅读层次，分别是“基础阅读”、“检视阅读”、“分析阅读”、“主题阅读”，此外，还穿插介绍了如何对一本书做出评价、如何使用辅助工具、有哪些不同种类的读物、阅读对人的作用等等关于“书”的一般性知识。可以说，这本书介绍的内容涉及到了阅读的各个方面。其语言风格偏学院风，结构清晰，表达严谨，理论性强，所以比较难读，再加上又是译著，读起来就更是困难重重了。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"我的感受 我们从小到大，读的书说少也不算少，但是对于“阅读的目的”，“阅读的方法”，“如何挑选一本书”等问题，不能说知之甚少，只能说完全没有思考过。遇到这本书，真是幸运，它让我对“书”这个概念，有了全面的、一般性的了解，让我减少今后阅读书籍时的盲目，像是灯塔一样指引我阅读。 作者的观点我很赞同，比如 “阅读要主动。” 阅读的过程就跟上课一样，上课的时候，大脑要跟着老师一起思考；阅读也是如此，在阅读时，要努力地记忆、思考，这样才是高效的阅读方法，才不至于读了好几页都不知道作者在说什么。很多人拒绝在阅读时主动思考，书籍对他们来说只是消遣的工具，所以他们只能接受通俗作品而不愿意去阅读论述类作品和经典作品。 作者还认为，在你没有真正读懂作者说的东西时，不要轻易评价一本书！这个道理放到网络生活中也同样适用。我们可能经常看到这样的评论：“我不知道你在说什么，但我觉得你说得可能不对。” 这句话一被说出来，就充满了偏见。但是在网络中，这种“键盘侠”的言论无处不在。 古人说“读万卷书行万里路”，因为行万里路之后就会从地方性偏见走出来，就不会认为自己待的地方比其它地方更优越；读万卷书就会走出时代性偏见，因为在读书的过程中会跟过去的时代进行对话，走出时代性偏见，我们这一生从某种意义上来说其实都是在走出偏见。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"坚持养成读书的好习惯 这本书我只是走马观花地读了一遍，吸收了的知识大概只有10%，如果以后有时间，我还想再重新捧读一遍这样的经典作品。养成良好的阅读习惯，是我大学阶段的目标之一。 读书是一件性价比非常非常高的事情。一位作者，研究一个领域几年，甚至几十年得到的成果，写到一本书中，而我们只需要一周的时间阅读这本书，就可以获得这些知识！“读万卷书，行万里路”，作为大学生的我们，可能现在还没有机会“行万里路”，但是图书馆的万卷藏书一直摆在那里，那是知识的海洋，等待着我们去遨游。 ","date":"2021-04-23","objectID":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《如何阅读一本书》读后感","uri":"/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"话不多说，看看豆瓣评分吧： 8.8分，对于一个喜剧电影来说，算是不可多得的高分了。排名116名，妥妥的经典。豆瓣评分很多人都有争议，但其实我蛮认同豆瓣评分的。在豆瓣上，评分较高的电影往往都不是靠炫酷的特效或者出名的演员，而是看一部电影是否有内涵，有高超的艺术表现力，这和我评判一部电影是不是“好”电影的标准是一样的。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 公路剧，正男是一个和奶奶相依为命的小学生，菊次郎是一个老混混。阴差阳错，富有童心的菊次郎带着偏早熟的正男一起去找他的妈妈，一路上遇到的各种有趣的事情。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"观影感受 这是一部开头20分钟就能让我眼眶湿润的电影，中间又让我捧腹大笑，笑完之后继续哭，哭完再笑…… 日式幽默真是太合我的胃口了，正好戳中我的笑点，哈哈哈，好多经典桥段真的好有趣。 感觉特别温馨，菊次郎和正男一路上碰到的人都好可爱好友善，影片描绘的“夏天”，正是我理想中的那种夏天的氛围，慵懒、和谐、美好。 影片的叙述手法毋庸置疑是采用一种超现实手法，所有人看起来都呆呆的，在夏天好像都晒昏了头脑。但是一点也不影响故事的趣味性，再一次证明，“艺术源自于生活但是一定高与生活！” ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"独特之处 久石让的配乐真的很到位，《summer》这首歌的名气应该和这部电影“珠联璧合”。 看完之后，我觉得这部电影并没有特别想说明说明道理，也并没有特别想要歌颂什么。就像是音乐一样，贝多芬、莫扎克这样的音乐大师的音乐被称为经典，并不是它们说明了多么深刻的道理，而是它们可以引起观众内心的共鸣。《菊次郎的夏天》这部电影就是让我看的时候觉得非常舒服，让我流泪让我笑，我真是太爱这部电影了。 ","date":"2021-04-05","objectID":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《菊次郎的夏天》观后感","uri":"/posts/%E8%8F%8A%E6%AC%A1%E9%83%8E%E7%9A%84%E5%A4%8F%E5%A4%A9%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["技能分享"],"content":"疫情防控通自动填报教程 ","date":"2021-04-05","objectID":"/hide/autoreport/:0:0","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"前言 “天下苦疫情防控通久矣！”作为UPC学子，每天都要做一件“无聊”的事情——填报疫情防控通。如果哪天忘了填报，就会被导员无情通报批评。 为什么不做一个自动填报的工具呢？ 毕竟 “有需求就有市场”，有了自动填报疫情防控通的需求，当然就有大佬基于计算机知识做出了这样的工具。切实解决了同学们痛点需求，就其实用性来说，应当得到推广。但考虑到非计算机专业的学生使用起来有一定的门槛，于是本人写下这篇详细教程来教大家使用这个程序。 首先感谢作者： 作者 作者的免责声明 ","date":"2021-04-05","objectID":"/hide/autoreport/:0:1","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"原理简介 我们在微信里打开“疫情防控通”时，实际上是打开了一个网页（此时的微信只是相当于一个浏览器），用其它浏览器一样可以访问。该网页的地址可以通过抓包获得，网址如下： https://app.upc.edu.cn/ncov/wap/default/index 打开后填入数字石大的账号和密码就可以进入如下页面： 那么，我们就可以跳过微信，直接通过编写程序打开这个页面，登录完成后通过代码实现自动化操作，进行填报。 大佬已经编写好这样的程序了，使用的语言是js，每次执行这个程序，就可以完成自动填报。那么，如何让这个程序每天自己自动执行一次呢？ 大佬提出了解决方案，借助外界工具“腾讯云函数”来实现这个程序的每天定时执行。腾讯云函数服务就相当于你把你的程序放在了一台24小时不关机的电脑上，这台电脑位于“云端”，你看不见也摸不着，只能通过远程访问。之后你在这台电脑上设定一个“触发器”，让它在指定的时间周期触发这个程序运行。从此以后，你将不再需要手动进行任何操作，这台云端上的电脑，会坚持不懈地，准时无误地完成你让它执行的任务。而且，目前“腾讯云函数”功能是免费的哦~当然，它和普通电脑还是有很大差别的，你不能把它当成一台真正的电脑，但是完成咱们的疫情防控通自动填报任务还是绰绰有余的。 ","date":"2021-04-05","objectID":"/hide/autoreport/:0:2","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"下载程序并进行配置 下面进入教程环节： 首先打开github上的项目地址： https://github.com/tienskowl/AutoReport 点击download ZIP 下载压缩文件，然后解压（不会吧不会吧，不会真有人连解压都不会吧?(阴阳怪气)） 解压完的样子： 点进去之后有个index.js文件，这个文件需要安装Nodejs环境才可以执行，我们不需要在自己的电脑上执行这个文件，只要修改其中的代码就可以。所以点击右键，选择打开方式，用记事本打开就可以。 然后你就可以看到具体的代码内容啦，看不懂不要紧，我们只要修改“学号”、“密码”。 将“学号”、“密码”替换成你数字石大的学号和密码。 这里有几个问题，你可能会问到： 问：这个程序会不会有病毒，作者会不会窃取我的数字石大账号密码？ 答：不会。这个程序是完全开源的，你可以看到它所有的源代码，就像是你把一个人全身的衣服都扒光了看，你觉得他可能藏有武器吗？ 问：下面还有第三个参数“Server酱APIKEY”，这个要不要填写？ 答：这个“Server酱”可以帮助这个程序实现微信推送功能。个人建议最好去搞一个Server酱的apikey填在这里。至于这个apikey如何获得，请参考server酱官网 http://sc.ftqq.com/3.version，本教程不作详细说明。这就相当于你买了一辆汽车，建议你再安装一个车载导航，但是你具体买哪个牌子的车道导航就看你自己的决定了。 修改完之后大概是这个样子： 保存后关闭，一定要保存！ ","date":"2021-04-05","objectID":"/hide/autoreport/:0:3","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"上传到腾讯云函数并设置触发器 打开腾讯云函数官网： https://console.cloud.tencent.com/scf 在“函数服务”里点“新建” 创建方式“自定义创建”，函数名称随意，运行环境选择“nodejs12.16”，提交方法选择“本地上传文件夹”，点击“上传” 可能会弹出这样的消息，点上传就可： 如果上传失败了，也可以把AutoReport-master文件夹压缩后选择“本地上传zip包”提交。 然后点击“完成” 之后就能看见这个函数创建完成，点进去进行测试 腾讯云提供了在线编辑器，如果想修改代码，可以直接在这里改，确实很方便。 这里我们一定要把“自动安装依赖”打开，然后点“部署”，再点“测试” 预期的测试结果 如果你填了Server酱的APIKEY，应该还能收到微信发的推送通知。 好啦，最后一步，设置触发器 如下图，点左侧“触发管理”、“创建触发器” 选择“自定义触发周期”，填写Cron表达式，推荐使用 0 1 1,8 * * * * 该表达式是作者推荐的一个表达式，它所表达的意思就是每天触发两次，时间为每天的01:01和08:01 提交之后，就大功告成啦！你可以过上“从此君王不早朝”的生活啦！（误） ","date":"2021-04-05","objectID":"/hide/autoreport/:0:4","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"Tips Question: 这个程序是如何填写定位信息的？ Answer: 通过返回昨天填报的地点填写到今天的位置。从这里可以看出这个程序真的很巧妙，如果你的位置发生了改变（比如从学校回家），你可以在回家之后，抢在程序自动填报之前，手动填报一次。 如果有问题请在下方评论区提出，谢谢！ ","date":"2021-04-05","objectID":"/hide/autoreport/:0:5","tags":null,"title":"AutoReport","uri":"/hide/autoreport/"},{"categories":["技能分享"],"content":"大物实验得到的数据，用python的matplotlib很方便处理 数据准备： r = np.arange(0.5,6.0,0.5) u2 = np.array([6.66,6.49,6.37,6.37,6.17,6.12,6.18,5.98,5.97,5.93,5.91]) i2 = np.array([2.06,2.01,1.97,1.98,1.91,1.90,1.92,1.85,1.85,1.84,1.83]) uw = np.array([0.145,0.259,0.338,0.419,0.467,0.513,0.552,0.586,0.616,0.641,0.663]) n = ((uw*uw)/r)/(u2*i2) # len(r) # r n 画图： import matplotlib.pyplot as plt import numpy as np %matplotlib inline x = np.linspace(0.5,5.5,11) #横坐标11个数据 # y = np.array([0.31,]) #纵坐标11个数据 plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 plt.grid(True)#网格线 plt.title('热机效率随负载大小变化曲线图')#标题 plt.plot(x,n,'r') #显示红线 plt.plot(x, n, 'k.') #显示黑点 plt.xlabel(r'负载大小/R') plt.ylabel(r'热机效率') plt.xticks(x) #重新设置x坐标 plt.show plt.savefig('./热机效率随负载大小变化曲线图.png',dpi=200) #保存图片，清晰度200 效果 ","date":"2021-04-02","objectID":"/posts/matplotlib%E4%BD%9C%E7%83%AD%E6%9C%BA%E6%95%88%E7%8E%87%E9%9A%8F%E8%B4%9F%E8%BD%BD%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF%E5%9B%BE/:0:0","tags":null,"title":"matplotlib作热机效率随负载大小变化曲线图","uri":"/posts/matplotlib%E4%BD%9C%E7%83%AD%E6%9C%BA%E6%95%88%E7%8E%87%E9%9A%8F%E8%B4%9F%E8%BD%BD%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF%E5%9B%BE/"},{"categories":["随笔杂记"],"content":"从开学开始，我就接到了李昕老师的任务——为我们寒假的成果“一种基于docker和jupyter notebook的复合类型题目在线检测方法”撰写一份“专利申请”，并完成申请。第一作者当然是李昕老师，因为我们的核心代码全是李昕老师写的，第二作者包括我和另外一位贡献较大的成员。申请专利并署名我们既是一种奖励，又是一种考验。 申请文件包括四个小文件，分别是“说明书”、“权利要求书”、“说明书摘要”、“说明书附图”。整个撰写过程还是比较困难的，毕竟是从零开始做这种工作，期间除了询问李昕外，还得到了王志宽学长的极大帮助，学长真的很不错！点赞！ 在这个过程中，有如下体会： ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:0","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"撰写说申请书也是一门学问 撰写申请书也是一种学问，甚至有一种职业，就叫专利代理师。他们的工作大致就是帮发明人撰写专利申请。不要小看这项工作的技术难度，它要求专利代理师有非常广阔的知识面（能懂得很多技术），极强的语言表达能力（特别是写说明文的能力）。 “说明书”和“权利要求书”是整个申请文件的两个核心文件。其中说明书写得越详细越好，要把这项技术描述得“前无古人”，这样才能通过专利局的审核。 而权利要求书则要写得简练概括，因为如果把一项发明的特征写得太详细，日后通过权利要求书维权的时候就不容易成功。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:1","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"语文真的太重要了 语文真的太重要了，我现在深刻体会到语文真的太重要了。我现在也深刻体会到我的中学语文tm都学了啥几把玩意儿，就是为了考试去背东西，没读过几本书，也没写过什么好文章。 之前一直把语文学偏了，就觉得语文是文人墨客抒发情感，写文章越是让人看不懂越牛逼，净整些没用的玩意儿。其实并不是，学习语文，关键是提升阅读理解能力，语言表达能力。这两种能力，对一个人来说，前者是输入能力，后者是输出能力。马克思说过：“人是一切社会关系的总合”、“一个人只有在社会中才能实现其价值”。而在社会中生活，必定会和外界进行交流，产生输入输出。所以说，语文能力是相当重要的。 写专利说明书的过程中，每一句话都有其意义，每一个标点符号都有要求。比如，如果在下文中提到一个新概念，上文必须有对应的铺垫内容，否则会让人看不懂；权利要求书中每一点权利要求中间不能出现句号，因为一个句号的差别就可能使特征的表述产生歧义，给侵权人反驳的机会。这也是为什么会有人专门从事这样的职业，他们写专利申请考虑到未来可能出现的各种情况，虽然一次收费5k元，但是帮发明人维护了重要的权利。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:2","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["随笔杂记"],"content":"收获 收获还是蛮大的，了解了一个新的领域，提升了表达能力以及表达的严谨性。另外，使用word的技巧更熟练了。 又点亮一项技能，进一步降低了以后吃不上饭的可能性。 ","date":"2021-03-28","objectID":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/:0:3","tags":null,"title":"“专利申请”撰写有感","uri":"/posts/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E6%92%B0%E5%86%99%E6%9C%89%E6%84%9F/"},{"categories":["笔记"],"content":"任务拆分 一个html页面，左边是题目，右边是文本框，可以编写代码。右下角有一个“提交”按钮，点击之后将代码发送到后台进行评测。 现在已有基于jupyter notebook的评测多个题目的评测代码，需要把它拆分后放在django后台运行。 可能需要用到数据库，统一使用的是mysql ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:1","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"3月23日 正在看白月黑羽的django教程，从http协议开始讲的，讲的很全，边看边做任务。 http://www.python3.vip/tut/webdev/django/http/ ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:2","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"3月27日 学习内容： HTTP协议 明白了浏览器打开网页的大致过程，明白了请求的几种类型get，post等，请求的内容由哪些部分组成，还了解了服务器返回的状态码等 django安装与运行 django在整个web中的角色是application(应用)，如何创建django项目，django项目中包含哪些东西 url路由 路由是干什么的，如何在django项目中配置路由，当路由过多时，该如何配置 ORM的概念 django的数据库为什么可以方便更换，这与orm有关。因为orm，不懂数据库的语句也可以对数据库增删改查 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:3","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月5日 说实话，有些动力不足。学习之路漫长又曲折，但是无论走得有多慢，都要走下去。这几天学的东西如下： 定义数据库表 在models里像定义“类”一样定义数据库字段，这种设计挺巧妙的。 创建数据库表 修改settings，告诉django去创建数据库表 Django Admin管理数据 使用django内置的管理界面 读取数据库数据 编写函数，使得浏览器可以使用get请求获取数据库信息 过滤条件 在上一步的基础上实现了更高级的功能 前后端分离的架构 不使用模板的时候写函数要把数据混在html代码里，使用的“模板”就可以实现前后端分离。明白了“前端”、“后端”、“架构师”之间的关系。还明白了“API接口”到底是什么。 至此，我对web开发的原理越来越明了。但是不具备实操技能，现在让我写代码还是一行也写不出来。继续学习。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:4","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月11日 看到了“数据的增删改查5”的3'58''，“和前端集成”前面。 json是前端和后端沟通的桥梁 后端把从数据库里查到的东西重构成json格式，前端再将json解析成内容填充到网页里，确实很巧妙啊。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:5","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月17日 这周已经把基础知识学完了，开始着手写代码。但是这周有数学分析期中考试，还有很多杂七杂八的事情，时间都被冲散了，拿不出整体的时间，让我很头疼。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:6","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"4月22日 有头绪啦，有头绪啦！昨天我写出了第一个评测的代码（虽然非常非常简单） 今天遇到的第一个问题： 如何将在页面上写出来后的code，保留原格式传给后台运行？ 李昕老师提示我用富文本框，我打算去看一个bootstrap教程学习。地址如下：https://www.bilibili.com/video/BV1TU4y1p7zU 小姐姐声音很好听。 ","date":"2021-03-23","objectID":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/:0:7","tags":null,"title":"长期任务：做一个在线oj的评测","uri":"/posts/%E9%95%BF%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BFoj%E7%9A%84%E8%AF%84%E6%B5%8B/"},{"categories":["笔记"],"content":"老婆不在家，看点刺激的 ","date":"2021-03-16","objectID":"/posts/pathlib%E5%BA%93/:0:0","tags":null,"title":"pathlib库","uri":"/posts/pathlib%E5%BA%93/"},{"categories":["笔记"],"content":"安装虚拟环境 在Powershell中执行 Set-ExecutionPolicy Unrestricted #执行策略更改 y #yes pip freeze #输出所有在本地已安装的包 pip install virtualenv cd 目标文件夹 virtualenv . #在当前目录创建虚拟环境 .\\Scripts\\activate #切换虚拟环境 deactivate #取消虚拟环境 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"安装django pip install django ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"创建django项目 django-admin startproject 项目名(mysite) cd ./mysite code . #用vscode启动 python manage.py runserver #启动服务器 解决报错信息 python manage.py migrate #注意要在mysite目录下执行 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置路由urls 在虚拟环境中，且在mysite目录下 python manage.py startapp 名字(misterwu) 在mysite的settings.py里的INSTALLED_APPS里添加’misterwu’进行关联 在mysite的urls.py里添加import path,include，再添加一个urlpatterns 在misterwu里新建一个urls.py，把mysite里的urls拷贝到这里 删掉import admin和第二行末尾的path 删掉urlpatterns里的内容 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示html页面 在misterwu的urls.py的urlpatterns里添加 path('',views.home,name=\"home\") 还要在前面添加 from . import views 在misterwu的views.py里定义一个\"home\"方法 def home(request): return render(request,'home.html',{}) 在misterwu下创建一个新文件夹templates，在下面创建home.html，在里面写 \u003ch1\u003ehello world!\u003c/h1\u003e ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"创建公共html模板 打开www.bootcss.com，进入bootstrap4中文文档，初学者模板，拷贝一份 \u003c!doctype html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003c!-- 必须的 meta 标签 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\u003e \u003c!-- Bootstrap 的 CSS 文件 --\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css\" integrity=\"sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l\" crossorigin=\"anonymous\"\u003e \u003ctitle\u003eHello, world!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHello, world!\u003c/h1\u003e \u003c!-- JavaScript 文件是可选的。从以下两种建议中选择一个即可！ --\u003e \u003c!-- 选项 1：jQuery 和 Bootstrap 集成包（集成了 Popper） --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-LCPyFKQyML7mqtS+4XytolfqyqSlcbB3bvDuH9vX2sdQMxRonb/M3b9EmhCNNNrV\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003c!-- 选项 2：Popper 和 Bootstrap 的 JS 插件各自独立 --\u003e \u003c!-- \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js\" integrity=\"sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js\" integrity=\"sha384-gRC4eoaRyQ8xv2X6Mnf+eOIrtON3wId3dAkwO0HQX26OrFBoLpjX/XWOJacSiZhL\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e --\u003e \u003c/body\u003e \u003c/html\u003e 在misterwu下的templates里新建一个base.html，把初学者模板拷贝到这里 然后在home.html里添加代码，最终样子如下: {% extends 'base.html'%} {% block content %} \u003ch1\u003ehello world!\u003c/h1\u003e \u003cp\u003e测试是否可以看到我!\u003c/p\u003e {% endblock %} 然后在base.html的body里调用这个代码块(这种写法貌似是php里的) ... \u003cbody\u003e link1link2link3 {% block content %} {% endblock %} ... ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:6","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示导航信息 在base.html的导航那一部分替换成如下代码： \u003cbr\u003e \u003cdiv class=\"container\"\u003e {% block content %} {% endblock %} \u003c/div\u003e 从bootstap上找到导航条源码 \u003cnav class=\"navbar navbar-expand-lg navbar-light bg-light\"\u003e \u003ca class=\"navbar-brand\" href=\"#\"\u003eNavbar\u003c/a\u003e \u003cbutton class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"\u003e \u003cspan class=\"navbar-toggler-icon\"\u003e\u003c/span\u003e \u003c/button\u003e \u003cdiv class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"\u003e \u003cul class=\"navbar-nav mr-auto\"\u003e \u003cli class=\"nav-item active\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eHome \u003cspan class=\"sr-only\"\u003e(current)\u003c/span\u003e\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eLink\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item dropdown\"\u003e \u003ca class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e Dropdown \u003c/a\u003e \u003cdiv class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eAction\u003c/a\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eAnother action\u003c/a\u003e \u003cdiv class=\"dropdown-divider\"\u003e\u003c/div\u003e \u003ca class=\"dropdown-item\" href=\"#\"\u003eSomething else here\u003c/a\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link disabled\" href=\"#\" tabindex=\"-1\" aria-disabled=\"true\"\u003eDisabled\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003cform class=\"form-inline my-2 my-lg-0\"\u003e \u003cinput class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"\u003e \u003cbutton class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"\u003eSearch\u003c/button\u003e \u003c/form\u003e \u003c/div\u003e \u003c/nav\u003e 上述代码也粘贴到下面 效果图 把home所在的标签都删掉 dropdown，disabled标签也删掉 把Navbar改掉，如（米斯特务） search也可以改掉 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:7","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"接口介绍 pass ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:8","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"接口请求和解析 在misterwu的views.py的 def home(request)函数中加入以下代码： import requests import json api_request = requests.get(\"https://api.github.com/users?since=0\") api = json.loads(api_request.content) 注意，在虚拟环境里先装requests 然后在return render(request,‘home.html’,{})后面的空字典里添加： return render(request,'home.html',{\"api\":api}) 来到home.html，在{%block content%}…{%endblock%}内添加 \u003cp\u003e{{api}}\u003c/p\u003e 成功！ ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:9","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"展示数据信息 在misterwu的home.html的block里写入 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e {% for x in api %} \u003cdiv class=\"col-sm\"\u003e \u003cdiv class=\"card\" style=\"width: 18rem;\"\u003e \u003cimg src=\"{{x.avatar_url}}\" class=\"card-img-top\" alt=\"...\"\u003e \u003cdiv class=\"card-body\"\u003e \u003ch5 class=\"card-title\"\u003e{{x.login}}\u003c/h5\u003e \u003cp class=\"card-text\"\u003e{{x.login}}的github\u003c/p\u003e \u003ca href=\"{{x.html_url}}\" class=\"btn btn-primary\"\u003e点进他的博客主页\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr\u003e \u003c/div\u003e\u003e {% endfor %} \u003c/div\u003e \u003c/div\u003e 上面代码中div里的内容是bootstrap4复制来的，原文如下 \u003cdiv class=\"card\" style=\"width: 18rem;\"\u003e \u003cimg src=\"...\" class=\"card-img-top\" alt=\"...\"\u003e \u003cdiv class=\"card-body\"\u003e \u003ch5 class=\"card-title\"\u003eCard title\u003c/h5\u003e \u003cp class=\"card-text\"\u003eSome quick example text to build on the card title and make up the bulk of the card's content.\u003c/p\u003e \u003ca href=\"#\" class=\"btn btn-primary\"\u003eGo somewhere\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:10","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"搜索页面跳转 在misterwu的urls.py的urlpatterns里加入一行： path('user/',views.home,name=\"user\"), 在views.py里加入一个函数: def user(request): return render(request,'user.html',{}) 在templates里创建user.html，写入： {% extends 'base.html'%} {% block content %} \u003ch1\u003ehello user\u003c/h1\u003e {% endblock %} 成功 在base.html的\u003cform class=“form-inline my-2 my-lg-0” \u003e里，再加两个属性 method=\"POST\" action=\"{% url 'user' %}\" 并在下面加入 {% csrf_token %} 之后点搜索，就可以正常跳转了 在base.html的下的里面加一个属性name=“user” 再到views.py里面的函数user里增加语句: user = request.POST['user'] return render最后的字典里面写 {'user':user} 在user.html中改成 hello {{user}} ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:11","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取搜索数据 在base.html的\u003ca class=“navbar-brand” href=\"#\"\u003e米斯特务里添加属性 href = \"{% url 'home' %}\" 在\u003ca class=“nav-link” href=\"#\"\u003eLink里添加属性 href = \"{% url 'user' %}\" “link”改成\"查询\" 在views.py的user函数中修改如下： 妈的，不想记了 ","date":"2021-03-15","objectID":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:12","tags":null,"title":"Django学习笔记","uri":"/posts/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"map()和apply()和applymap()区别 map()是Series对象的一个函数，DataFrame中没有map()，map()的功能是将一个自定义函数作用于Series对象的每个元素。 apply()函数的功能是将一个自定义函数作用于DataFrame的行或者列 applymap()函数的功能是将自定义函数作用于DataFrame的所有元素 案例可以看这个：https://www.cnblogs.com/jason–/p/11427145.html 讲的非常清晰 能看出map,apply,apply还是蛮有用的，但是上手不太容易 ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"sort_values()和sort_index()区别 1、sort_index() sort_index()通俗点讲，就是根据index的值进行排序，如果是按行排序，可以认为是根据index的值排序，如果是按列排序，可以认为是根据columns的值进行排序。用法如下： ### 按索引排序，需要指定轴和方向，默认为列方向排序 unsorted_df.sort_index()#默认为index升序 unsorted_df.sort_index(ascending=False)#此时为index降序 unsorted_df.sort_index(axis=1,ascending=True,inplace=False,na_position='last') #此时为columns方向升序，inplace指明是否替代原df,na_position指明缺失值的位置（'last'，'first'） unsorted_df.sort_index().sort_index(axis=1,ascending=True,inplace=False,na_position='last') #index和colimns同时排序，可以直接粘在后面 sort_values()对dataframe按某一列的值进行排序，或者按某一行的值进行排序。具体的参数设置如下： # 参数 DataFrame.sort_values（by，axis = 0，ascending = True，inplace = False，kind =' quicksort '，na_position ='last' ） #参数说明 by: str或str的列表，如果axis=0或axis='index'，那么by='列名'；如果axis=1或axis='columns'，那么by='行名' axis: {0或'index';1或'columns'} 默认为0，即纵向排序，如果为1，则为横向排序 ascending: 布尔型，默认为True,即升序 inplace: 布尔型，是否用排序后的数据代替现有数据 kind: 排序算法， {'quicksort'，'mergesort'，'heapsort'}，默认'quicksort' na_position: {'first'，'last'}，默认'last' ,即将缺失值放在最后。 摘自https://blog.csdn.net/u011412768/article/details/107251808 ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"pd.read_csv()参数 df=pd.read_csv(filepath, header=None,encoding=\"gbk\", names=[\"A\",\"B\",\"C\",\"D\",\"E\"], skiprows=1, skipfooter=1, usecols=[\"A\",\"B\",\"C\"], index_col=0, engine=\"python\") ———————————————— 版权声明：本文为CSDN博主「此间的少年1128」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_44056331/article/details/89366105 filepath_or_buffer: 数据输入的路径：可以是文件路径、可以是URL，也可以是实现read方法的任意对象。这个参数，就是我们输入的第一个参数。 还可以是一个URL，如果访问该URL会返回一个文件的话，那么pandas的read_csv函数会自动将该文件进行读取。比如：我们用fastapi写一个服务，将刚才的文件返回。 sep: 读取csv文件时指定的分隔符，默认为逗号。注意：“csv文件的分隔符” 和 “我们读取csv文件时指定的分隔符” 一定要一致。 比如：上面的girl.csv，我们将其分隔符从逗号改成\"\\t\"，如果这个时候还是用默认的逗号分隔符，那么数据读取之后便混为一体。 delimiter: 分隔符的另一个名字，与 sep 功能相似。 header/names: 当names没被赋值时，header会变成0，即选取数据文件的第一行作为列名。 当 names 被赋值，header 没被赋值时，那么header会变成None。如果都赋值，就会实现两个参数的组合功能。 index_col: 我们在读取文件之后，生成的DataFrame的索引默认是0 1 2 3…，我们当然可以set_index，但是也可以在读取的时候就指定某个列为索引。 usecols: 如果列有很多，而我们不想要全部的列、而是只要指定的列就可以使用这个参数。 详细看这篇博文，写得非常好！！https://www.cnblogs.com/traditional/p/12514914.html ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"样式问题 困扰了我很久是pandas样式问题，在这篇博客里写的很详细！ https://www.gairuo.com/p/pandas-style-function ","date":"2021-03-09","objectID":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"Pandas学习笔记","uri":"/posts/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"视频地址：https://www.bilibili.com/video/BV1Jx411L7LU?p=13\u0026spm_id_from=pageDriver 仅用于学习 感谢莫烦up主 ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:0","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"图中图 import matplotlib.pyplot as plt fig = plt.figure() x = [1, 2, 3, 4, 5, 6, 7] y = [1, 3, 4, 2, 5, 8, 6] # below are all percentage left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 ax1 = fig.add_axes([left, bottom, width, height]) # main axes ax1.plot(x, y, 'r') #r表示red，红颜色 ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_title('title') ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25]) # inside axes ax2.plot(y, x, 'b') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_title('title inside 1') # different method to add axes这是与上面两种不同的增加axes的方法 #################################### plt.axes([0.6, 0.2, 0.25, 0.25]) plt.plot(y[::-1], x, 'g') plt.xlabel('x') plt.ylabel('y') plt.title('title inside 2') plt.show() ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:1","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"次坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.arange(0, 10, 0.1) y1 = 0.05 * x**2 y2 = -1 *y1 fig, ax1 = plt.subplots() ax2 = ax1.twinx() # mirror the ax1将ax1的坐标轴镜像对称过去 ax1.plot(x, y1, 'g-') ax2.plot(x, y2, 'b-') ax1.set_xlabel('X data') ax1.set_ylabel('Y1 data', color='g') ax2.set_ylabel('Y2 data', color='b') plt.show() ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:2","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["笔记"],"content":"Animation动画 import numpy as np from matplotlib import pyplot as plt from matplotlib import animation fig, ax = plt.subplots() x = np.arange(0, 2*np.pi, 0.01) line, = ax.plot(x, np.sin(x)) def animate(i): line.set_ydata(np.sin(x + i/10.0)) # update the data return line, # Init only required for blitting to give a clean slate. def init(): line.set_ydata(np.sin(x)) return line, # call the animator. blit=True means only re-draw the parts that have changed. # blit=True dose not work on Mac, set blit=False # interval= update frequency ani = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=False) # save the animation as an mp4. This requires ffmpeg or mencoder to be # installed. The extra_args ensure that the x264 codec is used, so that # the video can be embedded in html5. You may need to adjust this for # your system: for more information, see # http://matplotlib.sourceforge.net/api/animation_api.html # anim.save('basic_animation.mp4', fps=30, extra_args=['-vcodec', 'libx264']) plt.show() 我试过了，jupyter notebook根本动不了 又试了pycharm，也动不了 完结撒花，再次感谢莫烦老师 ","date":"2021-03-03","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/:0:3","tags":null,"title":"matplotlib学习笔记（四）图中图-次坐标轴-Animation动画","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E5%9B%BE%E4%B8%AD%E5%9B%BE-%E6%AC%A1%E5%9D%90%E6%A0%87%E8%BD%B4-animation%E5%8A%A8%E7%94%BB/"},{"categories":["随笔杂记"],"content":"可以进行的学习 matplotlib kaggle刷题pandas等 web前端（css,javascript） Python爬虫实战 继续看课本（这个可能是最无聊的） 现在就好迷，在寝室里不知道学啥。 这样吧，学学云顶之弈把 ","date":"2021-03-02","objectID":"/posts/%E5%BC%80%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%98%8E%E7%A1%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/:0:1","tags":null,"title":"开学第二天明确学习方向","uri":"/posts/%E5%BC%80%E5%AD%A6%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%98%8E%E7%A1%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/"},{"categories":["笔记"],"content":"视频地址：https://www.bilibili.com/video/BV1Jx411L7LU?p=13\u0026spm_id_from=pageDriver 仅用于学习 感谢莫烦up主 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:0","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"image图片 import matplotlib.pyplot as plt import numpy as np # image data a = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3) \"\"\" for the value of \"interpolation\", check this: http://matplotlib.org/examples/images_contours_and_fields/interpolation_methods.html 参数interpolation见下图 for the value of \"origin\"= ['upper', 'lower'], check this: http://matplotlib.org/examples/pylab_examples/image_origin.html 参数origin如果为'upper'图像就会反过来 \"\"\" plt.imshow(a, interpolation='nearest', cmap='bone', origin='lower') plt.colorbar(shrink=.92) #shrink压缩到百分之九十二 plt.xticks(()) plt.yticks(()) plt.show() interpolation参数有这些 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:1","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"3D数据 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D #添加3D坐标轴显示 fig = plt.figure() ax = Axes3D(fig) #在figure上加一个3D的Axes # X, Y value X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X ** 2 + Y ** 2) # height value 高度是Z轴 Z = np.sin(R) #创建3D图 ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow')) \"\"\" r代表row, c代表col， rstride和cstride都是控制跨度的参数，简单理解，就是控制这个3D图像的稠密程度 ============= ================================================ Argument Description ============= ================================================ *X*, *Y*, *Z* Data values as 2D arrays *rstride* Array row stride (step size), defaults to 10 *cstride* Array column stride (step size), defaults to 10 *color* Color of the surface patches *cmap* A colormap for the surface patches. *facecolors* Face colors for the individual patches *norm* An instance of Normalize to map values to colors *vmin* Minimum value to map *vmax* Maximum value to map *shade* Whether to shade the facecolors ============= ================================================ \"\"\" # I think this is different from plt12_contours #在3D图下面创建一个等高线图 ax.contourf(X, Y, Z, zdir='z', offset=-2, cmap=plt.get_cmap('rainbow')) \"\"\" zdir='z'表示这个等高线图是从z轴压下去的，offset表示把等高线图放到-2这个位置 ========== ================================================ Argument Description ========== ================================================ *X*, *Y*, Data values as numpy.arrays *Z* *zdir* The direction to use: x, y or z (default) *offset* If specified plot a projection of the filled contour on this position in plane normal to zdir ========== ================================================ \"\"\" ax.set_zlim(-2, 2) plt.show() ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:2","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"Subplot 多合一显示 import matplotlib.pyplot as plt # example 1: ############################### plt.figure(figsize=(6, 4)) # plt.subplot(n_rows, n_cols, plot_num) plt.subplot(2, 2, 1) #2行2列，共4张图，编辑第1张图 plt.plot([0, 1], [0, 1]) plt.subplot(222) #2行2列，共4张图，编辑第2张图，这里不写逗号也可以识别（惊了） plt.plot([0, 1], [0, 2]) plt.subplot(223) #2行2列，共4张图，编辑第3张图 plt.plot([0, 1], [0, 3]) plt.subplot(224) #2行2列，共4张图，编辑第4张图 plt.plot([0, 1], [0, 4]) plt.tight_layout() # example 2: ############################### plt.figure(figsize=(6, 4)) # plt.subplot(n_rows, n_cols, plot_num) plt.subplot(2, 1, 1) # figure splits into 2 rows, 1 col, plot to the 1st sub-fig plt.plot([0, 1], [0, 1]) plt.subplot(234) # figure splits into 2 rows, 3 col, plot to the 4th sub-fig plt.plot([0, 1], [0, 2]) plt.subplot(235) # figure splits into 2 rows, 3 col, plot to the 5th sub-fig plt.plot([0, 1], [0, 3]) plt.subplot(236) # figure splits into 2 rows, 3 col, plot to the 6th sub-fig plt.plot([0, 1], [0, 4]) plt.tight_layout() plt.show() figure1 figure2 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:3","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"Subplot分格显示 import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec # 方法一：method 1: subplot2grid ########################## plt.figure() ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) # 分3行3列的格子，从(0,0)开始，跨列=3,跨行colspan默认为1 ax1.plot([1, 2], [1, 2]) ax1.set_title('ax1_title') ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2) ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2) ax4 = plt.subplot2grid((3, 3), (2, 0)) ax4.scatter([1, 2], [2, 2]) ax4.set_xlabel('ax4_x') ax4.set_ylabel('ax4_y') ax5 = plt.subplot2grid((3, 3), (2, 1)) # 方法二：method 2: gridspec ######################### plt.figure() gs = gridspec.GridSpec(3, 3) # use index from 0 ax6 = plt.subplot(gs[0, :]) ax7 = plt.subplot(gs[1, :2]) ax8 = plt.subplot(gs[1:, 2]) ax9 = plt.subplot(gs[-1, 0]) ax10 = plt.subplot(gs[-1, -2]) # 方法三：method 3: easy to define structure #################################### f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True) #用ax11,ax12,ax13,ax14接收返回的第一行第一列图，第一行第二列图，第二行第一列图，第二行第二列图 ax11.scatter([1,2], [1,2]) plt.tight_layout() plt.show() method1和method2效果图 method2 ","date":"2021-02-26","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/:0:4","tags":null,"title":"matplotlib学习笔记（三）image图片-3D数据-Subplot 多合一显示-Subplot分格显示","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89image%E5%9B%BE%E7%89%87-3d%E6%95%B0%E6%8D%AE-subplot-%E5%A4%9A%E5%90%88%E4%B8%80%E6%98%BE%E7%A4%BA-subplot%E5%88%86%E6%A0%BC%E6%98%BE%E7%A4%BA/"},{"categories":["笔记"],"content":"内容均来源于：https://www.bilibili.com/video/BV1Jx411L7LU?p=9\u0026spm_id_from=pageDriver 仅供学习使用 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:0","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Legend图例 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() # set x limits plt.xlim((-1, 2)) plt.ylim((-2, 3)) # set new sticks new_sticks = np.linspace(-1, 2, 5) plt.xticks(new_sticks) # set tick labels plt.yticks([-2, -1.8, -1, 1.22, 3], [r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) l1, = plt.plot(x, y1, label='linear line') #这里前面加个“l1 = ”是接收返回对象，如果不用到下面的handles，就没必要接收这个对象了，直接写语句就可 l2, = plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line') plt.legend(loc='upper right') # plt.legend(handles=[l1, l2], labels=['up', 'down'], loc='best')这是在显示图例的时候没有使用本来的信息，而是又自己设置了一遍，把原来的覆盖了，估计这辈子都不会用到这么麻烦的把哈哈 # the \",\" is very important in here l1, = plt... and l2, = plt... for this step如果要用到handles,就必须把l1和l2后面加个逗号 \"\"\"legend( handles=(line1, line2, line3), labels=('label1', 'label2', 'label3'), 'upper right') The *loc* location codes are:: 'best' : 0, (currently not supported for figure legends) 'upper right' : 1, 'upper left' : 2, 'lower left' : 3, 'lower right' : 4, 'right' : 5, 'center left' : 6, 'center right' : 7, 'lower center' : 8, 'upper center' : 9, 'center' : 10,\"\"\" plt.show() 简单省事儿的写法 plt.plot(x, y1, label='linear line') plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line') plt.legend(loc='best')#自动选择好的位置显示图例，图例中每条线原本的label也会显示 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:1","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Annotation标注 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y = 2*x + 1 plt.figure(num=1, figsize=(8, 5),) plt.plot(x, y,) ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) x0 = 1 y0 = 2*x0 + 1 plt.plot([x0, x0,], [0, y0,], 'k--', linewidth=2.5) #画一条从(x0,y0)垂直到x轴的虚线 plt.scatter([x0, ], [y0, ], s=50, color='b') #在(x0,y0)上标记一个点 #下面的太几把麻烦了，不研究了 # method 1: ##################### plt.annotate(r'$2x+1=%s$' % y0, xy=(x0, y0), xycoords='data', xytext=(+30, -30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-\u003e', connectionstyle=\"arc3,rad=.2\")) # method 2: ######################## plt.text(-3.7, 3, r'$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$', fontdict={'size': 16, 'color': 'r'}) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:2","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"坐标轴刻度（tick能见度） import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y = 0.1*x plt.figure() plt.plot(x, y, linewidth=10, zorder=1) # set zorder for ordering the plot in plt 2.0.2 or higher plt.ylim(-2, 2) ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) # set zorder for ordering the plot in plt 2.0.2 or higher label.set_bbox(dict(facecolor='white', edgecolor='none', alpha=0.8, zorder=2)) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:3","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Scatter散点图 import matplotlib.pyplot as plt import numpy as np n = 1024 # data size X = np.random.normal(0, 1, n) #正态分布生成散点 Y = np.random.normal(0, 1, n) ##正态分布生成散点 T = np.arctan2(Y, X) # for color later on这个公式是表示颜色的，超纲 plt.scatter(X, Y, s=75, c=T, alpha=.5) #s是size,c是color,alpha是透明度 plt.xlim(-1.5, 1.5) plt.xticks(()) # ignore xticks 将ticks设置为空白 plt.ylim(-1.5, 1.5) plt.yticks(()) # ignore yticks plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:4","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Bar柱状图 import matplotlib.pyplot as plt import numpy as np n = 12 X = np.arange(n) Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) #uniform均匀分布 Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') #“+”号是向上的柱状图 plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') #“-”号是向下的柱状图 for x, y in zip(X, Y1): # ha: horizontal alignment 水平位置 # va: vertical alignment 垂直位置 plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='center', va='bottom') #默认宽度0.8，通过加0.4来偏移到中间（其实不太懂qwq），y+0.05是不让柱状图上显示的文本与柱状图靠的太近 #'%.2f'%y 是对于传进来的数值保留两位小数 for x, y in zip(X, Y2): # ha: horizontal alignment # va: vertical alignment plt.text(x + 0.4, -y - 0.05, '%.2f' % y, ha='center', va='top') plt.xlim(-.5, n) plt.xticks(()) plt.ylim(-1.25, 1.25) plt.yticks(()) plt.show() 演示中的柱状图有两条，实际中一般用的用一条就够了 ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:5","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"Contours等高线图 import matplotlib.pyplot as plt import numpy as np def f(x,y): # the height function 计算高度的函数，不需要太关心 return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2) n = 256 x = np.linspace(-3, 3, n) y = np.linspace(-3, 3, n) X,Y = np.meshgrid(x, y) # use plt.contourf to filling contours填充颜色 # X, Y and value for (X,Y) point plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.hot) #X,Y是横纵坐标，f(X,Y)是高度，8是稠密程度，alpha是透明度，显示“hot”类型的等高线图 # use plt.contour to add contour lines画等高线 C = plt.contour(X, Y, f(X, Y), 8, colors='black', linewidth=.5) # adding label 加入label plt.clabel(C, inline=True, fontsize=10) #画在contour对象C上面，画在线内，粗细为10 plt.xticks(()) plt.yticks(()) plt.show() ","date":"2021-02-25","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/:0:6","tags":null,"title":"matplotlib学习笔记（二）Legend图例-Annotation标注-tick能见度-Scatter散点图-Bar柱状图-Contours等高线图","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8Clegend%E5%9B%BE%E4%BE%8B-annotation%E6%A0%87%E6%B3%A8-tick%E8%83%BD%E8%A7%81%E5%BA%A6-scatter%E6%95%A3%E7%82%B9%E5%9B%BE-bar%E6%9F%B1%E7%8A%B6%E5%9B%BE-contours%E7%AD%89%E9%AB%98%E7%BA%BF%E5%9B%BE/"},{"categories":["笔记"],"content":"上一篇我们讲了怎么用 json格式保存数据，这一篇我们来看看如何用 csv模块进行数据读写。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"一、csv简介 CSV (Comma Separated Values)，即逗号分隔值（也称字符分隔值，因为分隔符可以不是逗号），是一种常用的文本格式，用来存储表格数据，包括数字或者字符。 csv的使用很广泛，很多程序都会涉及到 csv的使用，但是 csv却没有通用的标准，所以在处理csv格式时常常会碰到麻烦。 因此在使用 csv时一定要遵循某一个标准，这不是固定的，但每个人都应该有一套自己的标准，这样在使用 csv时才不会犯低级错误。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:1","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"二、csv库的使用 关于 csv库的使用，我们从写和读两个方面来讲。 csv库有四个主要的类 writer，DictWriter，reader，DictReader reader和 DictReader都接受一个可以逐行迭代的对象作为参数，一般是一个包含 csv格式数据的文件对象。 writer和 DictWriter则接受一个 csv文件对象，csv格式的数据将会写入到这个文件中。 他们都会返回一个对应的对象，我们通过这个对象来进行数据的读和写。 这四者中 reader和 writer对应，DictReader和 DictWriter对应，也就是说通过 writer类写的 csv文件只能通过 reader类来读取，DictReader同理。 1、csv将数据写入文件 #-*- coding: utf-8 -* import csv #通过 writer类写入数据 #待写入的数据 注意到两个列表的元素个数不一样 test_writer_data_1 = ['Tom', 'Cody', 'Zack'] test_writer_data_2 = ['Mike', 'Bill'] #创建并打开文件 with open('test_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #获得 writer对象 delimiter是分隔符 默认为 \",\" writer = csv.writer(csvfile, delimiter=' ') #调用 writer的 writerow方法将 test_writer_data写入 test_writer.csv文件 writer.writerow(test_writer_data_1) writer.writerow(test_writer_data_2) #通过 DictWriter类写入数据 #待写入的数据 注意到待写入的数据类型为 dict 且第二个字典没有 lastname test_dict_writer_data_1 = {'firstname': 'Tom', 'lastname': 'Loya'} test_dict_writer_data_2 = {'firstname': 'Tom', 'lastname': 'Loya'} #创建并打开文件 with open('test_dict_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #设置表头 fieldnames=['firstname', 'lastname'] # 获得 DictWriter对象 delimiter是分隔符 默认为 \",\" 表头为 'firstname' 'lastname' dict_writer = csv.DictWriter(csvfile, delimiter=' ', fieldnames=fieldnames) #第一次写入数据先写入表头 dict_writer.writeheader() #调用 DictWriter的 writerow方法将 test_dict_writer_data写入 test_dict_writer.csv文件 dict_writer.writerow(test_dict_writer_data_1) dict_writer.writerow(test_dict_writer_data_2) 前面讲到，csv没有统一的标准，通过上面的例子我们可以发现，csv对写入的数据不做任何检查，也就是说几乎没有任何标准可言。 我们发现 writerow方法不会对数据进行检查，即使前后两句 writerow语句写入的数据的格式不同也不会报错。 所以在用 csv写入数据时要特别注意数据的格式问题！！！ 也可以用 writerows(list) 一次写入多行，例如： with open('test_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #获得 writer对象 delimiter是分隔符 默认为 \",\" writer = csv.writer(csvfile, delimiter=' ') #调用 writer的 writerows方法将 test_writer_data写入 test_writer.csv文件 writer.writerows([test_writer_data_1, test_writer_data_2]) with open('test_dict_writer.csv', 'w', newline='', encoding='utf-8') as csvfile: #设置表头 fieldnames=['firstname', 'lastname'] # 获得 DictWriter对象 delimiter是分隔符 默认为 \",\" 表头为 'firstname' 'lastname' dict_writer = csv.DictWriter(csvfile, delimiter=' ', fieldnames=fieldnames) #第一次写入数据先写入表头 dict_writer.writeheader() #调用 DictWriter的 writerows方法将 test_dict_writer_data写入 test_dict_writer.csv文件 dict_writer.writerows([test_dict_writer_data_1, test_dict_writer_data_2]) 2、csv从文件读取数据 #-*- coding: utf-8 -* import csv #通过 reader读取文件内容 注意到之前我们设置了 delimiter为空格，这里也要继续设置为空格 with open('test_writer.csv', 'r', newline='', encoding='utf-8') as csvfile: reader = csv.reader(csvfile, delimiter=' ') for row in reader: print(row) with open('test_dict_writer.csv', 'r', newline='', encoding='utf-8') as csvfile: dict_reader = csv.DictReader(csvfile, delimiter=' ') for row in dict_reader: print(row) 打印结果： 观察打印出的结果我们发现，reader读取的内容打印出来后还是列表格式，而 DictReader读取的内容却变为了列表加元组的格式，显然和我们刚开时传入的字典格式很不同。 而我们总是希望输入和输出能够一致，但是 csv模块并没有提供这样的方法，所以我们需要自己将 csv模块再进行一次封装，封装后的包应该满足下面的标准： 统一的分隔符 delimiter 统一的编码 统一的打开文件的方式 能够自己判断文件是否存在并且选择合适的方式打开文件 输入格式和输出格式保持一致 强制检查格式，格式错误禁止插入并报错 封装后的包的源码会在完成后贴出(￣▽￣)\" 最后让我们来总结一下使用 csv库的注意事项： 打开文件时要 注意模式 读用 r，写用 w 打开文件时要设置 newline=''（空字符） 打开文件时要指定编码打开，写入时也一样 如果设置过分隔符就要一直保持，读写时的分隔符必须一致 csv不会检查格式（虽然有个 strict模式，但 strict模式下也不会对格式进行检查），写入文件时一定要注意格式 以上就是 csv库的使用方法和注意事项，觉得不错就点个赞吧(●ˇ∀ˇ●) 作者：渔父歌 链接：https://www.jianshu.com/p/51211fcdf4b8%20 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 ","date":"2021-02-25","objectID":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:2","tags":null,"title":"csv库的使用方法","uri":"/posts/csv%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["笔记"],"content":"转载自https://www.jianshu.com/p/0ba2b643c0f2 在上一篇文章里我们讲了 xpath写法的问题还以爬取我的文章信息写了示例，但是在上一篇中我们只是爬取并打印了信息，并没有对信息进行保存。 实际应用中爬取到的信息肯定是需要保存到本地的。保存信息的方式有数据库和文件的形式，数据库我们后面再讲，现在让我们先看看怎么把信息保存到文件里。 这里我们主要讲讲 将数据保存为 json格式和 csv格式，这就要用到两个库 json库和 csv库，这两个库都是 python自带的库。 关于数据存储我们分两篇来讲，这一篇先讲 json，下一篇再讲 csv。 ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:0","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"一、关于 json json的简介直接引用百度百科的定义： JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 实际上 json的格式和 python中的字典很像，也是由键值对组成，但是 python中的值可以为任何对象（列表、字典、字符串、数字等等），而 json中的值只能是数组（列表）、字典、字符串、数组、布尔值中的一中或几种。 其格式就像下面这样： 注意：json中的引号必须是双引号，否则会报错 { \"key1\": \"value1\", \"key2\": [1,2,\"value2\"], \"key3\": { \"key31\": \"value1\", \"key32\": [1,2,\"value2\"], \"key33\": true, }, } ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:1","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"二、json库的使用 json库一共有三个方法，分别是 dump、dumps、load、loads。 其中 dump和 dumps是用来把把字典和数组转换为 json格式的，dump把转换结果直接写入文件，dumps返回字符串。 load和 loads是把 json格式的数据转换为字典格式，load直接从 json文件中读取数据并返回字典对象，loads把字符串形式的 json数据转换成字典格式。 下面讲讲这些方法的具体用法。 1、dump和 dumps dump的函数原型是 dump(obj, fp) 第一个参数 obj是要转换的对象，第二个参数 fp是要写入数据的文件对象。 dumps的函数原型是 dumps(obj) 参数是要转换的对象 注意：如果要转换的对象里有中文字符的话，要把 ensure_ascii设置为 False否则中文会被编码为 ascii格式 #-*- coding: utf-8 -* import json test = { \"key1\": \"value1\", \"key2\": [1,2,\"value2\"], \"key3\": { \"key31\": \"value1\", \"key32\": [1,2,\"value2\"], \"key33\": True, \"key34\": \"测试\", }, } #没有设置 ensure_ascii为 False with open('test.json', 'w', encoding='utf-8') as fp: json.dump(test, fp) #设置了 ensure_ascii为 False with open('test_no_ascii.json', 'w', encoding='utf-8') as fp: json.dump(test, fp, ensure_ascii=False) #test.json的文件内容为： #{... ... \"key33\": true, \"key34\": \"\\u6d4b\\u8bd5\"}} #test_no_ascii.json的文件内容为： #{... ... \"key33\": true, \"key34\": \"测试\"}} #注意到 python中的 True转换成了 Javascript里的 true #另外在打开文件的时候强烈建议用 encoding指定文件编码 #还需要注意文件的打开模式 w是写入，文件已存在的话就覆盖 #要追加写入的话记得用 a模式打开 test_string = json.dumps(test, ensure_ascii=False) print(test_string) 打印结果： 2、load和 loads load的函数原型是 load(fp) 参数 fp是要读取的文件对象 loads的函数原型是 loads(string) 参数 string是要转换成 python对象的 json字符串，通常用来将网页中的 json数据转换为 python对象 #-*- coding: utf-8 -* import json #json格式的字符串 test_string = '{\"key1\": \"value1\", \"key2\": [1, 2, \"value2\"], \"key3\": {\"key31\": \"value1\", \"key32\": [1, 2, \"value2\"], \"key33\": true, \"key34\": \"测试\"}}' #从之前保存的 test_no_ascii.json中读取 注意模式为 r with open('test_no_ascii.json', 'r', encoding='utf-8') as fp: json_obj_from_file = json.load(fp) json_obj_from_web = json.loads(test_string) #打印两个返回结果的类型 print(type(json_obj_from_file)) print(type(json_obj_from_web)) #打印两个返回结果的内容 print(json_obj_from_file) print(json_obj_from_web) 打印结果 json的dump和dumps的区别 dumps是将dict转化成str格式，loads是将str转化成dict格式。 dump和load也是类似的功能，只是与文件操作结合起来了。 ","date":"2021-02-25","objectID":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:2","tags":null,"title":"json数据存储","uri":"/posts/json%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["笔记"],"content":"学习视频地址：https://www.bilibili.com/video/BV1Jx411L7LU? github地址：https://github.com/MorvanZhou/tutorials/tree/master/matplotlibTUT ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:0","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"基本语法 ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:1","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"一个figure就是一张图片 这里有两个figure(两张图)，其中第二个figure有两个plot(两条线) ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:2","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["笔记"],"content":"设置坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y2) # plot the second curve in this figure with certain parameters plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') # set x limits plt.xlim((-1, 2)) #限制x坐标轴范围 plt.ylim((-2, 3)) #限制y坐标轴范围 plt.xlabel('I am x') #x轴的名字 plt.ylabel('I am y') #y轴的名字 # set new sticks new_ticks = np.linspace(-1, 2, 5) #np数组 print(new_ticks) plt.xticks(new_ticks) #设置新ticks # set tick labels设置tick的标签，这些是一一对应的，反斜杠加空格是空格的转义字符，加$符号变成好看的斜体 plt.yticks([-2, -1.8, -1, 1.22, 3], [r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) plt.show() 移动坐标轴 import matplotlib.pyplot as plt import numpy as np x = np.linspace(-3, 3, 50) y1 = 2*x + 1 y2 = x**2 plt.figure() plt.plot(x, y2) # plot the second curve in this figure with certain parameters plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--') # set x limits plt.xlim((-1, 2)) plt.ylim((-2, 3)) # set new ticks new_ticks = np.linspace(-1, 2, 5) plt.xticks(new_ticks) # set tick labels plt.yticks([-2, -1.8, -1, 1.22, 3], ['$really\\ bad$', '$bad$', '$normal$', '$good$', '$really\\ good$']) # to use '$ $' for math text and nice looking, e.g. '$\\pi$' # gca = 'get current axis'，获取当前正在编辑的这张图的坐标轴 ax = plt.gca() ax.spines['right'].set_color('none') #把右边和上边的边框线的颜色设置成“无”,\"spines\"翻译成“脊梁”？？？ ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') #用“下面”的轴的ticks代替“x坐标轴”的ticks,有如下参数可选（其实不太明白qwq） # ACCEPTS: [ 'top' 'bottom' 'both' 'default' 'none' ] ax.spines['bottom'].set_position(('data', 0)) #设置下面“脊梁”的位置（即x轴的位置），以“data”的方式，设置在y轴的0刻度上 # the 1st is in 'outward' 'axes' 'data' 还可以用其它方式确定这个位置，比如outer，axes这些 # axes: percentage of y axis # data: depend on y data ax.yaxis.set_ticks_position('left') #用“左边”的轴的ticks代替“y坐标轴”的ticks,有如下参数可选 # ACCEPTS: [ 'left' 'right' 'both' 'default' 'none' ] ax.spines['left'].set_position(('data',0)) #把y轴位置设置在x轴的0刻度上 plt.show() ","date":"2021-02-23","objectID":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/:0:3","tags":null,"title":"matplotlib学习笔记（一）基本语法,figure,坐标轴","uri":"/posts/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95figure%E5%9D%90%E6%A0%87%E8%BD%B4/"},{"categories":["书影记录"],"content":"《喜剧之王》是一部周星驰导演的经典电影，但我仅仅有所耳闻，并没有看过全片。去年春节时，周星驰导演的《新喜剧之王》上映，当时我在准备高考，所以没有任何关注，也不知道这部电影被网友称为烂片。直到今天，我在b站找电影看时偶然发现了这部电影，就凭这部电影是周星驰导演，我果断觉得点进去看看。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 主要讲的就是一个叫如梦的年轻女演员，性格十分单纯。她是个十足的倒霉蛋，做演员十多年任然只是一个跑龙套的，男朋友是个骗子，闺蜜成为明星之后也抛弃了她。但是也偶尔有她自己的幸运，比如父母很爱她，有一个富二代喜欢上了她。尽管生活那么艰辛，她还是像打不死的小强，一直在努力奋斗。最后成功当上最佳女主角的励志故事。 题材就是这么一个丑小鸭变白天鹅的经典题材，顺便再歌颂一下父爱母爱，经典题材不免有一些老套，但是老套不一定是缺点。比如说，任天堂出的《塞尔达传说旷野之息》这款游戏，它的剧情可以用“勇者斗恶龙救公主” 八个字概括，但是这并不影响它成为神作，它的剧情一样可以让人感动到落泪。而我在看这部《新喜剧之王》时，也多次感动得热泪盈眶。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"特点 这部《新喜剧之王》，和《喜剧之王》一样都有极端的人设，画面具有强烈的表现力，这一点很符合我的胃口。很多人说这种电影太不真实了，拍得没意义。我强烈反对，艺术来自于生活，但艺术高于生活。电影，小说等这些艺术形式，就应该是从真实生活中抽象出来的。 电影很短。两个半小时的时间里，它要讲述那么长的故事，还要让你印象深刻，引起你的思考，让你落泪，如果过于追求真实，剧情就像白开水一样平淡无味，那还看个卵的电影，去看纪录片不香么。 继续说特点，挺搞笑的，还有…我想想啊….好像就没啥特点了….和《美人鱼》，《喜剧之王》相比，总感觉少了点那味儿，感觉都不像是周星驰导的电影了。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"败笔 上面提到的，就是这部电影的败笔—-没那味儿了。 电影讲的不是粤语，镜头太干净，思路太清晰，还有好多互联网广告（58同城，荣耀手机）…看到广告的时候真是太出戏啦！！ 这部电影很多桥段都是十分动人的，单独拿出来看绝对堪称经典片段，但是，一块老鼠屎坏了一锅好汤，电影中的那些商业元素就是老鼠屎。 再扯一扯我们所处的时代，现在是短视频时代，大家都在变得浮躁，在这种浮躁的心态下，经典，往往是不能被欣赏的。打个比方，《2001太空漫游》这部电影如果把名字改成《2077太空漫游》在2021年上映，绝对会被骂惨。因为这部电影没啥剧情，镜头单调，节奏巨慢，不符合2021年观众的胃口。2021年观众比较喜欢《流浪地球》这种类型，看着爽就完事儿了。谁闲着没事儿去研究镜头背后蕴含的深刻含义呢？这可能就是这部《新喜剧之王》被大家骂的这么惨的时代原因吧。 总体来说，这部《新喜剧之王》，其实我觉得还是很不错的，星爷的电影我都很喜欢。 ","date":"2021-02-15","objectID":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《新喜剧之王》观后感","uri":"/posts/%E6%96%B0%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"发现宝藏视频和宝藏up主，讲的内容正是我的疑惑点。 https://www.bilibili.com/video/BV1Pg4y1z7Lr?from=search\u0026seid=13958657789515093044 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"导入 from bs4 import BeautifulSoup #导入模块 soup = BeautifulSoup(text,‘lxml’) #实例化BeautifulSoup对象 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取所有的div标签 divs = soup.find_all(‘div’) print(divs) divs不是列表，是bs4的ResultSet，输出结果是一个列表形式，每个div作为列表中的一个元素 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取指定的div标签 div = soup.find_all(‘div’)[1] print(div) #输出第二个数据，还可以切片，不举例了 div = list(soup.find_all(‘div’)) 把结果转换成列表，还是很方便的 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取拥有指定属性的标签(id=even的div标签) 方法一： divs = soup.find_all(‘div’,id=‘even’) 如果指定属性是class，会与Python关键字冲突，改为class_ 方法二： divs = soup.find_all(‘div’,attrs={“id”:“even”,“class”:“L square”}) #以字典的形式找到多个指定属性的div标签 ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取标签的属性值 alist = soup.find_all(‘a’) 方法一：通过下标方式提取 for a in alist: href = a[‘href’] print(href) 方法二：利用attrs方法提取 for a in alist: href = a.attrs[‘href’] print(href) ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"输出文字 使用string方法 print(div.string) ","date":"2021-02-14","objectID":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:6","tags":null,"title":"BeautifulSoup学习笔记","uri":"/posts/beautifulsoup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["书影记录"],"content":"14年的电影，男主是莱昂纳多·迪卡普里奥。晚上12:05分看完这部三个小时的电影，到凌晨4点我都没有睡着觉。 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"剧情 主要讲的就是一个年轻人去华尔街当股票经理，结果倒霉的是，上班第一天就遇到金融危机。幸运的是，还遇到了人生导师，教他吸大麻打飞机。 公司破产后，他也学会了搞传销（果然在大公司里就是能学到东西），然后就带着一群人搞传销卖股票，还创建了一个公司。最先跟他干的那个人，看他这么能赚钱，于是主动找他聊天，跟他聊了一会就立刻决定把本职工作辞掉，很有魄力，最后成了二老板。 最后他们被FBI逮到，坐牢去了，干了这么多坏事，也就坐2年牢。 电影重点不是讲述这个搞传销的年轻人是怎么奋斗的，也不是讲这帮人最后怎么被绳之以法的，而是花了大量的篇幅讲男主（下面简称为“搞传销的”）是怎么挥霍这些钱财的。 “搞传销的”住豪宅，买豪车，，喝香槟，嫖名娼…这些东西即使是像我们这样穷人，也在想象力范围之内。 出乎你想象力的是，“搞传销的”把办公室开成了妓院！职员天天上班的时候一边捞钱，一边“释放压力”。男厕所的镜子前中出，摩天大楼的透明电梯里口X… “搞传销的”染上毒瘾，毒品藏在家里到处都是，他也随身携带着大麻，瘾上来了就吸一口。他还有性癖，嫖娼的时候不喜欢戴套，举办舞会的时候认识一个很漂亮的有夫之妇，就跟到她家把她给上了。这件事被老婆发现之后，果断选择跟老婆离婚，这才是真男人（误 电影的尺度非常非常大，单从情涩这个角度看，堪比AV，比AV还牛逼的是这部电影里的女优是三点全露不打码，而且个个都是影星级别的辣妹。 来源：ASC杂志（此文是官方授权翻译，如需转载，请标明来源影视工业网，十分感谢） 作者：Michael Goldman 翻译：吴晓晖 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:1","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"风格 电影是表现力极强，非常非常浮夸。男主莱昂纳多·迪卡普里奥还在前一年演过一部《了不起的盖茨比》，这两部电影都是看了之后让人印象非常深刻的。 我们在看电影的时候，会不由自主把自己代入到电影中，与主角感同身受，看这部电影的时候，我脑子里一直就是这个感觉“有钱太TM爽啦！” ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:2","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["书影记录"],"content":"思考 虽然看完之后我非常震惊，但我脑子里就一个“爽”字，没有任何思考的空间了。随便想了想，有以下几点： 上个世纪8,90年代，大量的精英来到华尔街，剥削“穷人”，大发股票横财，挥霍金钱。但是“穷人”们的生活其实也不差，至少比发展中国家好多了，所以美国那时候是真正的黄金时代，暴富的人肆意挥霍，没暴富的人做暴富的美梦，进入21世纪后才发现全都是泡沫，是一刹的花火。 我真的想不明白这电影是怎么拍出来的，怎么在美国放映的，尺度如此之大，涉及了毒品，性，还有敏感的政治问题。2004年那时候肯定是引起了轩然大波，那时候我才2岁，真想穿越回去调查一下。 最后，十分推荐这部电影，看完之后会对自己当前的生活有新的思考。 ","date":"2021-02-11","objectID":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/:0:3","tags":null,"title":"《华尔街之狼》观后感","uri":"/posts/%E5%8D%8E%E5%B0%94%E8%A1%97%E4%B9%8B%E7%8B%BC%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["笔记"],"content":"感慨 网上的教程好多好乱，我照着其中的一个做，差点把我网站给干没了。以后搞东西之前，一定要备份！！！！ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:1","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"思路 大致就是，先在腾讯云申请了一个免费的证书，然后下载是一个压缩文件，有用的是里面的Apache的配置文件（因为我的wordpress是跑在Apache上的） 然后在宝塔面板里安装，手动安装太麻烦，宝塔面板安装还是挺方便的，点赞。 最后进到wordpress里设置里，改下链接的形式，把http改成https，安装一个插件really simple ssl，把其它还没改过来的都自动改掉。 另外，细节还是蛮多的，比如说要设置各种安全组，各种尝试之后这就是不懂原理就进行操作的坏处，最后目的虽然实现了，但是现在被我搞得有点乱。反正我是不想再尝试第二遍了。 ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:2","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"走过的弯路 一定要提前备份！！！幸好宝塔，wordpress这两个软件 用的人挺多，网上教程也多，我参考了好多教程，才没有陷入僵局。 宝塔自己也提供一种免费的ssl证书，但是这个证书现在chrome,edge浏览器都是不认账的，网页根本进不去！这一步卡了我好久，我不知道问题出在哪了，还以为是自己配置过程出了差错，为此我还反复修改数据库，被迫学会了进入phpmyadmin，服了。 在安装了不安全的证书情况下，chrome，edge浏览器都进不去，但是手机上的via可以进，是否意味着via不够安全？ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:3","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["笔记"],"content":"感想 其实我经常像这样去折腾一些东西，往往“折腾”的过程都非常不顺利。但是基本上我最后都能成功，而且每次折腾完都有不少收获。 一开始，我就想折腾一个博客，能写点东西就行。后来，我觉得博客太丑了，就折腾博客的主题。再后来，觉得我应该折腾个域名。再再后来，我又折腾了https。。。 探索无止境，每次折腾都是勇敢迈向未知，路漫漫其修远兮，吾将上下而求索！ ","date":"2021-02-09","objectID":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/:0:4","tags":null,"title":"搞了一晚上http升级为https","uri":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E6%99%9A%E4%B8%8Ahttp%E5%8D%87%E7%BA%A7%E4%B8%BAhttps/"},{"categories":["随笔杂记"],"content":"时间？ 我是从去年暑假开始学吉他的，到目前为止也就刚好半年吧。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"学的好不好？ 学的还是挺不错的，也就半年的时间，上了不超过20节课（每节一个小时）我现在已经能弹很多很多流行歌曲了。每隔一段时间我都能找到一首我特别想弹唱的歌，“把我喜欢的歌弹出来” 这就是我学吉他的最大动力。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"除了会弹吉他，还有哪些收获？ 有机会能到琴行做做客，那里的氛围我很喜欢，那里的人甚至比学校里的同学还好相处。 遇见了两个吉他老师，除了教我弹吉他，还对我进行艺术熏陶。我与他们交流的过程中，学到很多音乐的知识，确实感受到了音乐的魅力。打个比方，你没打王者荣耀之前，看别人玩王者荣耀就跟个弱智似的，但是有一天你朋友拉你入坑，你就掉坑里出不去了。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"总结 吉他是一门下限比较低，上限比较高的一门乐器。对于我来说，学习吉他是一件性价比很高的事情，弹吉他不仅可以打发时间，而且特别装逼。尤其是当你跟你朋友相处了很久之后，他/她突然发现你竟然点亮了吉他这个技能点，那么你在他/她心中的地位会提高的。 ","date":"2021-02-09","objectID":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"学吉他总结","uri":"/posts/%E5%AD%A6%E5%90%89%E4%BB%96%E6%80%BB%E7%BB%93/"},{"categories":["刷题"],"content":"https://www.bilibili.com/video/BV1A4411v7b2?p=34\u0026spm_id_from=pageDriver 这个课讲得真是太好了，很少能有把复杂抽象的知识讲得这么清楚的老师 打算一口气把这个看完 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:0","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["刷题"],"content":"2月3日 现在看到62集了，看到这个人的笔记记得还不错，以后如果知识点忘了可以作为参考 https://blog.csdn.net/qq_41872653/article/details/109256914 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:1","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["刷题"],"content":"2月4日 看到74集，不想再看了，因为到此为止，课本已经上的内容已经都能很好理解了，再深入学习，就凭个人兴趣了。而且，看了知乎上的回答，学习数据分析没必要深入学习面向对象，毕竟我们在进行数据分析的时候更多地是在调用别人写的包，而不是自己写包，数据分析遇到的问题都是临时性的，不至于写包。 最主要的原因，是越往后看，我越觉得老师讲的内容越生僻，学习的性价比不高。再加上李昕老师强调了任务，这个寒假要学到第九章！我发现我还有很多其他的东西需要学习。比如pandas 接下来的目标：每天玩一玩爬虫，肝一肝pandas视频 ","date":"2021-02-02","objectID":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/:0:2","tags":null,"title":"python面向对象课程","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B/"},{"categories":["随笔杂记"],"content":"1月30日更新 增加了竹子mod 参考资料http://www.minecraftxz.com/bamboo/ 豆腐工坊mod 参考资料https://www.mcmod.cn/class/386.html 增加了小地图，进客户端就能看到 魔法金属 是一个大量级的Mod 可以观看籽岷的视频学习https://www.bilibili.com/video/BV1Qf4y1k73t 还增加了光影，在设置里可以调哦~ 另外请注意：服务器有死亡掉落哦，小心死了之后物品都没啦，最好组队一起玩，队友可以互救。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:0:1","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"进服教程 首先点开这个链接，下载由我整合的客户端~为了使下载速度更快，我没有使用垃圾百度网盘，而是用了阿里云，打开就能下载。 https://githubdownload.oss-cn-qingdao.aliyuncs.com/%E9%AD%94%E6%B3%95%E9%87%91%E5%B1%9E%E8%B1%86%E8%85%90%E5%B7%A5%E5%9D%8A1.7.10.zip 下载完成后，是一个压缩包，需要解压。电脑里没有解压软件的同学，可以下载好压软件，或者360zip 解压后的样子 解压完成后，打开文件夹里的这个启动器： 进去之后把用户名填了 （你他娘的可别填leyou1，那是我的账号。） 点击确定之后，就可以启动游戏啦 之后点多人游戏 就可以进服玩啦 服务器现有的Mod是魔法金属，可以在网上搜一搜教程，或者在b站看看视频。 无论你是建筑党，生存党，红石党，都欢迎你来建设服务器。 另外 服务器里没有装登陆插件，所以不需要密码，请勿泄露服务器的ip地址！ ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:1:0","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"开服信息公示 1.一开始是打算使用逸飞购买的阿里云轻量化应用服务器，29元三个月，平均每月9元，但是那个内存太小，没法开mod服，所以放弃。 后来图个方便，直接购买了淘宝的面板服，30元一个月。问淘宝客服要了mod文件，客服果然还是牛逼，照着他的方法弄就弄成了。 2.服务器的性质就是基友联机生存，非商业，不接受赞助。 3.如果你想增加mod，可以找我，现在加mod很方便。 4.QQ群： ","date":"2021-01-30","objectID":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/:2:0","tags":null,"title":"叮~我们的MC服务器终于到货啦！","uri":"/posts/%E5%8F%AE~%E6%88%91%E4%BB%AC%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%88%E4%BA%8E%E5%88%B0%E8%B4%A7%E5%95%A6/"},{"categories":["随笔杂记"],"content":"寒假过得很快活，人只要一快活，就不想回顾昨天，只想着期待明天。我太快活了，所以我20多天没有写东西。现在是凌晨1:30，我有点感到孤寂，悲凉之情顿生，遂开电脑作文抒情。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"1.读书 最近在读《围城》这本书， 里面的人想出来，外面的人想进去 这本书是很有意思的一本书，很真实，真的很真实，主题是两性关系，这种题材的文学作品少之又少，强烈建议阅读。 放假前带回来一本图书馆借的书和一本课本，意料之中果然都没什么翻开过，幸亏当时没犯傻，把下学期的书都带回来，怎么带回来的，就怎么原封不动的带回去。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"2.学技术 放假了一直在学自己感兴趣的东西，像什么爬虫啦，html，github，学得也比较乱，还弄了个疫情防控通自动打卡的程序，感觉非常不错。我自己在家真是一点都不无聊。直到李老师突然让我帮他做自动测评脚本，我还当个组长，我是真觉得心有余而力不足了，一方面知识匮乏，另一方面领导者不好当。到后期是力不足，心也无余了，我才大一，我好累 ，就是这种感觉qwq ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"3.打游戏 我是有志向的人，立志要读万卷书，行万里路，打万部游戏。刚放假弄了个赛博朋克，电脑带不动，机缘巧合又弄了个生化危机3重置版，感受到了这种过去解密题材的游戏的魅力，作为lsp，我还打了不可描述的补丁，拍成视频发出去炫耀。现在打的更多的是塞尔达传说旷野之息，神作不解释，从此我的脑海中只信仰这一款游戏。MC我又双又又在弄服务器了，毕竟上大学了，同学们买电脑的多了，要求联机玩MC，明天争取把Mod服开起来。 ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"4.弹吉他 其它的，以后再说把，困了… ","date":"2021-01-30","objectID":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"放寒假20天总结","uri":"/posts/%E6%94%BE%E5%AF%92%E5%81%8720%E5%A4%A9%E6%80%BB%E7%BB%93/"},{"categories":["随笔杂记"],"content":"几天前李昕老师在群里问有没有想帮他干点活的，我们九个人就都忙着报名参加了。其中四个是外专业的，两个智科，三个本研的。有如下感想： ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:0:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"1.对Python的好感度大大提高 Python的成功再次印证了那句话：“最简单的就是最牛逼的”（我自己说的），C++，java这样的高级语言已经够简单了，但是Python比它们还简单！面向对象真是非常巧妙的设计！ Python的简单并不使它功能缺失，反而使它功能更加强大。你可以用它写脚本，写网页，数据分析，甚至做人工智能。丰富的第三方扩展库，极大缩减了编程过程造轮子的时间，简洁的语法，使它无比适合做数据分析。 我现在已经不是处于认识Python的阶段了，而是要更深刻地去学习Python，进入到实战中，感受它的魅力。如果不是这次帮李昕老师干活，看李昕老师修改我们的代码（其实代码主要都是李昕老师写的），我肯定想不到原来Python还可以这样玩！c++学了一个学期，到头来只会刷题，期末考试就做出来6道，很不爽。学了Python没多久，就能入门爬虫和数据分析了，真的挺好玩的。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:1:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"2.体会到了数据结构的重要性 之前看李昕老师的视频，听他讲json啊，列表啊，字典啊，元组什么的真是好乏味，觉得这东西很虚，没什么意思。现在实战了几天，我彻底改变了这种看法，也对数据结构的重要性有了更深的理解。数据结构就像是不同类型的交通工具，列表啊，字典啊，元组啥的就相当于飞机，高铁，大巴车，你编写一个程序实现它的功能，就相当于是选择合适的交通工具去往你的目的地的过程。比如说过年回家，你出了学校门要打出租车，到了火车站坐上高铁，下了高铁坐上家里的小轿车，到家门口了，出去买点东西再回来要骑共享单车。你写一个程序也是这样，先从json文件里，转换成字典，再提取有用信息，转换成列表方便修改，最后还要转换成字符串输出。这些东西的转换非常频繁，如果熟练掌握，就不会让操作羁绊大脑的天马行空。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:2:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["随笔杂记"],"content":"3.做事情不要想着一口吃成个胖子 这句话不是我说的，我觉得说的太对了，孙运雷老师的智能化设计报告里引用过：“任何复杂的系统的设计都是从简单开始的”，你不可能一开始就设计复杂的系统，如果这么做，一定会以失败告终。苹果的处理器这么牛逼，因为它已经出了14代了，塞尔达传说旷野之息这么好玩，这是它第十五部续作。很多时候，我们特别想把事情做好，甚至还没开始做的时候，我们脑海里就有了做成功这件事的喜悦，那个时候的灵感确实特别想实现，但当我们实际开始动手操作的时候，发现跟想象中有些不一样，最后成品做出来，也是跟最初的理想差了十万八千里，一切都是在妥协。没办法，我们都是普通人，不是天才，我们就只能和环境妥协，妥协，又妥协，人生何尝不是这样？小时候梦想当太空人，长大了卖喜之郎养家糊口，最终还是活成了自己讨厌的样子。 知道这个道理过后，就心平气和了很多。现在愿意做事情慢慢来，开始接受不完美。甚至有的时候碰巧把想象中的事情做成了之后，觉得这种完美很不真实，比如弹吉他，一首曲子我弹的竟然和原曲子这么像？是不是吉他坏了，砸了吧。 明天孙萃邀请我帮他宣讲，我脑子里是有很多东西想讲的，我也特别想提升我的演讲能力。但我确实没怎么演讲过，所以，我不对自己报太大的期望，简单的把一部分东西流畅讲出来就可以了，对自己期望太高，讲的时候也会紧张，适得其反。 ","date":"2021-01-30","objectID":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/:3:0","tags":null,"title":"参加测试脚本编写小组的感想","uri":"/posts/%E5%8F%82%E5%8A%A0%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%B0%8F%E7%BB%84%E7%9A%84%E6%84%9F%E6%83%B3/"},{"categories":["技能分享"],"content":"v2ray是一个代理工具，你不仅需要在电脑上下载这个软件，还要购买或者直接搭建v2ray服务器用于科学上网。 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:0","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"1.下载v2ray 打开以下链接，即可自动跳入下载 点击直接下载 （如果上面链接不可用，请使用备用下载地址：链接：https://pan.baidu.com/s/1G1xoYTRB5I0hGYcUWAkVHg 提取码：6sy0 ） 下载完无需安装，解压即可。 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:1","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"2.添加一个订阅 双击点开后，软件会自动跳到后台运行 在右下角你可以找到它，双击点开 点击这里的 订阅–\u003e订阅设置 点击添加 输入订阅地址后点确定，可以使用我已经购买的订阅地址，请私聊我 之后再回到界面，点击 订阅–\u003e更新订阅 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:2","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"3.切换服务器，开启代理 然后右下角这里，右键点击–\u003e选择服务器（先随便选一个），和游戏加速器一样，因为每个人的网络环境不同，你需要更换不同的节点以达到更快的网速 选择完服务器之后，再右键该图标–\u003e点击http代理，选择全局模式，或者pac模式 全局模式下，图标会变成红色，pac模式会变紫，检测一下操作是否正确 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:3","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"最后 做个测试吧！看是否能打开谷歌http://www.google.com 再搜索ip，可以查看你的网络环境已经发生改变 ","date":"2021-01-22","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/:0:4","tags":null,"title":"如何使用v2ray代理","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/"},{"categories":["技能分享"],"content":"一.添加环境变量 直接在windows里面搜索“查看高级系统设置”，选择\u003c高级\u003e,\u003c环境变量\u003e，点开，以下三行填入其中： 然后点确定。 在我的电脑里\u003c环境变量\u003e和\u003c系统变量\u003e里面都有path，我也不知道该填哪个，索性把两个都填上了，这三个变量我觉得应该也有多余的，反正这个东西我是搞不太清楚的，只是照着网上说的做。 二.打开终端，进入目标文件夹，运行jupyter notebook这条指令 1.打开cmd之后cd进目标文件夹。 2.在目标文件夹里用git终端（需要安装git） 3.在目标文件夹按shift+右键，点\u003c在此处打开powershell窗口\u003e 以上三种方法打开终端都可以。 然后jupyter的黑窗口就跳出来了，或者是直接在终端里显示，进入notebook页面里就能看见打开了目标文件夹，还挺方便。 ","date":"2021-01-19","objectID":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/:0:0","tags":null,"title":"jupyter打开项目文件夹","uri":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"categories":["技能分享"],"content":"2月17日更新 新方法 打开anaconda prompt(按win搜索) 键入jupyter notebook + 目标文件地址 ","date":"2021-01-19","objectID":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/:0:1","tags":null,"title":"jupyter打开项目文件夹","uri":"/posts/jupyter%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"categories":["刷题"],"content":"方法一（利用的stringstream，可以是浮点数） 数字to字符串 #include \u003ciostream\u003e #include \u003csstream\u003e using namespace std; int main() { double x; string str; stringstream ss; cin \u003e\u003e x; ss \u003c\u003c x; ss \u003e\u003e str; cout \u003c\u003c str; return 0; } 字符串to数字 #include \u003ciostream\u003e #include \u003csstream\u003e using namespace std; int main() { double x; string str; stringstream ss; cin \u003e\u003e str; ss \u003c\u003c str; ss \u003e\u003e x; cout \u003c\u003c x; return 0; } ","date":"2021-01-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:0","tags":null,"title":"字符串与数字之间的转换","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { string s; s = \"123456\"; string::iterator it; it=s.begin(); s.insert(it+1,'p'); //把p插到第1个字符前，从0开始计数 cout \u003c\u003c s \u003c\u003c endl; return 0; } 运行结果 1p23456 Process returned 0 (0x0) execution time : 0.011 s Press any key to continue. ","date":"2020-12-28","objectID":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/:0:0","tags":null,"title":"给string对象插入字符","uri":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"看了课本后面的内容，发现新大陆了。string其实也是容器，而且功能很强大。 ","date":"2020-12-28","objectID":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/:1:0","tags":null,"title":"给string对象插入字符","uri":"/posts/%E7%BB%99string%E5%AF%B9%E8%B1%A1%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { srand(time(NULL)); vector\u003cint\u003ev; int i; for(int i=0;i\u003c10;i++) { v.push_back(rand()%100); } for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v.begin(),v.end()); //升序排列 for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 结果： 13 32 13 85 48 99 36 53 18 16 13 13 16 18 32 36 48 53 85 99 Process returned 0 (0x0) execution time : 0.013 s Press any key to continue. 自定义函数： #include \u003cbits/stdc++.h\u003e using namespace std; bool cmp(const int \u0026a,const int \u0026b) { return a \u003e b; } int main() { srand(time(NULL)); vector\u003cint\u003ev; int i; for(int i=0;i\u003c10;i++) { v.push_back(rand()%100); } for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; sort(v.begin(),v.end(),cmp); //升序排列 for(i=0;i\u003c10;i++) { cout \u003c\u003c v[i] \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 实测const可以去掉，不影响结果 结果： 3 26 45 43 42 72 71 63 35 63 72 71 63 63 45 43 42 35 26 3 一、const int 和int 的区别 1、返回值 const int \u0026 是返回这个数值的一个常量的引用。 而int 是返回这个数值的一个拷贝。 int 是进行拷贝构造，而const int \u0026 是返回的引用。拷贝构造更消耗时间，与此同时还用析构函数。因为产生了一个拷贝，你就可以轻易地修改拷贝的内容。 2、取指针 const int类型一旦定义以后就不能修改，int类型是随时可以修改的。 在取指针方面，const有略复杂的东西，但是常规的、合理的操作不应该涉及到，因为const int是用来保存一些全局常量的，这些常量在编译期可以改，在运行期不能改。 听起来这像宏，其实这确实就是用来取代宏的： #define PI 3.14 const float Pi = 3.14; 如果你的代码里用到了100次PI（宏），你的代码中会保存100个3.14这个常数。 鉴于使用常数进行运算的机器代码很多时候会比使用变量来的长，如果你换用100次Pi（const float)，程序编译后的机器码里就不需要出现100次常量3.14，只要在需要的时候引用存有3.14的常量就行了。 特别在复杂的运算里，3.14这个常量（其实是无法修改的变量）会被一直装载在寄存器里带来一些性能提升。 3、内容 constint* p; //p可变，p指向的内容不可变，int const* p; //p可变，p指向的内容不可变。 int* const p; //p不可变，p指向的内容可变 const int* const p; //p和p指向的内容都不可变。 二、const的作用： 1、可以定义const常量，具有不可变性。 例如：const int Max=100; Max++会产生错误; 2、便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。 例如： void f(const int i) { ………} 编译器就会知道i是一个常量，不允许修改； 3、可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以做到不变则已，一变都变！ 如1中，如果想修改Max的内容，只需要它修改成：const int Max=you want;即可！ 4、可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错； 例如： void f(const int i) { i=10;//error! } 5、可以节省空间，避免不必要的内存分配。 ","date":"2020-12-28","objectID":"/posts/%E4%BD%BF%E7%94%A8sort%E7%AE%97%E6%B3%95%E5%AF%B9%E5%90%91%E9%87%8F%E5%85%83%E7%B4%A0%E6%8E%92%E5%88%97/:0:0","tags":null,"title":"使用sort算法对向量元素排列","uri":"/posts/%E4%BD%BF%E7%94%A8sort%E7%AE%97%E6%B3%95%E5%AF%B9%E5%90%91%E9%87%8F%E5%85%83%E7%B4%A0%E6%8E%92%E5%88%97/"},{"categories":["刷题"],"content":"#include \u003cbits/stdc++.h\u003e using namespace std; int main() { srand(time(NULL)); vector\u003cint\u003ev(10); for(int i=0;i\u003c10;i++) { v[i] = rand()%100; } vector\u003cint\u003e::iterator it; for(it=v.begin();it!=v.end();it++) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c endl; reverse(v.begin(),v.end()); for(it=v.begin();it!=v.end();it++) { cout \u003c\u003c *it \u003c\u003c ' '; } cout \u003c\u003c endl; return 0; } 运行结果 94 66 52 71 33 43 91 59 78 69 69 78 59 91 43 33 71 52 66 94 Process returned 0 (0x0) execution time : 0.013 s Press any key to continue. string容器 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { string s; s = \"123456\"; reverse(s.begin(),s.end()); cout \u003c\u003c s; return 0; } ","date":"2020-12-28","objectID":"/posts/%E4%BD%BF%E7%94%A8reverse%E5%8F%8D%E5%90%91%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"使用reverse反向排列算法","uri":"/posts/%E4%BD%BF%E7%94%A8reverse%E5%8F%8D%E5%90%91%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"},{"categories":["书影记录"],"content":"今天和同学们看了电影《十二公民》，有感而发。 十二公民讲的主要是十二位职业，性格各不相同的成年人，受到老师的邀请在政法大学的教室里进行模拟陪审，讨论一起凶杀案的嫌疑人是有罪还是无罪的故事。影片的场景非常简单，绝大部分剧情都发生在那间教室里，但是剧情却一波三折，从最初的十一人投票认为有罪，一人认为无罪，到最后全部认为无罪通过，这样的剧情真是让我难忘。 这十二个人，他们的职业，性格都迥然不同。有出租车司机，有房地产商，有社会混混，有保安，有小卖部店长，有外科医生….还有一个厉害角色—检察官。每个人都来自不同的地区，有着不同的人生经历，让他们几个坐在一起讨论事情，真的非常有趣，吵得热闹的时候都快把桌子给掀了，还多次差点动手打起来。他们只有一个共同点，那就是，他们都是中国公民。 这部影片，道法课张会芸老师介绍过，它主要揭露的，就是中国的公民法治意识的不健全。和西方相比，中国人本来就是刚刚步入法治社会，又在文革时期，法律曾遭到严重践踏。不错，现在中国人的素质在提高，人们都知道，一个人犯了法，需要用法律来将他绳之以法。可关键是，有在法律之外的东西，它不是执行法律，而是审判一个嫌疑人是否触犯法律，它就是法治思维，这仍然是这个公民普遍缺少的。 小的时候我看过这部影片，当时我也搞不明白，为什么铁证如山，那个检察官还要硬说嫌疑人是无罪的？ 现在，我读过一些书，也上过思修课，我渐渐开始明白：我们评判一个事件，往往带有主观色彩，比如，嫌疑人是一个富二代，我们潜意识里就认为富二代就是坏孩子，就一定是凶手，就一定是他犯的罪。所以在听证人的证词时，我们潜意识里就觉得嫌疑人他就是凶手。 但是，如果我们转变思想，我们把潜意识删除，我们假设嫌疑人是无罪的，我们去推理证人的证词出了问题，结果我们还真找到了问题。这，就是那位检察官一直在引导另外十一个人做的事情。 以前的中国，忙着打仗，忙着发展经济，社会上出现了一些问题，我们需要快速的解决，不要产生过多社会舆论，所以我们按照人情世故去执法，给老百姓一个让他们觉得“合理”的结果，尽管这样的结果与真理违背。但是，现在不一样了，现在中国富起来了，强起来了，人民的素质在提高，社会在进步，我们需要正确的法治思维，我们要努力让真理存在，否则，社会也不会继续发展。 最后，我觉得一个电影的好坏可以从两个方面评析：一是可观看性，如果一部电影讲述的故事非常有趣，让人想看一直下去，那它符合可观看性。二是内涵性，如果一部电影，它不仅仅像是喜剧片那样人看完笑完就忘了，而是揭示出深刻的道理，甚至帮助改善一些社会问题，那么它是一部有内涵的电影。我认为，十二公民这部电影，符合这两点，电影的笑点很多，故事很有趣，且这部电影有内涵有深意，因此我认为它是一部好电影。 ","date":"2020-12-21","objectID":"/posts/%E5%8D%81%E4%BA%8C%E5%85%AC%E6%B0%91%E8%A7%82%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《十二公民》观后感","uri":"/posts/%E5%8D%81%E4%BA%8C%E5%85%AC%E6%B0%91%E8%A7%82%E5%90%8E%E6%84%9F/"},{"categories":["刷题"],"content":"题目描述 你需要开发一款文字处理软件。最开始时输入一个字符串（不超过 100 个字符）作为初始文档。可以认为文档开头是第 0 个字符。需要支持以下操作： 1 str：后接插入，在文档后面插入字符串 str，并输出文档的字符串。 2 a b：截取文档部分，只保留文档中从第 a 个字符起 b 个字符，并输出文档的字符串。 3 a str：插入片段，在文档中第 a 个字符前面插入字符串 str，并输出文档的字符串。 4 str：查找子串，查找字符串 str 在文档中最先的位置并输出；如果找不到输出 -1。 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int n,i; cin \u003e\u003e n; string s; cin \u003e\u003e s; for(i=0;i\u003cn;i++) { int menu; cin \u003e\u003e menu; if(menu==1) { string tmp; cin \u003e\u003e tmp; s = s + tmp; cout \u003c\u003c s \u003c\u003c endl; } if(menu==2) { int a,b; cin \u003e\u003e a \u003e\u003e b; s = s.substr(a,b); cout \u003c\u003c s \u003c\u003c endl; } if(menu==3) { int location; string tmp; cin \u003e\u003e location \u003e\u003e tmp; s.insert(location,tmp); cout \u003c\u003c s \u003c\u003c endl; } if(menu==4) { string tmp; cin \u003e\u003e tmp; if(s.find(tmp)\u003cs.size()) cout \u003c\u003c s.find(tmp) \u003c\u003c endl; else cout \u003c\u003c -1 \u003c\u003c endl; } } return 0; } ","date":"2020-12-17","objectID":"/posts/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6-substr-insert-find/:0:0","tags":null,"title":"字符处理软件-substr-insert-find","uri":"/posts/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6-substr-insert-find/"},{"categories":["刷题"],"content":"需要的库： !pip install lxml !pip install request !pip install pathlib 代码： import time #代码合集并修改为下载多页表情 import requests from bs4 import BeautifulSoup from pathlib import Path for i in range(1,4): url = f'https://www.fabiaoqing.com/biaoqing/lists/page/{i}.html' response = requests.get(url) time.sleep(3) soup = BeautifulSoup(response.content,'lxml') img_list = soup.find_all('img', class_=\"ui image lazy\") for index,img in enumerate(img_list): image = img.get('data-original') content = requests.get(image).content file = Path('d:/emotion') / f'{index}{Path(image).suffix}' file.write_bytes(content) ","date":"2020-12-13","objectID":"/posts/requests%E7%88%AC%E8%A1%A8%E6%83%85%E5%8C%85/:0:0","tags":null,"title":"requests爬表情包","uri":"/posts/requests%E7%88%AC%E8%A1%A8%E6%83%85%E5%8C%85/"},{"categories":["书影记录"],"content":"我把解放后中国的崛起分为两个阶段，一是1949年至改革开放前（1978年）发展重工业，二是1978年改革开放之后到现在的中国特色社会主义经济。  第一阶段，主要领导人是毛泽东主席，他的伟大之处就在于让中国人民团结起来，组建了强有力的政府，政府的动员能力十分了得，当时人民也非常热血积极，在政府的指挥下完成了不少辉煌的成就。1949年~1952年国民经济恢复时期，政府领导人民恢复生产发展经济，1953年~1957年完成一五计划，此外，还打赢了抗美援朝战争，赢得安全的国际环境。后期毛主席领导尽管出现了一些错误，如发动“大跃进”，但是也有好的作用。152万个乡镇企业（当时叫社队企业）是留给邓小平同志的重要遗产。  总的来说，第一阶段政府组织人民填补了中国没有重工业基础的空白，但是人民生活并不好。  第二阶段，主要领导人是邓小平同志，他在1978年提出改革开放，把工作重心从阶级斗争转变为经济建设，邓小平南方讲话后，各地政府的意识形态转向重商主义。中国从此走上了一个很特殊的经济体系-中国特色社会主义经济，按照《中国的官办经济》的作者陈经的说法，就叫做官办经济。  官办经济特殊在于政府是“经济人”，由各地政府领导当地人民发展本地经济，人民没什么自由度，但是政府自由度很大，什么赚钱就搞什么。中国在地方政府这一层次上引入市场竞争体系，发挥了市场在资源配置中的基础作用，而一般民众依附于各级政府的行动当中。  中国运行官办经济的优势如下： 毛泽东时期留下的152万个乡镇企业派上用场，它们是最初的国企，受政府控制。 政府十分强势，权力大，组织力强，效率很高，且能承担亏损。 地方政府又很听中央的话，有错误可以及时被纠正，这叫做宏观调控。 对于整个中国，也有很多机遇： 国际环境以和平为主。 经济全球化，使中国参与到世界贸易。 中央有很多厉害人物，比如邓小平，陈云，朱镕基，他们除了制定官办经济体系外，还对整个中国的经济进行了引导： 发展比较优势，最明显的就是发展棉纺织业，中国自古以来就是纺织大国，靠这个能稳定的赚到钱。 赚到钱后，再去引进外资，吸引外国商人来中国办厂（邓小平设立经济特区），生产物美价廉的商品，再卖给外国，走“开放，引进，出口，加工”的道路。所以中国的工厂越来越多，号称“世界工厂”，制造业首屈一指，世界也越来越依赖中国。 大搞基础设施建设，这不仅解决了很多民生问题（比如就业，防水防洪），还使国内有效需求真实地增长，更好发挥市场的作用。 用宏观调控稳定市场，中国深刻吸取了“大跃进”的教训，特别注重稳定，尊重客观规律发展。经济稍微过热或者过冷，中央都要进行干预。（比如朱镕基抓银行，控制银行的权利，将其收归中央，控制各地政府的资金流动） 转换企业经营机制，对国有企业进行改革，反对垄断（比如运营商有三大）；转成股份制（调动国企工作人员积极性）；见死不救，在市场竞争中淘汰一些垃圾国企。 另外，最近几年中国赶上了移动互联网的浪潮，电商平台，在线支付极大促进了消费。雷军与董明珠的十亿赌局，体现出了互联网行业相较于传统制造业发展速度之迅速。很多土生土长的中国企业，比如华为，海光等，掌握很多核心科技，这也是一个国家宝贵的财富。 ","date":"2020-12-12","objectID":"/posts/%E4%B8%AD%E5%9B%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/:0:0","tags":null,"title":"中国是如何富起来的？","uri":"/posts/%E4%B8%AD%E5%9B%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/"},{"categories":["刷题"],"content":"一开始我尝试自己写，需要用到把int类型转换成string类型，在Python里，这非常简单，一行代码就可以搞定。但是我惊奇的发现，在c++里把int类型转换成string类型真的好麻烦！在百度上查了很久，方法要么不对，要么就是太复杂。果然c++是不适合处理字符串的。 所以放弃那种做法，用这种： bool is_huiwen(int n) { unsigned i=n; unsigned m=0; while(i\u003e0) { m=m*10+i%10; i/=10; } return m==n; } 思路，比如判断121，把121倒过来还是121，判断与原数相等，所以是回文数。 ","date":"2020-12-04","objectID":"/posts/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/:0:0","tags":null,"title":"判断回文数","uri":"/posts/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["刷题"],"content":"比较字符串字典序的三种方法【C++】 - 知乎 (zhihu.com) #include \u003ciostream\u003e using namespace std; int main() { char s1[2] = \"a\"; char s2[2] = \"b\"; cout \u003c\u003c strcmp(s1, s2) \u003c\u003c endl; //-1 cout \u003c\u003c strcmp(s2, s1) \u003c\u003c endl; //1 cout \u003c\u003c strcmp(s1, s1) \u003c\u003c endl; //0 return 0; } #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main() { string s1 = \"a\"; string s2 = \"b\"; cout \u003c\u003c s1.compare(s2) \u003c\u003c endl; //-1 cout \u003c\u003c s2.compare(s1) \u003c\u003c endl; //1 cout \u003c\u003c s1.compare(s1) \u003c\u003c endl; //0 return 0; } #include \u003ciostream\u003e using namespace std; int main() { char s1[2] = \"a\"; char s2[2] = \"b\"; cout \u003c\u003c (s1 \u003c s2) \u003c\u003c endl; //0 cout \u003c\u003c \u0026s1 \u003c\u003c endl; //00BDFE74 cout \u003c\u003c \u0026s2 \u003c\u003c endl; //00BDFE68 cout \u003c\u003c (string(s1) \u003c string(s2)) \u003c\u003c endl; //1 cout \u003c\u003c (string(s2) \u003c string(s1)) \u003c\u003c endl; //0 cout \u003c\u003c (string(s1) == string(s1)) \u003c\u003c endl; //1 return 0; } ","date":"2020-12-04","objectID":"/posts/c++%E6%AF%94%E8%BE%83%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"c++比较字典序的三种方法","uri":"/posts/c++%E6%AF%94%E8%BE%83%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["刷题"],"content":"质数判断是最简单最基本的算法，虽然我能很快把代码写出来，但是总会有一些小错误，不妨把下面的经典代码记下来 #include \u003ciostream\u003e #include \u003ccmath\u003e using namespace std; bool sb(int x) { int i,flag=0; if(x==1) return 0; else { for(i=2; i\u003c=sqrt(x); i++) { if(x%i==0) { flag = 1; } } if(flag==1) { return false; } else { return true; } } } 如果是质数，函数sb()返回1，不是就返回0； ","date":"2020-12-03","objectID":"/posts/%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD/:0:0","tags":null,"title":"质数判断","uri":"/posts/%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD/"},{"categories":["刷题"],"content":"nmd，一道题做了一个小时没看出哪里有问题，居然是“等于”写错了！ 千万不要把“==”写成“=” 输出小数时函数用成了int Fun() 应该用double Fun() 习惯了使用int Fun() 也是看了半天，没有看出问题来 输入M和N 我只写了cin » N; 导致后面全错，查了半天也没查出来； 定义了数组a[9999]; 后面定义了变量a 报错invalid types ‘int[int]’ for array subscript 使用cnt变量进行计数时，没有赋初始值0； 算法是对的，一送进Oj就错 搞了半天，数组开小了 明天就程序设计考试了，我作为程序设计课代表（假课代表），不能考的太差呀！ 加油吧 ","date":"2020-12-02","objectID":"/posts/c++%E5%82%BB%E7%BC%BA%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/:0:0","tags":null,"title":"c++傻缺错误集锦","uri":"/posts/c++%E5%82%BB%E7%BC%BA%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/"},{"categories":["刷题"],"content":"from selenium import webdriver from bs4 import BeautifulSoup import csv out = open('d:/data.csv','w', newline='') csv_write = csv.writer(out,dialect='excel') for year in range(1960,2018): driver = webdriver.Chrome() url = \"https://www.kylc.com/stats/global/yearly/g_gdp/%d.html\"%year xpath = \"/html/body/div[2]/div[1]/div[5]/div[1]/div/div/div/table\" driver.get(url) table1 = driver.find_element_by_xpath(xpath).get_attribute(\"innerHTML\") out = open('d:/data.csv','w', newline='') csv_write = csv.writer(out,dialect='excel') soup = BeautifulSoup(table1,\"html.parser\") table = soup.find_all('tr') for row in table: cols = [col.text for col in row.find_all('td')] if len(cols)==0 or not cols[0].isdigit(): continue cols.append(year) csv_write.writerow(cols) print(cols) driver.close() ","date":"2020-12-01","objectID":"/posts/selenium%E7%88%ACgdp/:0:0","tags":null,"title":"selenium爬GDP","uri":"/posts/selenium%E7%88%ACgdp/"},{"categories":["刷题"],"content":"【题目描述】 某某国王（不是萨拉克门托！）有一个神奇的魔镜，它可以把东西变为原来的两倍(可惜是反的)。某日，他感到很无聊，于是把皇后的一串珠子变了不知道几次，皇后回来之后不是很高兴，她还是喜欢原来那串珠子，现在告诉你改变之后珠子的形状，请你告诉她，原来的珠子是什么样子的。 【输入】 输入有多组测试用例，每组一行，每行一串字符，表示现在的珠串，长度小于100。 【输出】 输出对应有多行，每行输出原来的珠串。 For example: Input Result 1232232112322321 121121 abba 1232 121 ab ","date":"2020-11-27","objectID":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/:0:0","tags":null,"title":"对称字符串处理","uri":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"categories":["刷题"],"content":"Answer:(penalty regime: 20 %) #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cstring\u003e using namespace std; bool myfun(string \u0026s) { int beg = 0; int end = s.size()-1; while(beg \u003c end) { if(s[beg] != s[end]) { return false; } beg++; end--; } return true; } int main() { string s; while(cin \u003e\u003e s) { while(myfun(s) \u0026\u0026 s.size()%2==0) s = s.substr(0,s.size()/2); cout \u003c\u003c s \u003c\u003c endl; } return 0; } 搞了老久了妈的 没想到，c++的string字符串中的单个字符也可以通过s[]的形式来访问，发现了新大陆，感觉还是蛮方便的； 这题的算法很巧妙，当然不是我想出来的，参考https://blog.csdn.net/jacketinsysu/article/details/38335453； t=s.substr(a,b)是将s中的从a开始的b个元素复制到t中； ","date":"2020-11-27","objectID":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/:1:0","tags":null,"title":"对称字符串处理","uri":"/posts/%E5%AF%B9%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"categories":["刷题"],"content":"【题目描述】 某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分）是： 7 279 5 279 这两行数据的含义是：总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是279 （总分等于输入的语文、数学、英语三科成绩之和），但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是： 5 279 7 279 则按输出错误处理，不能得分。 【输入】 共n+l行：第1行为一个正整数n（6≤n≤300），表示该校参加评选的学生人数；第2到n+l行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1～n（恰好是输入数据的行号减1）。 【输出】 共有5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。 For example: Input Result 6 90 67 80 87 66 91 78 89 91 88 99 77 67 89 64 78 89 98 6 265 4 264 3 258 2 244 1 237 ","date":"2020-11-24","objectID":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/:0:0","tags":null,"title":"给学生成绩排序，总分相同看语文，语文相同看序号","uri":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/"},{"categories":["刷题"],"content":"Answer:(penalty regime: 20 %) 法一，不推荐 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; struct student_t_distribution { int yuwen; int shuxue; int yingyu; int sum; int code; }s[9999]; int main() { int n,i,j; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e s[i].yuwen \u003e\u003e s[i].shuxue \u003e\u003e s[i].yingyu ; } for(i=0;i\u003cn;i++) { s[i].sum = s[i].yuwen + s[i].shuxue + s[i].yingyu; s[i].code = i + 1 ; } for(i=0;i\u003cn;i++) { for(j=i+1;j\u003cn;j++) { if(s[j].sum\u003es[i].sum (s[j].sum==s[i].sum \u0026\u0026 s[j].yuwen\u003es[i].yuwen) (s[j].sum==s[i].sum \u0026\u0026 s[j].yuwen==s[i].yuwen \u0026\u0026 s[j].code\u003cs[i].code)) { swap(s[j],s[i]); } } } for(i=0;i\u003c5;i++) { cout \u003c\u003c s[i].code \u003c\u003c' '\u003c\u003c s[i].sum \u003c\u003c endl; } return 0; } 法二，用函数和sort，推荐 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; struct stu { int yuwen; int shuxue; int yingyu; int sum; int code; }s[9999]; bool cmp(stu \u0026a,stu \u0026b) { if(a.sum != b.sum) { return a.sum \u003e b.sum; } if(a.sum == b.sum \u0026\u0026 a.yuwen != b.yuwen) { return a.yuwen \u003e b.yuwen; } if(a.sum == b.sum \u0026\u0026 a.yuwen == b.yuwen) { return a.code \u003c b.code; } return 0; } int main() { int n,i; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e s[i].yuwen \u003e\u003e s[i].shuxue \u003e\u003e s[i].yingyu ; } for(i=0;i\u003cn;i++) { s[i].sum = s[i].yuwen + s[i].shuxue + s[i].yingyu; s[i].code = i + 1 ; } sort(s,s+n,cmp); for(i=0;i\u003c5;i++) { cout \u003c\u003c s[i].code \u003c\u003c' '\u003c\u003c s[i].sum \u003c\u003c endl; } return 0; } ","date":"2020-11-24","objectID":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/:0:1","tags":null,"title":"给学生成绩排序，总分相同看语文，语文相同看序号","uri":"/posts/%E7%BB%99%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E5%88%86%E7%9B%B8%E5%90%8C%E7%9C%8B%E8%AF%AD%E6%96%87%E8%AF%AD%E6%96%87%E7%9B%B8%E5%90%8C%E7%9C%8B%E5%BA%8F%E5%8F%B7/"},{"categories":["刷题"],"content":"【题目描述】 中超联赛拥有大量的现场观众和收视观众，球迷都渴望观看比赛，同时希望能有一个平台更深度的了解中超联赛，体验中超球队的辛苦和努力。每场足球比赛历时90分钟，分为上半场和下半场。 中超的积分规则如下：赢得一场比赛得3分，平一场得1分，输球不得分。例如一个球队的胜平负的场次分别为11,2和 2，那么积分就是11*3+2*1=35。9102年的中超联赛已经落下帷幕，请你帮忙计算出各球队的总积分并按照积分给出球队最终的排名吧！ 【输入】 有多行。第1行是球队数量n（1\u003cn≤16）。 接下来有n行，每行数据包含球队的名称（不含空格，长度不超过30个字符）和胜、平、负的场次，数据间以空格分开。 【输出】 各个球队按照积分的排名情况（保证所有球队的积分各不相同），每行输出球队的名次、名称和该队的积分，数据间用一个空格分开，每行末尾没有空格。 For example: Input Result 3 shanghaishanggang 11 2 2 beijingguoan 12 2 1 shandonglunengtaishan 10 1 4 1 beijingguoan 38 2 shanghaishanggang 35 3 shandonglunengtaishan 31 Answer:(penalty regime: 20 %) #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; typedef struct footballteam //不懂 { char name[1000]; int win; int equals; int fail; int sum; }TEAM; int cmp(TEAM \u0026a,TEAM \u0026b) //不懂 { return a.sum \u003e b.sum; } int main() { TEAM a[20]; int n,i; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i].name \u003e\u003e a[i].win \u003e\u003e a[i].equals \u003e\u003e a[i].fail; a[i].sum = a[i].win*3 + a[i].equals; } sort(a,a+n,cmp); for(i=0;i\u003cn;i++) { cout \u003c\u003c i+1 \u003c\u003c' '\u003c\u003ca[i].name \u003c\u003c' '\u003c\u003ca[i].sum \u003c\u003c endl; } return 0; } ","date":"2020-11-21","objectID":"/posts/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F-sort-typedef/:0:0","tags":null,"title":"结构体排序-sort()-typedef","uri":"/posts/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F-sort-typedef/"},{"categories":["刷题"],"content":"【问题描述】 有n只猴子围成一圈，从1~n编号，大家决定从中选出一个大王。经过协商，决定选大王的规则为：从编号为1的猴子开始报数，报到k的猴子出圈，然后再从下一只开始继续报1到k，最后剩下来的那一只就是大王。 【输入】  一行，包含两个正整数n和k（2≤n≤1000,2≤k≤109）。 【输出】  一行，一个正整数，表示猴王的编号。 For example: Input Result 3 2 3 ","date":"2020-11-21","objectID":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","tags":null,"title":"猴子选大王-结构体","uri":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; struct MONKEY { int code; int next; }; int main() { MONKEY mons[1000]; int n; int k; cin \u003e\u003e n \u003e\u003e k; //init int i,j,index=1,pre; for(i=1;i\u003cn;i++) { mons[i].code = i; mons[i].next = i+1; } mons[n].code = n; mons[n].next = 1; //run for(i=1;i\u003cn;i++) { //do a roll for(j=1;j\u003ck;j++) { pre = index; index = mons[index].next; } //index will leave mons[pre].next = mons[index].next; pre = mons[pre].next; //这两句是加的 index = mons[index].next; } cout \u003c\u003c mons[index].code \u003c\u003c endl; return 0; } 分析： 这题比较难，老宫上课时写了一段代码，我把它记下来了，提交后发现不能通过全部测试数据。然后我就自己捣鼓。我知道问题是出在//index will leave 这个地方，但我不知道怎么改，最后我就打算放弃了，随便加了两句竟然瞎猫碰死耗子碰对了。 Input Expected Got 3 2 3 3 285 844 97 97 Passed all tests! ","date":"2020-11-21","objectID":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","tags":null,"title":"猴子选大王-结构体","uri":"/posts/%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["刷题"],"content":"【题目描述】 请编一个将浮点数四舍五入的函数Fun，其功能是使浮点数保留2位小数，并对第3位进行四舍五入（规定实型数为正数）。 例如：实型数为1234.567，则函数返回1234.57；实型数为1234.564，则函数返回1234.56。 【输入】 一个浮点数。 【输出】 精确到小数点后面2位的浮点数。 【函数声明】 double Fun(double a) For example: Input Result 1234.567 1234.57 1234.561 1234.56 ","date":"2020-11-18","objectID":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/:0:0","tags":null,"title":"四舍五入小数","uri":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"Answer: double Fun(double a) { //1.进行四舍五入 a = a + 0.005; //2.将要保留的数据挪到整数位，再取整 int temp = a*100; //一步到位 //int temp = (a+0.005)*100; //3.转为所需数字 a = temp/100.0; return a; } 点评：很有趣的写法！ ","date":"2020-11-18","objectID":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/:1:0","tags":null,"title":"四舍五入小数","uri":"/posts/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"求m和n的最大公约数 int gcd(int m,int n) { if(m%n==0) { return n; } else { return gcd(n,m%n); } } ","date":"2020-11-17","objectID":"/posts/%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/:0:0","tags":null,"title":"递归法求最大公约数","uri":"/posts/%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"categories":["刷题"],"content":"from selenium import webdriver from bs4 import BeautifulSoup from selenium.webdriver import ActionChains import time from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC def wait(xpath,driver): WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH, xpath))) #登录： def login(driver): id_box = '//*[@id=\"userAccount\"]' wait(id_box,driver) driver.find_element_by_xpath(id_box).send_keys('2007010218') password_box = '//*[@id=\"userPassword\"]' driver.find_element_by_xpath(password_box).send_keys('2007010218') yan_zhen = '//*[@id=\"RANDOMCODE\"]' driver.find_element_by_xpath(yan_zhen).click() time.sleep(5) login_btn = '//*[@id=\"btnSubmit\"]' driver.find_element_by_xpath(login_btn).click() time.sleep(2) ke_biao = '/html/body/div[5]/a[2]/div' driver.find_element_by_xpath(ke_biao).click() time.sleep(2) #执行 driver = webdriver.Chrome() url = 'http://jwxt.upc.edu.cn/' driver.get(url) time.sleep(1) login(driver) driver.get_screenshot_as_file(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\kb.png\") driver.quit() 依次执行以上cell，1.打开chrome自动输入账号密码。2.有五秒钟的时间人工输入验证码。3.自动进入课表页面，自动截图，保存在桌面（保存文件夹在目录可能需要更改） ","date":"2020-11-16","objectID":"/posts/selenium%E7%88%AC%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E8%A1%A8/:0:0","tags":null,"title":"selenium爬教务处课表","uri":"/posts/selenium%E7%88%AC%E6%95%99%E5%8A%A1%E5%A4%84%E8%AF%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"seleniumrequest下载 ","date":"2020-11-16","objectID":"/posts/python%E7%88%AC%E8%99%AB-selenium-request/:0:0","tags":null,"title":"Python爬虫-selenium-request","uri":"/posts/python%E7%88%AC%E8%99%AB-selenium-request/"},{"categories":["随笔杂记"],"content":"九月，我成为了石油大学计算机学院的一名学生。秋高气爽，海风习习，我第一次远离家乡，独自留在一个陌生的城市，妈妈望着我远去的背影，掉下了眼泪，我的心里也很不是滋味。 但是，我很快就熟悉了校园，与身边的同学打成了一片，我们一起去食堂吃饭，一起寻找上课的教室，一起讨论不会的程序设计题目，一起参加各种活动。从高三压抑紧张的氛围解脱出来后，我终于可以进入大学，选择我最感兴趣的计算机专业，学习我喜欢的东西，认识我喜欢的人，我前所未有地感受到了自由的美好，青春的美好。 过度的自由，会让人迷失方向。太过于自由，就让我陷入了堕落，我开始睡懒觉，有时间就会刷手机，上课不想听课，也不注意锻炼身体。我和很多大一新生一样，没过多久，就陷入了人生的迷茫。晚上睡觉之前，我回忆我的一天，我问我自己，我今天做了什么？起初，我给自己定下很多很多目标，我要坚持每天练字，我要每天刷很多程序题，我还要学会ps,pr,ppt,excel等等很多软件，我还要读很多书… 当然，这些目标我都没有完成，我会觉得有些愧疚，我给自己找理由说自己每天琐事太多，时间不够用。可是有一天，我发现我手机屏幕的使用时间竟然达到了每天六个小时。简单计算一下，我每天早上六点起床，十二点睡觉，白天18个小时之中，三分之一的时间都浪费在了手机上，“时间不够”完全就是借口！ 我反思是什么阻碍了我的坚持？我一门心思想学习的那些技能，比如书法，程序设计，office软件，都遇到了小小的瓶颈，而我在遇到瓶颈时，并不是想着怎么去突破它，而是选择了放弃，转身去向其它活动。在参加其它活动的过程中很多我并不感兴趣，仅仅只是浅尝辄止，这是毫无用处的。我太“花心”了，想得到的太多，却没耐心解决难题。 第十周是我开学以来最迷茫的一周，我的人际关系面临挑战，由于班级不同课程时间不同，还有人生目标，价值观的不同，我和室友的矛盾渐渐凸显。还有三座大山压在我心里，一是周四的体测，二是周六的数学分析考试，三是周日的合唱比赛。尤其是这个合唱比赛，真的让我很难受。我本就不喜欢参加这种文艺活动，却在这次活动中承担了主角的压力。这真是错误地选择。 但是一切都会过去，我和室友沟通，我们达到了微妙的平衡，商量回归到正常作息。我尽量减少其它活动，只把精力投放在了“三座大山”上面，一有时间就呆在图书馆里，我甚至找回了一点高三的感觉，那时的我就是这样目标明确，有压力也有动力。功夫不负有心人，周四的体测我顺利合格了，周六的数学分析考试题目也基本都复习到了，合唱比赛我也在积极准备，与室友的关系也渐渐缓和，阳光又照进了我的生活。 堕落懒散的生活只会让人得到一时的欢愉，真正长久的快乐，是通过努力奋斗得到的。我想起《人民日报》上的一句话：“不能因现实复杂而放弃梦想，不能因理想遥远而放弃追求，因为，历史只会眷顾坚定者，奋进者，搏击者，而不会等待犹豫者，懈怠者，畏难者！” 我就像党在1978年召开的十一届三中全会一样，完成思想上的“拨乱反正”，我应该让自己知道我要做什么事，并且努力地把事情做好。正如习总书记所说“奋斗是青春最靓丽的底色。”我要用奋斗青春成就未来！ ， ","date":"2020-11-15","objectID":"/posts/%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E4%B8%8D%E8%BF%B7%E8%8C%AB%E5%A5%8B%E6%96%97%E9%9D%92%E6%98%A5%E6%88%90%E5%B0%B1%E6%9C%AA%E6%9D%A5-%E5%BE%81%E6%96%87%E6%B4%BB%E5%8A%A8/:0:0","tags":null,"title":"我的青春不迷茫，奋斗青春成就未来-征文活动","uri":"/posts/%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E4%B8%8D%E8%BF%B7%E8%8C%AB%E5%A5%8B%E6%96%97%E9%9D%92%E6%98%A5%E6%88%90%E5%B0%B1%E6%9C%AA%E6%9D%A5-%E5%BE%81%E6%96%87%E6%B4%BB%E5%8A%A8/"},{"categories":["刷题"],"content":" bitset\u003c16\u003e bint; // 16 bit 二进制数据，还有 bitset\u003c32\u003e cin \u003e\u003e bint; int a; a = bint.to_ulong(); cout \u003c\u003c a; ","date":"2020-11-10","objectID":"/posts/%E8%BE%93%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6/:0:0","tags":null,"title":"输入二进制转化为十进制","uri":"/posts/%E8%BE%93%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6/"},{"categories":["刷题"],"content":"【题目描述】 小明参加学校每年一度的大学生科技节活动的游戏，这次遇到的题目是字符接龙。主持人拿出2张卡片，每张卡片上都有一个顺序字符串，即字符串是按ASCII码顺序编排的。现在要求小明把2个字符串连接成一个字符串，而且连接以后的字符串内容还是按ASCII码顺序排列的。（假设每张卡片上的字符串都不包含空格）。 【输入格式】 有2行。分别为两个不包含空格的字符串，每个字符串长度不超过1000。 【输出格式】  连接后的顺序字符串（按ASCII码顺序排列）。 For example: Input Result acd br abcdr ","date":"2020-11-07","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/:0:0","tags":null,"title":"字符数组的拼接和排序-strcat()-sort()-strlen()","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e #include\u003cstring.h\u003e #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; int main() { char a[100]; char b[100]; int len; scanf(\"%s\",a); scanf(\"%s\",b); strcat(a,b); len = strlen(a); sort(a,a+len); cout \u003c\u003c a; return 0; } 头文件好像没有全部用到。这段代码写得我还是比较满意的，如果要造轮子的话，光是一个拼接就够我搞一节课了。 ","date":"2020-11-07","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/:1:0","tags":null,"title":"字符数组的拼接和排序-strcat()-sort()-strlen()","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8E%92%E5%BA%8F-strcat-sort-strlen/"},{"categories":["刷题"],"content":"【题目描述】 输入一个长度不超过 100 的字符串，删除串中的重复字符。例如：输入的字符串为abacaeedabcdcd， 删除重复字符串后为abced。 【输入格式】 一个长度不超过100个字符。 【输出格式】 删除重复字符后的字符串，保留原来的顺序。 For example: Input Result abacaeedabcd abced ","date":"2020-11-07","objectID":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/:0:0","tags":null,"title":"删除重复的字符并重新排列-这个题太jb烦人了","uri":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/"},{"categories":["刷题"],"content":"Answer #include \u003cstdio.h\u003e #define N 100 int main() { char a[N]; int i,j,m; scanf(\"%s\",a); for(i=0; a[i]!=0; i++) for(j=i+1; a[j]!=0; j++) if(a[i]==a[j]) { for(m=j; a[m]!=0; m++) { a[m]=a[m+1]; } j--; } puts(a); return 0; } 完全就是造轮子，没意思，明明知道有很好用的函数可以直接解决，但是我一个都不会！！ ","date":"2020-11-07","objectID":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/:1:0","tags":null,"title":"删除重复的字符并重新排列-这个题太jb烦人了","uri":"/posts/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97-%E8%BF%99%E4%B8%AA%E9%A2%98%E5%A4%AAjb%E7%83%A6%E4%BA%BA%E4%BA%86/"},{"categories":["刷题"],"content":"【题目描述】 If we define each of the upper case letters a number, that is, 1 for A, 2 for B, 3for C, … 25 for Y, 26 for Z, we can calculate a mark for any word or sentence. We believe that 100 points is the full mark, so for those word with a mark larger than 100, we should just ignore that, with a label “INVALID” .Then let’s see interesting results: What is the most important for your success? HARDWORK? H+A+R+D+W+O+R+K=8+1+18+4+23+15+18+11=98 KNOWLEDGE? K+N+O+W+L+E+D+G+E=11+14+15+23+12+5+4+7+5=96 MONEY? M+O+N+E+Y=13+15+14+5+25=72 LUCK? L+U+C+K=12+21+3+11=47 ATTITUDE! A+T+T+I+T+U+D+E=1+20+20+9+20+21+4+5=100 So just be with good attitude and you will be on your way to success. 【输入格式】 For each case of the input, it contains a single line. For each line, some characters will appear with maybe some of them being upper case letters. All characters are printable. Each line will have at most 127 characters. 【输出格式】 For each case, you should only pay attention to upper case letters and calculate the total points. If it is over 100, “INVALID” should be returned. Or you should print the exact point of that. For example: Input Result DELICIOUS FOOD YY, and YY again! did i lose anything? INVALID 100 0 ","date":"2020-11-05","objectID":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/:0:0","tags":null,"title":"每个字母代表一个数字，输出字符串代表的数字之和","uri":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; int main() { //输入1至26个字母 char a[9999]; int i,j,cnt,x=0; for(i=1;i\u003c=26;i++) { a[i] = 'A' + i - 1; } //输入字符 char b[9999]; while(cin.getline(b,9999)) //这个while是后来加上去的，没有while就不能多次输入 { cnt = 0; //逐个计数 for(i=0;b[i]!='\\0';i++) { for(j=1;j\u003c=26;j++) { if(b[i] == a[j]) { x = j; break; } else { x = 0; //这里本来是没有这个else和x的，但是如果不加这个else，会出bug } } cnt = cnt + x; } if(cnt \u003e 100) { cout \u003c\u003c \"INVALID\" \u003c\u003cendl; } else { cout \u003c\u003c cnt \u003c\u003c endl; } } return 0; } 这个吊题目不难，但是需要细心，写出算法用了十分钟，改bug用三十分钟。还问了恺毅同学，他是真的强。 ","date":"2020-11-05","objectID":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/:1:0","tags":null,"title":"每个字母代表一个数字，输出字符串代表的数字之和","uri":"/posts/%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AF%8D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"【题目描述】 从键盘输入一行文本，统计其中数字字符‘0’~‘9’出现的频率并输出。没出现的不需要输出。 【输入格式】 一行文本，长度不超过1000。 【输出格式】 按照从0到9顺序输出统计结果。每个数字的信息占一行，如“0:2”表示数字字符0出现了2次。 For example: Input Result Hello No 007. 0:2 7:1 ","date":"2020-11-05","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:0","tags":null,"title":"统计字符串中字符出现的个数-int与char类型的转换","uri":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"Answer #include \u003ciostream\u003e using namespace std; int main() { char a[9999]; int i,j,cnt; //输入部分 cin.getline(a,9999); //处理部分 for(i=0;i\u003c10;i++) { cnt = 0; char x; x = i + '0'; //这里将i的值从int类型变成char类型，存入x中，不能再存回i中，因为i的类型为int for(j=0;a[j]!='\\0';j++) { if(a[j] == x) { cnt++; } } //输出部分 if(cnt != 0) { cout \u003c\u003c x \u003c\u003c ':'\u003c\u003ccnt\u003c\u003cendl; } } return 0; } ","date":"2020-11-05","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:0","tags":null,"title":"统计字符串中字符出现的个数-int与char类型的转换","uri":"/posts/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-int%E4%B8%8Echar%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题"],"content":"【题目描述】 小明在录入一篇英文文献时由于键盘误操作，事先按下了CapsLock（大写锁定）键，然后又按照平时的录入习惯进行操作。结果录入的内容里面，原本应该是英文大写的地方都变成了小写，而原来应该是英文小写的地方都变成了大写。如果重新录入的话实在太可怕了！ 【输入格式】 任意一个字符串（长度小于等于80），以换行结束。 【输出格式】 转换后的字符串。 For example: Input Result i AM A STUDENT.i AM 19. I am a student.I am 19. ","date":"2020-11-02","objectID":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"大小写字母互换-输入与输出字符串","uri":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { char a[90]; int i=0; cin.getline(a,90); for(i=0;a[i]!='\\0';i++) { if(a[i]\u003e='a' \u0026\u0026 a[i]\u003c='z') { a[i] = a[i] - 32; } else if(a[i]\u003e='A' \u0026\u0026 a[i]\u003c='Z') { a[i] = a[i] + 32; } } puts(a); return 0; } 这题算法很简单，难的是输入与输出，试了很久，最终用这种输入方法可以实现。 发现了几个问题1.网上查的ascii码跟实际程序里的对不上，查ascii码可以用下面这个代码 #include \u003ciostream\u003e using namespace std; int main() { char a[20]; cin.getline(a,90); int i; cout \u003c\u003c a[0] - '0'; return 0; } 2.字符数组可以直接cin»a;和cout«a; ","date":"2020-11-02","objectID":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"大小写字母互换-输入与输出字符串","uri":"/posts/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E4%BA%92%E6%8D%A2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"https://blog.csdn.net/lost_in_jungle_/article/details/82716778 写得针不戳 cin » a; 可以直接输入字符串，但是这个输入貌似很操蛋。 puts这个还蛮好用的； gets在codeblocks里可以用，但是在网页编程上确实用不了；可以用cin.getline(数组名)代替。 ","date":"2020-11-02","objectID":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":null,"title":"字符数组的输入输出","uri":"/posts/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"sort函数的调用需要头文件#include 从小到大排： 例如：a[50]={2,3,5,1,-1},想让它按照从小到大的顺序排列，那么就可以这么写，sort(a,a+5),然后数组就会变成{-1,1,2,3,5}。 具体代码如下： #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; int main() { int i,a[50]={2,3,5,1,-1}; sort(a,a+5);//规定排序的范围 for(i=0;i\u003c5;i++) printf(\"%d \",a[i]); return 0; } 从大到小排： 例如：a[50]={2,3,5,1,-1},想让它按照从大到小的顺序排列，那么就可以这么写，sort(a,a+5,cmp),调用cmp函数,然后数组就会变成{5,3,2,1,-1}。 具体代码如下： #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; bool cmp(int x,int y) { return x\u003ey; } int main() { int i,a[50]={2,3,5,1,-1}; sort(a,a+5,cmp); for(i=0;i\u003c5;i++) printf(\"%d \",a[i]); return 0; } ","date":"2020-11-01","objectID":"/posts/%E7%94%A8sort%E5%87%BD%E6%95%B0%E7%BB%99%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"用sort函数给数组排序","uri":"/posts/%E7%94%A8sort%E5%87%BD%E6%95%B0%E7%BB%99%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"【题目描述】 给出两幅相同大小的黑白图像（用 0表示黑，1表示白）表示，求它们的相似度。说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。 【输入】 第一行包含两个整数 m 和 n，表示图像的行数和列数，中间用单个空格隔开。1≤ m≤ 100, 1≤ n≤ 100。 之后 m 行，每行 n 个整数，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 之后 m 行，每行 n 个整数，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 【输出】 两幅图像的相似度，结果保留小数点后两位。 For example: Input Result 3 3 1 0 1 0 0 1 1 1 0 1 1 0 0 0 1 0 0 1 44.44 ","date":"2020-11-01","objectID":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/:0:0","tags":null,"title":"cout输出精确到小数点后两位","uri":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003ciomanip\u003e using namespace std; int main() { int a[500][500]; int b[500][500]; int m,n,j,k; //输入部分 cin \u003e\u003e n \u003e\u003e m; for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { cin \u003e\u003e a[j][k]; } } for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { cin \u003e\u003e b[j][k]; } } //计算部分 float cnt=0; for(j=1;j\u003c=n;j++) { for(k=1;k\u003c=m;k++) { if(a[j][k]==b[j][k]) cnt++; } } cnt = cnt * 100; //输出部分 cout \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c cnt/(m*n); return 0; } 输出精确的方式： #include cout « fixed « setprecision(2) « a; //其中fixed自动补0，setprecision(2)是精确到小数点后两位 ","date":"2020-11-01","objectID":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/:1:0","tags":null,"title":"cout输出精确到小数点后两位","uri":"/posts/cout%E8%BE%93%E5%87%BA%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D/"},{"categories":["笔记"],"content":"工欲善其事，必先利其器。 看学校官网，关注讲座www.upc.edu.cn 看学院官网，看学术报告，黄岛讲堂，写记录册 computer.upc.edu.cn 关注微信公众号 “石光计E” EI，从图书馆进http://library.upc.edu.cn/html/ziyuan/wwsjk/2014/0620/147.html SCI，图书馆进http://library.upc.edu.cn/html/daohang/syzy/2019/0611/2232.html 中国计算机学会推荐国际学术会议和期刊目录https://www.ccf.org.cn/Academic_Evaluation/By_category/ A刊找综述性文章 A会找最新的文章 中文 雷锋网https://www.leiphone.com 机器之心 www.jiqizhixin.com 中国计算机学会推荐国际学术会议和期刊目录-2019下载 重要-2015-nature-深度学习三巨头写的综述-Deep-learning下载 重要-2017-深度学习的起源-On-the-Origin-of-Deep-Learning下载 ","date":"2020-10-28","objectID":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/:0:0","tags":null,"title":"工欲善其事，必先利其器。","uri":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"},{"categories":["笔记"],"content":"之前的文件 archivetempBN2017年日本演讲下载 2005-12-30-中国的官办经济下载 20201011-第一次组会下载 pythoncourse下载 伟大的中国工业革命——“发展政治经济学”一般原理批判纲要下载 五百年来谁著史：1500年以来的中国与世界 韩毓海下载 智能化设计研究报告v1下载 ","date":"2020-10-28","objectID":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/:1:0","tags":null,"title":"工欲善其事，必先利其器。","uri":"/posts/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"},{"categories":["刷题"],"content":"【题目描述】 判断一个正整数 n 是否能被一个“幸运数”整除。幸运数是指一个只包含 4 或 7 的正整数，如 7、47、477 等都是幸运数，17、42 则不是幸运数。 【输入格式】 一行包含一个正整数 n(1≤n≤1000)。 【输出格式】 一行一个字符串，如果能被幸运数整除输出“YES”；否则，输出“NO”。 For example: Input Result 47 YES ","date":"2020-10-27","objectID":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/:0:0","tags":null,"title":"判断n能否被幸运数整除-do while循环应用","uri":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int n,i,j,flag; cin \u003e\u003e n; for(i=1;i\u003c=n;i++) { j = i; //这里不能直接用i来操作，因为i还要用于循环，不可以更改其值 do { if(j%10==4 j%10==7) { flag = 1; } else { flag = 0; break; } j = j / 10; } while(j); //当不符合条件时跳出循环 if(flag==1 \u0026\u0026 n%i==0) { cout \u003c\u003c \"YES\"; return 0; } } cout \u003c\u003c \"NO\"; return 0; } ","date":"2020-10-27","objectID":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/:1:0","tags":null,"title":"判断n能否被幸运数整除-do while循环应用","uri":"/posts/%E5%88%A4%E6%96%ADn%E8%83%BD%E5%90%A6%E8%A2%AB%E5%B9%B8%E8%BF%90%E6%95%B0%E6%95%B4%E9%99%A4-do-while%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8/"},{"categories":["刷题"],"content":"【题目描述】 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 【输入】 有2行。第1行为1个正整数N ，表示所生成的随机数的个数。第2行有N个用空格隔开的正整数，为所产生的随机数。 【输出】 共2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 For example: Input Result 10 20 40 32 67 40 20 89 300 400 15 8 15 20 32 40 67 89 300 400 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"分析 这题真的困扰了我好久妈了个逼的，一开始我用最基本的语法去写，结果我他妈直接写完报错，我以为是我的算法不够好，就发到唐老师群里求助，结果他说我上课不听课…我也想上他的课呀… 后来我去网上搜，有个人的博客里有这题，他用到了一个set，这个东西我不太清楚是啥，于是翻开我的c++primer去找，但是这本书实在是太专业了，我得把前面的看懂才能彻底搞懂这个东西，而且今天晚上我发现我要想搞懂这本书实在是太难了，我需要付出很多很多时间和精力。而我有更重要的任务去做，比如刷程序设计的题目，比如学习python，我真的不想再自己去碰一鼻子灰了，还是跟着导师的步子来吧。 所以今天晚上，我得明确我的学习线路：1.c++学习听老师的话，就以做题为主，不会的上百度搜，遇到一个点搞懂一个点就行了。2.python学习得跟上进度，提上日程。3.数学的学习也不能落下。4.在寝室里的时候就学学办公软件excel什么的。5.另外，多看看书，了解时局，和历史，最近对中国经济确实挺感兴趣。 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003cbits/stdc++.h\u003e //这玩意是万能头文件 using namespace std; int main() { int n; cin \u003e\u003e n; int x; set\u003cint\u003es; //set可以自动进行排序，默认是从小到大 for(int i=0; i\u003cn; i++) { cin \u003e\u003e x; s.insert(x); //这个有点像python的.append } cout\u003c\u003cs.size()\u003c\u003cendl; for(auto x:s) cout \u003c\u003c x \u003c\u003c' '; return 0; } 其它说明 for(auto i:v) cout«i; 遍历v里面的每一个元素。 begin(); // 返回指向第一个元素的迭代器 end(); // 返回指向迭代器的最末尾处（即最后一个元素的下一个位置） clear(); // 清除所有元素 count(); // 返回某个值元素的个数 empty(); // 如果集合为空，返回true equal_range(); //返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 ","date":"2020-10-26","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:2:0","tags":null,"title":"自动去重和排序","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"【题目描述】 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 【输入】 有2行。第1行为1个正整数N ，表示所生成的随机数的个数。第2行有N个用空格隔开的正整数，为所产生的随机数。 【输出】 共2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 For example: Input 10 20 40 32 67 40 20 89 300 400 15 Result 8 15 20 32 40 67 89 300 400 ","date":"2020-10-24","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:0:0","tags":null,"title":"每日一题-数组去重和排序","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int a[100]; int n,i,j,k; int cnt = 0; //输入数组 cin \u003e\u003e n; for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i]; } //去重 for(i = 0;i\u003cn;i++) { for(j=i+1;j\u003cn;j++) { if(a[i]==a[j]) { cnt++; //cnt为重复个数 //排序1 for(k=i;k\u003cn;k++) { a[k] = a[k+1]; } } } } //排序 int temp; for(i=0;i\u003cn-cnt;i++) { for(j=i+1;j\u003cn-cnt;j++) { if(a[j]\u003ca[i]) { temp = a[j]; a[j] = a[i]; a[i] = temp; } } } //输出数组 cout \u003c\u003c n - cnt - 1 \u003c\u003c endl; for(i=0;i\u003cn-cnt;i++) { cout \u003c\u003c a[i] \u003c\u003c \" \"; } return 0; } ","date":"2020-10-24","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"每日一题-数组去重和排序","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F/"},{"categories":["书影记录"],"content":"本书的目录如下： （一）中国的官办经济–世界上最怪异的经济 （二）官办进出口：从“十个大庆”到八千亿美元外汇储备 （三）官办经济威力初级分析 （四）官办经济–不懂具体经济的老毛同志 （五）官办经济–中国苏联经济模式进阶分析 （六）官办经济–邓小平比拼戈尔巴乔夫 （七）官办经济–“猫摸”二论体现的实验方法与认识态度 （八）官办经济–中国政府的SWOT分析 （九）扯几句闲话，继续SWOT分析 （十）机会与危机 （十一）官办经济运行大法－－网中央的蜘蛛 （十二）“运行大法”的奇异之处 （十三）官办经济之前的改革时期 （十四）大气候，小气候 （十五）从“鸟笼经济”到“官办经济” （十六）邓小平的绝地反击 （十七）政府成了“经济人” （十八）崩溃危机 （十九）转型调控之路 （二十）企业效率问题 （二十一）穷政府 （二十二）气可鼓不可泄 （二十三）穷政府的几大主题 （二十四）毛泽东反全球化 （二十五）靠比较优势发家 （二十六）富政府的“超级现金牛” （二十七）“社会主义大事业”变成了“官办经济” （二十八）官办经济中的“官”与“民” （二十九）往下怎么搞 （三十）自主创新从哪里来 （三十一）从“出口导向”到“扩大内需” （三十二）微观的枷锁 （三十三）当经济增长不再解决问题 （三十四）五个世界 （三十五）邪恶轴心 （三十六）结束语 整体感知 这本书最有特色的地方就是他梳理了建国以来的经济发展历史，从最初的计划经济，到改革开放，中国政府一直把握着中国经济的命脉。中国政府摸爬滚打，自己都没想到自己搞出了这么牛逼的官办经济。中国从建国时的落后且挨打，到现在的富强且强硬，仅仅用了60多年。也介绍了不同时代的不少人物，按时间顺序，给我印象比较深刻的有老毛（毛主席），陈云，周恩来，邓小平，朱镕基，江泽民，胡景涛等等。作者的语言犀利有趣，除了历史课本，我真的很少有机会去了解新中国的野史，为了维护社会稳定，“文革”，“天安门事件”…等等这些事件很少被人们提起。但是作者大胆的叙述，让我大开眼界。现在的我也不再是叛逆的孩子了，看这些野史不是为了猎奇，而是为了更加透彻的洞察咱们社会的本质。到底中国政府是怎么一路走来的？到底我们要成为什么样的人才才是社会主义的可靠建设者和合格接班人？读了这本书，我填补了一部分知识盲区。所以，读这本书给我最大的收获，就是让我系统地了解了中国的经济模式到底是怎么一回事，社会的舆论都很极端和片面，有人在拼命地夸，有人在拼命地骂，我到底该相信谁？读了这本书后我的答案是谁也不相信，中国的经济有它巨大的优势，也有劣势，但总体上确实帮助中国富起来了，强起来了。并且我也了解中国是靠什么强起来的，我总结了两个字“出口”。怪不得中国被称为“世界工厂”，中国有政府作为经济人，劳动力廉价，效率还高，用外资来生产商品之后再卖给外国人，在这个过程中不断吞食产业，妙啊。读完书我才发现中国政府这么有钱，原来腐败是无法避免，且并不完全有害的，我才知道中国在国金经济上原来有这么重要的地位。中国现在提出要保护环境，解决三农问题，进行基础设施建设，改革教育医疗，原来都与经济有关！ 这是第一遍我读下来的感觉，我觉得我只读懂了40%，书中有很多经济术语，政治名词我是看不懂的，就像英语阅读里面有看不懂的单词一样，整体看下来，我大致知道它讲了啥，但是让我具体概括，我是很难用准确语言说出来的。尤其是该书的后半部分，介绍到现代世界部分，更加糊涂了。前面的历史，由于有初高中学过的政治历史作铺垫，容易理解，看起来也挺有意思。这让我不免又感叹，学政治和历史真不是没有用的，越要达到顶尖的高度，就越需要全面的知识。 ","date":"2020-10-19","objectID":"/posts/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AE%98%E5%8A%9E%E7%BB%8F%E6%B5%8E%E8%AF%BB%E5%90%8E%E6%84%9F/:0:0","tags":null,"title":"《中国的官办经济》读后感","uri":"/posts/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AE%98%E5%8A%9E%E7%BB%8F%E6%B5%8E%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["刷题"],"content":"【问题描述】一元二次方程：ax2+bx+c=0 （a ╪ 0） 【输入形式】输入a、b和c的值（有理数） 【输出形式】输出x的两个值，或者No（即没有有理数的解） 【样例输入】1 2.5 3 【样例输出】No 【样例输入】1 -2 1 【样例输出】1.00 1.00 【样例输出说明】输出的两个解保留两位小数，大的在前。 s = input() numLst = s.split(' ') resultLst = map(float,numLst) a,b,c = resultLst import math delta = b**2-4*a*c if delta \u003c 0: print('No') else: x1 = (-b+math.sqrt(delta))/(2*a) x2 = (-b-math.sqrt(delta))/(2*a) if x1 \u003e x2: print(\"%.2f\" % x1,\"%.2f\" % x2) else: print(\"%.2f\" % x2,\"%.2f\" % x1) ","date":"2020-10-19","objectID":"/posts/python-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/:0:0","tags":null,"title":"Python-一元二次方程，保留两位小数","uri":"/posts/python-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/"},{"categories":["刷题"],"content":"【题目描述】 数学课上，楠楠学习了一个新的知识。 两数相除，如果得不到整数商，会有两种情况：一种是得到有限小数，另一种是得到无限小数。从小数点后某一位开始依次不断地重复出现前一个或一节数字的十进制无限小数，叫做循环小数，如2.9666…, (在数学中它读作“二点九六，六循环” ）， 定义循环小数的缩写法是将第一个循环节以后的数字全部略去，并将第一个循环节首末用括号括起来。 例如： 2.966666… 缩写为 2.9(6) 35.232323…缩写为 35.(23) 楠楠发现，根据循环小数的特征，很快能算出这个循环小数中小数点后第n位的数字，你能吗？ 【输入】 共2行。第一行，包含一个整数n(n≤100000)，表示求小数点后的第n位。第二行，一个字符串，用缩写法表示的一个循环小数。 【输出】  一行，包含一个整数，表示循环小数中小数点后第n位的数字。 For example: Input Result 10 352.19(7) 7 ","date":"2020-10-17","objectID":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/:0:0","tags":null,"title":"识别字符","uri":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { char a[100]; int weishu,buxunhuan,xunhuan,m,jieguo1; cin \u003e\u003e weishu ; //输入1 int n=0; cin \u003e\u003e a[0]; while((a[++n]=getchar())!='\\n'); //输入2 int i,left,right,dian; for(i=n;i\u003e0;i--) { if(a[i] == ')') right = i; if(a[i] == '(') left = i; if(a[i] == '.') dian = i; } buxunhuan = left - dian -1; xunhuan = right - left -1; if(weishu \u003c= buxunhuan) { jieguo1 = weishu + dian; cout \u003c\u003c a[jieguo1]; } else { m = (weishu - buxunhuan)%xunhuan; if(m==0) { cout \u003c\u003c a[left + xunhuan]; } else { cout \u003c\u003c a[m+left]; } } return 0; } ","date":"2020-10-17","objectID":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/:1:0","tags":null,"title":"识别字符","uri":"/posts/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6/"},{"categories":["刷题"],"content":"原理在这https://www.bilibili.com/video/BV1k7411q7jo ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"倒序写法 import random def shuffle(lis): for i in range(len(lis) -1,0,-1): p = random.randrange(0,i+1) lis[i],lis[p] = lis[p],lis[i] return lis 这里在random库下定义了一个函数shuffle 之所以是i+1是因为random.randrange()是左闭右开的，不包括i+1 lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) 每次运行这段代码结果应该都是不一样的 ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"正序写法 import random def shuffle(lis): for i in range(0,len(lis) -1,1): p = random.randrange(i,len(lis)+1) lis[i],lis[p] = lis[p],lis[i] return lis lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"实际上在random库中本事提供了这样的函数 这样直接写也是可以的 import random lst = [1,2,2,3,3,4,5,10] random.shuffle(lst) print(lst) ","date":"2020-10-11","objectID":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"Python-洗牌算法","uri":"/posts/python-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"categories":["刷题"],"content":"题目描述】  根据样例在屏幕上输出一个平行四边形，如果每行字母超过了z，则从a重新开始。 【输入】  一行，包含一个整数n（2\u003cn≤26）。 【输出】  见样例。 For example: ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/:0:0","tags":null,"title":"每日一题--a到z26个字母循环输出","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int i,j,k,n; char ch; cin \u003e\u003e n; for(i=0;i\u003cn;i++) { for(k=0;k\u003ci;k++) { cout\u003c\u003c\" \"; } for(j = 0; j\u003cn;j++) { ch = 'a'+ (j + i)%26; cout \u003c\u003c ch; } cout \u003c\u003c endl; } return 0; } ch = ‘a’+ (j + i)%26; 这段代码很有味道，控制了首个字母，以及循环。 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/:1:0","tags":null,"title":"每日一题--a到z26个字母循环输出","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-a%E5%88%B0z26%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA/"},{"categories":["刷题"],"content":"【题目描述】 营业额我叫王大锤，昨天还是一名C++老师。万万没想到，我又失业了。昨天上课前我写的程序让整个学校的电脑中了病毒。为了生计，无可奈何，在学校旁边的唐师傅理发店找了一份兼职。 唐师傅理发店已经开张十年有余，生意红火。唐币是一种专门用来唐师傅营业额的，用int以至于long long int已经无法表示唐师傅的总营业额了。而唐师傅又想要计算自开业以来的总营业额。他给了我两个账本和我的第一个任务，能不能获得这份工作，在此一举！ 每个账本都已经在最后一页写上了这一时期的总营业额，设计一个程序，计算出它们的和。 【输入】 共2行，每行1个正整数(不超过100位)，分别表示每个账本上写着的总营业额（单位：唐币）。 【输出】  一行，包含一个整数，表示总的营业额。 For example: Input Result 1 9 10 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/:0:0","tags":null,"title":"每日一题--有进位的加法运算","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; int main() { int a[110]={0},b[110]={0},c[110]={0}; int i,j,lent,lens,len; char s[110],t[110]; cin \u003e\u003e s \u003e\u003e t; lens = strlen(s); lent = strlen(t); len = max(lens,lent); for(i=lens-1,j=0;i\u003e=0;i--,j++) //将s逆序存储到整型组a中 { a[j] = s[i] - '0'; } for(i=lent-1,j=0;i\u003e=0;i--,j++) //将s逆序存储到整型组a中 { b[j] = t[i] - '0'; } for(i=0;i\u003clen;i++) //进位运算 { c[i] = c[i] + a[i] + b[i]; if(c[i] \u003e 9) { c[i+1]++; c[i] = c[i] % 10; } } if(c[len]!=0) //判断最高位是否进位，即计算结果数据长度是否加1 { len++; } for(i=len-1;i\u003e=0;i--) //逆序输出 { cout \u003c\u003c c[i]; } cout \u003c\u003c endl; return 0; } q1为什么要倒序相加？ 因为两个相加的数字的位数可能不同，倒序之后可以对齐 q2为什么我看不懂一些参数的数值控制，比如len-1… 因为数组是从0开始的，a[0]是第一位，看不懂就自己拿笔写一遍 ","date":"2020-10-10","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/:1:0","tags":null,"title":"每日一题--有进位的加法运算","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%89%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"},{"categories":["刷题"],"content":"【题目描述】 给出n个同学的身高，请根据他们的身高升序排列并输出排序结果。 【输入格式】 第一行包含1个正整数 n（2\u003cn≤100），表示有 n 个同学的身高。 第二行包含 n 个正整数，之间用一个空格隔开，表示 n 个同学的身高。每个同学的身高都在 150~200 厘米之间。 【输出格式】 一行 n 个正整数，之间用一个空格隔开，表示 n 个同学根据身高升序排列的结果。 For example: Input Result 7 180 170 176 160 155 150 160 150 155 160 160 170 176 180 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"每日一题(2)--很多个数排序问题","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["刷题"],"content":"答案 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int i,j,k,n,a[100]; //输入部分 cin \u003e\u003e n; for(i=1;i\u003c=n;i++) { cin \u003e\u003e a[i]; } //输出部分 for(i=1;i\u003c=n;i++) //外层循环i,选出第i位小的数 { k = i; //a[k]是被比较的那个数 for(j=i+1;j\u003c=n;j++) //内层循环，选出第i位之后最小的数 { if(a[j]\u003ca[k]) { k = j; //遇到更小的数，替换a[k] } } if(k!=i) { swap(a[i],a[k]); //把最小数替换到前面 } } //输出部分 for(i=1;i\u003cn;i++) { cout \u003c\u003c a[i] \u003c\u003c \" \"; } cout \u003c\u003c a[n] \u003c\u003c endl; return 0; } 思路：“打擂台”：每一趟把最小的数挑出来放好 第一趟把n个数中最小的数放在第一个位置，第二趟把2到n这n-1个数中挑出最小的放在第二个位置，以此类推 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"每日一题(2)--很多个数排序问题","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982-%E5%BE%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"categories":["笔记"],"content":"【题目描述】 公司举办年会，为了活跃气氛，设置了摇奖环节。参加聚会的每位员工都有一张带有号码的抽奖券。现在，主持人从小到大依次公布 n 个不同的获奖号码，小唐看着自己抽奖券上的号码 win，无比紧张。 【输入格式】 第一行一个正整数n（2\u003cn≤100），表示有n个获奖号码。 第二行包含n个正整数，之间用一个空格隔开，表示依次公布的n个获奖号码。 第三行一个正整数 win，表示小唐抽奖券上的号码。1≤获奖号码，win\u003c10000。 【输出格式】 一行一个整数，如果小唐中奖了，表示中奖的是第几个号码；如果没有中奖，则为 0。 For example: Input Result 7 1 2 3 4 16 27 55 3 3 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/:0:0","tags":null,"title":"每日一题--二分法找数组中的数","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/"},{"categories":["笔记"],"content":"答案 #include \u003ciostream\u003e using namespace std; int main() { int n,i,win,a[100]; cin \u003e\u003e n; //输出部分 for(i=0;i\u003cn;i++) { cin \u003e\u003e a[i]; } cin \u003e\u003e win; int left = 0,right = n-1; //left存放第一个元素下表,right存放最后一个元素的下标 int found = n; //found标记找到的位置，初始化为n,表示没有找到 //二分过程 while(left \u003c= right) { int mid = (left + right)/2; if(a[mid] == win) //找到了标记位置并退出循环 { found = mid; break; } if(win \u003c a[mid]) { right = mid-1; //win只能在左半部分 } else if(a[mid] \u003c win) { left = mid+1; } } //输出部分 if(found !=n) { cout \u003c\u003c found + 1 \u003c\u003c endl; //对应的下标加1输出第几个号码 } else { cout \u003c\u003c 0 \u003c\u003c endl; } return 0; } 注意该案例中数组是从0到n-1定义的，共有n个数 要在编程中考虑到0是第一个数 其实实际编程过程真的不想把0设为第一个数 怪麻烦的 不知道教程为啥要这样写 ","date":"2020-10-08","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/:1:0","tags":null,"title":"每日一题--二分法找数组中的数","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%88%86%E6%B3%95%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0/"},{"categories":["笔记"],"content":"【题目描述】 输入一个正整数 n，求各位上的数字和。 【输入格式】 一行，包含一个正整数 n，n 最多 200 位。 【输出格式】 一行，一个整数，表示正整数 n 的各位数字之和。 #include \u003ciostream\u003e using namespace std; int main() { char a[200]; int i,sum=0; cin \u003e\u003e a ; for(i=0;a[i]!='\\0';i++) { sum = sum + (a[i] - '0'); } cout \u003c\u003c sum \u003c\u003c endl; return 0; } 利用字符数组储存这个超大数 如果a[]是一个字符数组的话，a[i]-‘0’就是a[i]这个字符和‘0’这个字符ASC码的差值,计算结果为整形 利用a[i]!='\\0’来判断字符串是否结束 ","date":"2020-10-07","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B1%82%E8%B6%85%E5%A4%A7%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C/:0:0","tags":null,"title":"每日一题--求超大数的各位数字和","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B1%82%E8%B6%85%E5%A4%A7%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C/"},{"categories":["刷题"],"content":"#include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cctime\u003e using namespace std; int main() { srand((int)time(0)); // 产生随机种子 把0换成NULL也行 int left,right,oper,result; char char_oper; //除了数字oper变量外，还有字符char_oper变量 left = rand() % 10; right = rand() % 10; oper = rand() % 4; //这是加减乘除符号，用0,1,2,3四个数表示 switch(oper) { case 0:char_oper = '+'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left + right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 1:char_oper = '-'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left - right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 2:char_oper = '*'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left * right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; case 3:char_oper = '/'; cout \u003c\u003c left \u003c\u003c char_oper \u003c\u003c right \u003c\u003c \"=\"; cin \u003e\u003e result; if(result == left / right) { cout \u003c\u003c \"YES\"; } else { cout \u003c\u003c \"NO\"; } break; } return 0; } 利用随机数实现非数字变量的随机 0表示+ 1表示- 2表示* 3表示/ 用switch语句实现 这段代码比较巧妙，稍微琢磨一下 ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%87%BA%E9%A2%98%E8%87%AA%E5%8A%A8%E6%89%B9%E6%94%B9/:0:0","tags":null,"title":"每日一题--给小朋友的自动出题自动批改","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%87%BA%E9%A2%98%E8%87%AA%E5%8A%A8%E6%89%B9%E6%94%B9/"},{"categories":["刷题"],"content":"【题目描述】 输入一个正整数 n，输出 n×n 的回型方阵。例如，n=5 时，输出： 1 1 1 1 1 1 2 2 2 1 1 2 3 2 1 1 2 2 2 1 1 1 1 1 1 【输入格式】 一行，包含一个正整数 n，2≤n≤9。 【输出格式】 共 n 行，每行包含 n 个正整数，之间用一个空格隔开。 ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:0:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"答案1 先给左上角负值，再通过下标的对称性复制到左下角，右上角，右下角 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int n,i,j,a[10][10]; cin \u003e\u003e n; for(i=1;i\u003c=(n+1)/2;i++) //只写入整个数组的四分之一，多出四分之一的部分无所谓 { for(j=1;j\u003c=(n+1)/2;j++) //i控制行数，j控制列数 { a[i][j] = min(i,j); //min函数引用了algorithm库,i和j中较小的那个值恰好是需要写入的值 a[i][n+1-j] = a[n+1-i][j] = a[n+1-i][n+1-j] = a[i][j]; //左右对称，上线对称，对角线对称 } } for(i=1;i\u003c=n;i++) //输出部分 { for(j=1;j\u003c=n-1;j++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \"; } cout \u003c\u003c a[i][n] \u003c\u003c endl; //最后一个输出单独写，因为空格 } return 0; } ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:1:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"答案2 通过“一圈一圈”赋值的方法做，先给a[1][1]到a[n][n]全部赋值1，然后给a[2][2]到a[n-1][n-1]全部赋值2，……共n/2圈（如果n是奇数，则最后一圈就是一个数） #include \u003ciostream\u003e using namespace std; int main() { int n,i,j,k,a[10][10]; cin \u003e\u003e n; for(k=1;k\u003c=(n+1)/2;k++) //输入部分，看不懂就另n=5,k=1,k=2,i=1,i=1,j=1,j=2演算一遍 { for(i=k;i\u003c=n+1-k;i++) { for(j=k;j\u003c=n+1-k;j++) { a[i][j] = k; } } } for(i=1;i\u003c=n;i++) //输出部分 { for(j=1;j\u003c=n-1;j++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \"; } cout \u003c\u003c a[i][n] \u003c\u003c endl; } return 0; } ","date":"2020-10-06","objectID":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:2:0","tags":null,"title":"每日一题--二维数组","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["笔记"],"content":"总体感受 这是我跟着b站昕哥的视频学习\"Python数据分析“的第二周，总体上感觉Python确实是比c++要简单不少，学c++就像是开手动挡汽车，虽然难学，但是学会之后可以享受操纵的乐趣。而学Python就像是开手动挡汽车，简单上手，也功能强大。 和以前在网上自学其它东西不一样的是，这次学习Python，我有一个团队陪我一起，虽然团队的成员不太听我的话，但是我乐在其中，有什么麻烦的问题被解决了，我会发自内心地想要分享出来，不管是否对别人有所帮助，我都要满足我装逼的心理。 ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:1","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["笔记"],"content":"已经学到的东西 在第一章里，大致了解了Python这门语言，知道了它是解释型语言，是一门高级语言(虽然这些我之前就知道)。解释型语言我之前也接触过类似的，比如超文本标记语言html5，虽然只是浅尝辄止，但是接触过和没接触过的区别就是1和0之间的区别。毕 竟 0 的 无 数 倍 都 比 不 上 1 。 第二章，就比较枯燥乏味了，学的是基本数据类型。要记忆的东西很多，我也开始做笔记了。我的学习方法是，先看一遍视频，把知识点都截图在笔记里，然后照着笔记把所有代码都打一遍，如果遇到看不懂的地方，就打开视频把那一块再看一遍。这样，我大部分知识点仍然是记不住，但是在我脑海里会有个印象，当我在做练习时，我想实现某个功能时，我就能想到那条语句，然后把笔记调出来，再看一遍笔记，把知识点用在实战中，一次两次就能记清楚了。 还学到了其它东西: 我还捯饬了半天搞了个博客，又弄了个域名 我还发信息有道云笔记贼好用 我还在想办法搞定Latex ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:2","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["笔记"],"content":"未来的目标 总感觉没做什么时间就不够了，时间够了精力又不够了，时间精力够时我又感觉很懒，想打game，想看动漫，想出去喝酒，不想敲代码，不想学习，不想动脑子，反正在这里也没人管我。 但是不行啊，放弃是最简单的事情，还是坚持下去吧。 ","date":"2020-10-04","objectID":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/:0:3","tags":null,"title":"Python第二周学习报告（草稿）","uri":"/posts/python%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E8%8D%89%E7%A8%BF/"},{"categories":["刷题"],"content":"修改pip源： https://jingyan.baidu.com/article/b24f6c8296b507c6bee5da4f.html 修改jupyter默认目录： 在jupyter中键入 !jupyter notebook –generate-config 这样会在c盘的用户文件中写入一个叫jupyter_notebook_config.py的配置文件 在c盘用户文件夹中找到.jupyter目录 找到刚写入的文件jupyter_notebook_config.py 可以用IDLE打开，上面菜单栏有edit\u003efind查找工具 （用其他编辑器如记事本啥的应该都行） 找到#c.NotebookApp.notebook_dir =’ ‘去掉注释后，在‘ ’中输入你想启动目录路径 注意目录的格式中的”\\”要改成”\\”否则jupyter无法运行。 以上步骤做完后，需要更改快捷方式的位置，找到Jupyter的快捷方式，右键打开属性，将快捷方式中“目标”中的”%USERPROFILE%”去掉。(引号也要去掉) 再启动服务器进入页面，就成功了 qwq搜索了好多教程，每个教程都是不能成功，综合在一起捯饬了半天才总结如上方法qwq ","date":"2020-09-30","objectID":"/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/:0:0","tags":null,"title":"第一章练习题","uri":"/posts/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":null,"content":"简历 教育背景 2020.09至今：中国石油大学（华东）（青岛、211、双一流）计算机科学与技术专业 综合成绩：91.29｜专业排名：1/20｜四/六级已过 研究方向：数据压缩、可视化、人工智能等 荣誉奖项 荣获2020-2021 学年及2021-2022 学年综合优秀一等奖学金 2022-2023 学年综合优秀二等奖学金 荣获 2021-2022 学年及 2022-2023 学年社会工作奖学金 荣获中国石油大学（华东）优秀毕业生称号 荣获2020-2021 学年优秀学生称号 荣获 2021-2022 学年及 2022-2023 学年优秀学生干部称号 荣获2023 年优秀共青团员称号 2021 年被评为优秀学生社团会员 项目竞赛 第十八届全国大学生智能汽车竞赛全国总决赛一等奖，2023 中国高校计算机大赛 2023 网络技术挑战赛华东赛区二等奖，全国总决赛三等奖，2023 2023 年美国大学生数学建模竞赛 HonorableMention 奖，2023 第十三届中国大学生服务外包创新创业大赛区域赛二等奖，全国总决赛三等奖，担任组长，2022 大学生创新创业训练项目优秀结题，担任组长，2023 发表论文 【1】Xin Li, Zhikuan Wang, Chenglizhao Chen, Chunfeng Tao, Yuanbo Qiu, Junde Liu and Baile Sun. SemID : Blind Image Inpainting with Semantic Inconsistency Detection[J]. 2023. Tsinghua Science and Technology. 【2】Xin Li, Baile Sun, Jixiu Liao, and Xiaofei Zhao. 2023. Remote Sensing Image Compression Method Based on Implicit Neural Representation. In 2023 12th International Conference on Computing and Pattern Recognition (ICCPR 2023), October 27–29, 2023, Qingdao, China. ACM, New York, NY, USA, 8 pages. https://doi.org/10.1145/3633637.3633706 发明专利 【1】李昕,孙百乐,王文婕等. 一种基于docker和jupyter notebook的复合类型题目在线检测方法[P]. 山东省：CN115145805A,2022-10-04. 【2】李昕,王志宽,刘航源,孙百乐. 一种基于语义不一致性检测的图像盲修复方法[P]. 山东省：CN114897738A,2022-08-12. 【3】孙百乐,王文婕,廖集秀,徐朔. 一种基于 YOLOv5 和 PaDiM 的主板缺陷检测方法[P]. (已通过初审，未公布) 掌握技术 前端： Vue：较熟悉，多次在竞赛和课程作业中使用Vue开发前端页面 微信小程序：较熟悉，为导师课题组开发过一套日志小程序，开发和使用超过1年 QT：一般熟悉，做过小型项目 后端： Flask：较熟悉，多次在竞赛和课程作业中使用Flask开发后端 Django：一般熟悉，使用Django+MySQL开发过一整套OnlineJudge网站 PHP：简单了解，修改过实际项目中的代码 运维： Linux：较熟悉，熟悉 Linux 的基本命令，曾担任Linux自由软件协会会长，组织各项事务，教授社团课程 Nginx：较熟悉，会使用配置文件进行端口转发，反向代理等 Docker：一般熟悉，在竞赛中使用过，会使用docker容器，会用Dockerfile创建docker容器等 人工智能： Pytorch：较熟悉，在科研中常使用 图形学： OpenGL：一般熟悉，系统学习过课程，做过大作业 写作： 会写专利，已成功撰写 2 篇 性格爱好 性格沉稳、开朗、乐观、谦和、上进心强、人际交往能力良好、沟通表达能力良好、团队协作能力良好。 爱好读书，旅游，看电影。 关于该博客 2022年初寒假，使用hugo+Lovelt+github+jsdelivr打造此博客，用于学习和记录学习。欢迎留言～ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"书影记录 ","date":"0001-01-01","objectID":"/bookshelf/:0:0","tags":null,"title":"","uri":"/bookshelf/"},{"categories":null,"content":"记录上大学后读过的书 以前没有写读书笔记的习惯，以后一定要养成写读书笔记的习惯！💪 书名 作者 简介 读书笔记 备注 《罗生门》 芥川龙之介 既然是为了生存，还有什么不可以的？ 2021.6～8 《浮生六记》 沈复 古人伉俪情深的生活记叙 2021.6～8 《阿Q正传》 鲁迅 旧时代愚钝腐朽的中国人 2021.6～8 《老人与海》 海明威 永不向命运低头的硬汉精神 2021.6～8 《围城》 钱钟书 旧知识分子，旧婚姻 2021.6～8 《边城》 沈从文 描绘湘西地区特有的风土人情 2021.6～8 《动物农场》 乔治·奥威尔 反乌托邦政治讽喻寓言 2021.9～ 《中国的官办经济》 陈经 看江湖派如何解说中国经济 《中国的官办经济》读后感 2020 《他改变了中国》 罗伯特·劳伦斯·库恩 西方人笔下的中国领导人 2020 《一往无前》 范海涛 小米的血泪奋斗史 2020 《乖，摸摸头》 大冰 爱与温暖的故事 2020 《京华烟云》 林语堂 超喜欢木兰 《京华烟云》读后有感 2020 《王阳明传》 梅韩 “此心光明，亦复何言” 2020 《如何阅读一本书》 莫提默·J·艾德勒/查尔斯·范多伦 教你学会读书的一本书 《如何阅读一本书》读后感 2021 《小王子》 圣埃克苏佩里 当我不开心的时候就会去读这本书 2021 《消失的13级台阶》 高野和明 很好看的日本推理小说 《消失的13级台阶》读后感 2021 《盗墓笔记》1、2 南派三叔 惊险刺激的冒险小说 2021 《人类简史》 尤瓦尔·赫拉利 从人类的角度去认识历史，书中观点很新颖很有趣，值得一看！ 《人类简史》读后有感 2021 《共产党宣言》 马克思、恩格斯 全世界无产者，联合起来！ 2021 《堂吉诃德》 塞万提斯 中二病始祖堂吉诃德的冒险故事 2021 《房思琪的初恋乐园》 林奕含 悲伤的女性题材的著作 2021 《史蒂夫·乔布斯传》 沃尔特·艾萨克 果粉必读，中立、客观。很多经典句子的出处 《史蒂夫·乔布斯传》读书笔记 2021 《百年孤独》 马尔克斯 把拉丁美洲的血泪史融入一个家族100年的兴亡当中 2022 《撒哈拉的故事》 三毛 前半段日常非常有趣，后半段主线剧情。三毛的文笔让人看了就爱❤️ 2022 《明天也是小春日和》 津端英子/津端修一 讲了两位日本老人的田园生活。很治愈 《明天也是小春日和》：那并不耀眼的初冬暖阳，恰似你日复一日最长情的陪伴 2022 《雪国》 川端康成 感伤的东方美，以及男人的怪癖 《雪国》读书笔记 2022.2.12 《湖》 川端康成 人生无常，万事皆空 2022.2.15 《学术研究你的成功之道》 凌晓峰、杨强 读研或读博前看到这本书感觉很幸运 2022.2.20 《邓小平时代》 傅高义 改革开放的总设计师 《邓小平时代》——改革开放的总设计师 2022.3.18 《秒速五厘米》 新海诚 樱花🌸下落的速度是秒速五厘米，我该以什么速度才能靠近你? 2022.3.23 《失乐园》 渡边淳一 性教育启蒙 《失乐园》读后有感 2022.4.13 《无人生还》 阿加莎·克里斯蒂 剧透（误）：最后所有人都死了 《无人生还》读后有感 2022.4.30 《从零开始的女性主义》 上野千鹤子、田房永子 更正你对女权主义的误解 《从零开始的女性主义》读后有感 2022.5.6 《挪威的森林》 村上春树 哪会有人喜欢孤独，只不过不想失望罢了 2022.5.31 《论人类不平等的起源和基础》 卢梭 就没有私有制，就没有伤害 2022.6.8 《写给大家看的设计书》 Robin Williams 生活就要设计 《写给大家看的设计书》读书笔记 2022.6.13 《我的天才女友》 埃莱娜·费兰特 “赛鲁罗小时候头脑的聪慧没有找到出口，格雷科，最后她的美都展现在脸蛋和胸上，还有大腿和屁股上——那些美在这些地方都会昙花一现，就像从来没拥有过一样。” 2022.6.30 《乡土中国》 费孝通 中国乡土社会传统文化和社会结构理论研究的代表作之一 《乡土中国》读书笔记 2022.7.7 《鞑靼人的沙漠》 迪诺·布扎蒂 当觉得虚度时光的时候看这本书 2022.8.23 《程序员的自我修养——链接、装载与库》 俞甲子、石凡、潘爱民 深入理解程序是如何运行的（没啃完，因为后面太硬核了） 2022.9.14 《我的奋斗（给彪悍的人生一个解释）》 罗永浩 一个极具个性又很有思想的胖子的30岁自传 2022.10.31 《悉达多》 赫尔曼·黑塞 人生就是在不断的体验与感悟 《悉达多》—人生就是在不断的体验与感悟 2022.11.12 《一个无政府主义者的意外死亡》 达里奥·福 2022.12 《肠子的小心思》 朱莉娅·恩德斯 任何人都可以读的有关肠子的医学科普书 《肠子的小心思》——读书笔记 2023.1.28 《海边的卡夫卡》 村上春树 做世界上最顽强的15岁少年 2023.3.19 《1984》 乔治·奥威尔 反乌托邦三部曲之一 2023.4 《蒂凡尼的早餐》 杜鲁门·卡波特 我希望有一天早上醒来在蒂凡尼吃早饭时、我仍旧是我。 2023.5.30 《乡村教师》 刘慈欣 用科幻的方式赞颂人类文明的传播者 2023.6.8 《坍缩》 刘慈欣 非常有趣 2023.6.8 《微纪元》 刘慈欣 生命的进化趋势是向小的方向 2023.6.9 《梦之海》 刘慈欣 艺术+科幻 2023.6.10 《思想者》 刘慈欣 2023.6.11 《长安的荔枝》 马伯庸 优秀的历史改编小说 2023.7.3 《天龙八部》壹 金庸 段誉传 2023.8.25 《孽子》 白先勇 从青少年的视角描绘被歧视的同性恋 2023.9.26 《球状闪电》 刘慈欣 大刘真的牛，这想法太绝了 2023.10 《置身事内》 兰小欢 客观科普我国当前的经济现状 《置身事内》读书笔记 2023.12.11 《永恒的终结》 阿西莫夫 人类真的能存活到10万世纪吗？ 2023.1.15 ","date":"0001-01-01","objectID":"/bookshelf/:1:0","tags":null,"title":"","uri":"/bookshelf/"},{"categories":null,"content":"记录看过的电影（部分） 影片名 简评 观后感 备注 87版红楼梦 王熙凤，林黛玉，贾宝玉…永恒的经典 87《红楼梦》观之有感 大二军训时候看的 菊次郎的夏天 我觉得这个片子真的好好笑哈哈哈。 《菊次郎的夏天》观后感 新喜剧之王 星爷～ 《新喜剧之王》观后感 华尔街之狼 看看资本主义暴发户的腐烂生活 《华尔街之狼》观后感 大一寒假 十二公民 讲述了当代中国一个由富二代“杀人案”引发了最为激烈的法庭智斗的故事。 《十二公民》观后感 唐人街探案1 很不错的电影，喜剧搞笑、悬疑够劲儿、演员颜值也能打 怒火重案 是男人就看怒火重案 甲方乙方 “地主家也没有余粮呀～” 哈利·波特与魔法石 老少皆宜的童话故事 who am i 德国黑客（指物理和心理黑客）电影 入殓师 奥斯卡金像奖，08年在日本上映，21年在中国上映，可能中国也要正视老龄化问题了吧 英雄联盟：双城之战 豆瓣9.1分，绝对不辜负撸友的期待 速度与激情1 经典，不解释 色，戒 汤唯真好看～ 小姐 아가씨 女同片，非常魔幻 误杀2 我觉得很好看，不知道为什么评价这么低 2022.1.20 误杀1 还是去看误杀2吧 2022.1.21 半泽直树 最强打工人！很好看的日剧 《半泽直树》观后有感 长津湖之水门桥 吴京、易洋千玺打美国鬼子 鬼灭之刃 立志篇 背着妹妹去杀鬼～ 大二下学期初 模仿游戏 天才总是孤独的 2022.2.28 心灵奇旅 你找到你生命的“火花”了吗？ 2022.3.4 泰坦尼克号 杰克和露丝的爱情故事❤️，永远的经典～ 2022.3.12 蝙蝠侠 民风淳朴哥谭市 2022.3.18 叶问 我要打十个！👊 2022.3.25 投名状 你以为是武打戏，其实是政治戏、感情戏！ 2022.4.4 师父 南蛮子闯天津 2022.4.24 教父1 我将给他一个他无法拒绝的理由 2022.5.15 超级战舰 美国解放军打外星人。 2022.6.2 源代码 低成本拍摄，高成本编剧 2022.7.18 人生大事 “人生啊，就像一本书，哪个都要画到最后一页，有的人画上的是句号，有的人画上的是省略号。” 2022.7.20 独行月球 搞笑片还得看开心麻花👍 2022.7.30 神探大战 我愿称之为警匪片中的魔幻现实主义 2022.8.3 盗梦空间 大为震撼 2022.8.16 银行大劫案 根据现实改编，可现实就是这么荒诞😂 2022.9.18 午夜凶铃 美版贞子 2022.11.26 咒怨 跟彤彤一起看不害怕 2022.11.29 寂静之地 2022.12.1 爱乐之城 2022.12.2 超脱 是致郁，也是治愈 2022.12.17 鱿鱼游戏 人性 2023.1.3 满江红 悬疑、典故、明星加搞笑，张艺谋是懂流量密码的。别管有人骂，片子还是值得看的 2023.1.28 流浪地球2 中国科幻的顶峰之作🐮 2023.2.27 中国乒乓之绝地反击 很热血，是好看的呀！ 2023.3.24 欢乐颂4 2023.4 狂飙 高启强与安欣斗智斗勇，真的好好看 2023.5 沉默的羔羊 不错 2023.6.4 毒舌律师 法律+悬疑+人性，好好看 2023.6.25 孤注一掷 一部拍的非常好的反诈题材剧情片 2023.8.9 坚如磐石 还不错的国产官商勾结犯罪片 2023.9 美国往事 once upon a time in American 2023.10 史蒂夫乔布斯 2024.1 ","date":"0001-01-01","objectID":"/bookshelf/:2:0","tags":null,"title":"","uri":"/bookshelf/"}]
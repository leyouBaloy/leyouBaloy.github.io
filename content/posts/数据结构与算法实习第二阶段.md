---
title: "æ•°æ®ç»“æ„ä¸ç®—æ³•å®ä¹ ç¬¬äºŒé˜¶æ®µ"
author: å­™ç™¾ä¹
date: 2022-07-02T15:38:13+08:00
draft: false
categories: 
- åˆ·é¢˜
- ç¬”è®°
---



## 7-2 åˆ†è€Œæ²»ä¹‹

**çŸ¥è¯†ç‚¹**ï¼šå›¾è®º

**æ€è·¯**ï¼š

* æ€è·¯ä¸€ï¼šè®°å½•é‚»æ¥çŸ©é˜µï¼Œè¾“å…¥æ—¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æ•°ã€‚è¢«æ‘§æ¯çš„åŸå¸‚çš„åº¦ç½®ä¸º0ï¼Œå’Œå®ƒç›¸é‚»çš„ç‚¹åº¦ä¹Ÿ-1ã€‚æœ€åæ£€æŸ¥æ˜¯å¦æœ‰åº¦å¤§äº0çš„ç‚¹ï¼Œæœ‰å°±è¯´æ˜æœ‰åŸå¸‚ç›¸è¿é€šï¼Œè¾“å‡ºNOï¼Œå¦åˆ™è¾“å‡ºYESï¼›
* æ€è·¯äºŒï¼šè®°å½•æ‰€æœ‰çš„è¾¹(u, v)ï¼Œå’Œè¢«æ”»é™·åŸæ± lost[i]ã€‚éå†è¾¹(u, v)ï¼Œå¦‚æœå­˜åœ¨uæˆ–væ²¡æœ‰è¢«æ”»é™·ï¼ˆå³ä¸åœ¨losté‡Œé¢ï¼‰ï¼Œè¯´æ˜æœ‰åŸå¸‚è¿é€šï¼Œè¾“å‡ºNOï¼Œå¦åˆ™YESï¼›

å› ä¸ºè¿™é¢˜æœ€å¤šæœ‰10005ä¸ªç‚¹ï¼Œä½¿ç”¨é‚»æ¥çŸ©é˜µä¼šè¶…å†…å­˜ï¼Œæ‰€ä»¥é‡‡ç”¨ç¬¬äºŒç§æ€è·¯ï¼›

**ç»†èŠ‚**ï¼š

* è®°å½•è¾¹å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæ•°ç»„`u[10005]`å’Œ`v[10005]`ï¼Œç¬¬`i`æ¡è¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯`u[i]`å’Œ`v[i]`
* åˆ¤æ–­è¾¹ä¸­æ˜¯å¦åŒ…å«æ²¡è¢«æ”»é™·çš„åŸæ± `if( !lost[u[i]] && !lost[v[i]] )`

**ä»£ç **ï¼š

```c++
#include <iostream>;
using namespace std;

class Citys {
public:
    int N, M;
    int u[10005]={0};
    int v[10005]={0}; // ç¬¬ i æ¡è¾¹ä¸º (u[i], v[i])
    void insertPath(); // è¾“å…¥è·¯å¾„
    bool isValid(); // è¾“å…¥ä¸€ä¸ªæ–¹æ¡ˆï¼Œåˆ¤æ–­æ˜¯å¦æœ‰æ•ˆ
    Citys();
};

Citys::Citys() {
    cin >> N >> M;
}

void Citys::insertPath() {
    for(int i=0; i<M; i++){
        cin >> u[i] >> v[i];
    }
}

bool Citys::isValid() {
    // è¾“å…¥æ”»ç ´çš„åŸæ± 
    int Np; cin >> Np;
    int lost[10005] = {0};
    for( int i=0; i<Np; i++ ){
        int city; cin >> city;
        lost[city] = 1;
    }
    // åˆ¤æ–­
    for( int i=0; i<M; i++ ){
        if( !lost[u[i]] && !lost[v[i]] ){ // å¦‚æœéƒ½ä¸æ˜¯è¢«æ”»é™·çš„åŸæ± 
            return false;
        }
    }
    return true;

}
int main() {
    // è¾“å…¥æ•°æ®
    Citys citys = Citys();
    citys.insertPath();
    int K; cin >> K;
    for( int i=0; i<K; i++ ){
        if( citys.isValid() ) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
  
    return 0;
}

```

## 7-3 é‚£å°±åˆ«æ‹…å¿ƒäº†

**çŸ¥è¯†ç‚¹**ï¼šdfsã€æ—¶é—´å¤æ‚åº¦

**æ€è·¯**ï¼šæŠ½è±¡ä¸€ä¸‹ï¼šç»™å®šä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œå¹¶ä¸”ç»™å‡ºèµ·ç‚¹Aå’Œç»ˆç‚¹Bï¼Œé—®ä»Aå‡ºå‘çš„æ‰€æœ‰è·¯å¾„æ˜¯å¦éƒ½èƒ½åˆ°è¾¾Bï¼Œå¹¶ä¸”æ±‚å‡ºä»Aå‡ºå‘åˆ°è¾¾Bçš„ä¸åŒè·¯å¾„æœ‰å¤šå°‘æ¡ã€‚ç¬¬ä¸€ä¸ªé—®é¢˜éå¸¸å¥½è§£ï¼Œåªè¦ä»Aå¼€å§‹DFSï¼Œå¦‚æœæœåˆ°æŸä¸ªå‡ºåº¦ä¸º0çš„ç‚¹ï¼Œå¹¶ä¸”è¿™ä¸ªç‚¹ä¸æ˜¯é¢˜é¢ç»™å‡ºçš„Bç‚¹ï¼Œå°±è¯´æ˜å¹¶ä¸æ˜¯æ‰€æœ‰ä»Aå‡ºå‘çš„è·¯å¾„éƒ½èƒ½åˆ°è¾¾Bã€‚å¯¹äºç¬¬äºŒä¸ªé—®é¢˜ï¼Œè™½ç„¶è¿™é“é¢˜æ•°æ®æ¯”è¾ƒå°ï¼Œæœ€å¤šåªæœ‰500ä¸ªç‚¹ï¼Œä½†æ˜¯è¿™é¢˜çš„æ—¶é—´é™åˆ¶æ˜¯400msï¼Œå¯¹äºæ±‚è§£ä¸åŒè·¯å¾„çš„é—®é¢˜ï¼Œå¦‚æœæš´åŠ›æœç´¢çš„è¯æ˜¯ä¸€å®šä¼šè¶…æ—¶çš„ã€‚

è€ƒå¯Ÿè¾“å…¥æ ·ä¾‹1:

```
7 8
7 6
8 5
6 5
5 2
5 3
2 1
3 1
7 1
```



![7-3 é‚£å°±åˆ«æ‹…å¿ƒäº†é¢˜è§£DAG](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg)

å¾ˆæ˜æ˜¾ï¼Œä»7åˆ°1æœ‰å¦‚ä¸‹è·¯å¾„ï¼š

```
7 -> 6 -> 5 â€”> 2 -> 1
7 -> 6 -> 5 -> 3 -> 1
7 -> 8 -> 5 -> 2 -> 1
7 -> 8 -> 5 -> 3 -> 1
```

å‘ç°ï¼Œä»5åˆ°1æœ‰ä¸¤æ¡è·¯å¾„ã€‚åœ¨æœç´¢æ—¶ï¼Œç»è¿‡7ï¼Œ6ï¼Œ5ï¼Œä¼šæŠŠè¿™ä¸¤æ¡è·¯å¾„éƒ½æœç´¢ä¸€éï¼›ç»è¿‡7ï¼Œ8ï¼Œ5ï¼Œåˆä¼šæŠŠè¿™ä¸¤æ¡è·¯å¾„æœç´¢ä¸€éã€‚è¿™æ ·å°±é€ æˆäº†æ—¶é—´çš„æµªè´¹ã€‚æˆ‘ä»¬è€ƒè™‘ï¼Œå¦‚æœåœ¨ç»è¿‡6å·èŠ‚ç‚¹åˆ°è¾¾5å·èŠ‚ç‚¹ï¼Œå†åˆ°è¾¾ç»ˆç‚¹1å·èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„å…¨éƒ¨æœç´¢å®Œæ—¶ï¼Œ5å·èŠ‚ç‚¹èƒ½å¤Ÿå‚¨å­˜ä¸‹â€œç»è¿‡è¯¥èŠ‚ç‚¹æœ‰2æ¡è·¯å¾„åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹â€è¿™ä¸ªä¿¡æ¯ï¼Œè¿™æ ·åœ¨ä»8å·èŠ‚ç‚¹æœç´¢åˆ°5å·æ—¶ï¼Œå°±ä¸éœ€è¦å†é‡å¤åœ°å°†æ¥ä¸‹æ¥çš„è·¯å¾„å…¨éƒ¨æœç´¢ä¸€éäº†ï¼Œç›´æ¥ä»5å·èŠ‚ç‚¹è¯»åˆ°â€œæ¥ä¸‹æ¥æœ‰2æ¡ä¸åŒçš„è·¯å¾„â€è¿™ä¸ªä¿¡æ¯ã€‚æ­£å¥½ï¼ŒDFSçš„â€œèµ°åˆ°åº•å†è¿”å›â€çš„æ€§è´¨å¯ä»¥åšåˆ°ä»å°¾åˆ°å¤´ï¼Œä¹Ÿå°±æ˜¯ä»ç»ˆç‚¹åˆ°èµ·ç‚¹è®°å½•ä¿¡æ¯ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨DFSçš„è¿‡ç¨‹ä¸­è¿›è¡Œè®°å¿†åŒ–æ“ä½œã€‚

æˆ‘ä»¬å®šä¹‰`step[i]`ä¸ºâ€œä»`i`å·èŠ‚ç‚¹åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„æ¡æ•°â€œï¼Œæ±‚è§£çš„ç›®æ ‡æ˜¯`step[A]`ï¼Œå®šä¹‰`step[B] = 1`ï¼Œå¹¶ä¸”æ ‡è®°ğµBèŠ‚ç‚¹å·²ç»è¢«è®¿é—®è¿‡ã€‚åœ¨DFSçš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå°†è¦æœç´¢çš„èŠ‚ç‚¹æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼Œå°±æœç´¢ï¼Œå¹¶è®°å½•ä¸‹è·¯å¾„æ¡æ•°ï¼Œå½“å‰èŠ‚ç‚¹ç›´æ¥åŠ ä¸Šå¾…æœç´¢ï¼ˆå…¶å®è¿™æ—¶å€™å·²ç»æœç´¢å®Œäº†ï¼‰çš„èŠ‚ç‚¹çš„è·¯å¾„æ¡æ•°ã€‚ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼ŒDFSçš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

1. åˆå§‹åŒ–`step[]`æ•°ç»„ä¸º0ï¼Œåˆå§‹åŒ–`vis[]`æ•°ç»„ä¸º**false**ï¼Œèµ‹å€¼`step[1]=1`, `vis[1]=true`;
2. ä»èµ·ç‚¹7å¼€å§‹DFSï¼Œèµ‹å€¼`vis[7]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢6ï¼Œ`vis[6]==false`ï¼Œè¿›å…¥ï¼›
3. ä»6èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[6]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢5ï¼Œ`vis[5]==false`ï¼Œè¿›å…¥ï¼›
4. ä»5èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[5]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢2ï¼Œ`vis[2]==false`ï¼Œè¿›å…¥ï¼›
5. ä»2èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[2]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢1ï¼Œ`vis[1]==true`ï¼Œä¸è¿›å…¥ï¼›ç´¯åŠ è·¯å¾„æ¡æ•°`step[2]=step[2]+step[1]`ï¼Œè¿™æ—¶`step[2]=1`ã€‚2èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›ï¼Œ`step[5]=step[5]+step[2]`,æ­¤æ—¶`step[5]=1`
6. æ¥ä¸‹æ¥æƒ³æœç´¢3ï¼Œèµ‹å€¼`vis[1]==true`ï¼Œä¸è¿›å…¥ï¼›ç´¯åŠ è·¯å¾„æ¡æ•°`step[3]=step[3]+step[1]`ï¼Œè¿™æ—¶`step[3]=1`ã€‚3èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›,`step[5]=step[5]+step[3]`,æ­¤æ—¶`step[5]=2`
7. 5èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›ï¼Œ`step[6]=step[6]+step[5]`ï¼Œæ­¤æ—¶`step[6]=2`.
8. 6æ²¡æœ‰å…¶å®ƒèŠ‚ç‚¹äº†ï¼Œè¿”å›7ï¼Œ`step[7]=step[7]+step[6]`ï¼Œæ­¤æ—¶`step[7]=2`ã€‚ç»§ç»­æœç´¢8ã€‚
9. ä»8å¼€å§‹DFSï¼Œèµ‹å€¼`vis[8]=true`ï¼Œæ¥ä¸‹æ¥åˆæƒ³æœç´¢5ï¼Œ`vis[5]=true`ï¼Œä¸è¿›å…¥ï¼Œ`step[8]=step[8]+step[5]`ï¼Œæ­¤æ—¶`step[8]=2`ï¼›
10. æ²¡æœ‰å…¶å®ƒè·¯å¾„äº†ï¼Œè¿”å›7ï¼Œ`step[7]=step[7]+step[8]`ï¼Œæ­¤æ—¶`step[7]=4`ã€‚æ²¡æœ‰å…¶å®ƒèŠ‚ç‚¹äº†ï¼Œé€’å½’ç»“æŸã€‚

**ç»†èŠ‚**ï¼š

* è·¯å¾„ä½¿ç”¨é‚»æ¥çŸ©é˜µå­˜å‚¨ï¼ˆé‚»æ¥è¡¨æ›´èŠ‚çœç©ºé—´ï¼Œä½†å› ä¸ºä¸èƒ½ä½¿ç”¨`vector`ï¼Œæ‰€ä»¥é‚»æ¥è¡¨å®ç°èµ·æ¥ä¼šéº»çƒ¦ä¸€ç‚¹ï¼‰
* åˆ¤æ–­èƒ½å¦â€œé€»è¾‘è‡ªæ´½â€ï¼šå‡ºåº¦ä¸º0ä¸”è¯¥èŠ‚ç‚¹ä¸æ˜¯ç»ˆç‚¹ï¼Œä»¤å…¨å±€å˜é‡`isLogic`

dfsçš„è¿‡ç¨‹ç”¨ä»£ç å®ç°ï¼š

```c++
void Propositions::dfs(int node) {
    vis[node] = true;
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}
```

æ‰€æœ‰ä»£ç ï¼š

```c++
#include <iostream>
using namespace std;

class Propositions {
public:
    int N, M;
    int start, end; // èµ·ç‚¹å’Œç»ˆç‚¹
    int isLogic = true; // æ˜¯å¦é€»è¾‘è‡ªæ´½
    int path[505][505]; // é‚»æ¥çŸ©é˜µï¼Œåœ¨æ„å»ºå‡½æ•°ä¸­åˆå§‹åŒ–ä¸º0ï¼›
    long long step[505] = {0}; // step[i] : ç¬¬ i ä¸ªç‚¹åˆ°ç»ˆç‚¹çš„è·¯å¾„çš„ä¸ªæ•°
    bool vis[505] = {0}; // æ˜¯å¦è®¿é—®è¿‡

    Propositions();
    void insertPath(); // è¾“å…¥è·¯å¾„
    int getOutdegree(int node); // è®¡ç®—ä¸€ä¸ªèŠ‚ç‚¹çš„å‡ºåº¦
    void dfs(int node); // æ·±åº¦ä¼˜å…ˆæœç´¢
    void detect(); // æ¨ç†å…¥å£
};

Propositions::Propositions() {
    for( int i=0; i<N+1; i++ ){
        for( int j=0; j<N+1; j++ ){
            path[i][j] = 0;
        }
    }
}

void Propositions::insertPath() {
    cin >> N >> M;
    for( int i=0; i<M; i++ ){
        int from, to; cin >> from >> to;
        path[from][to] = 1;
    }
}

int Propositions::getOutdegree(int node) {
    int sum = 0;
    for( int i=0; i<N+1; i++ ){
        sum += path[node][i];
    }
    return sum;
}

void Propositions::dfs(int node) {
    vis[node] = true;
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}

void Propositions::detect() {
    cin >> start >> end;
    step[end] = 1; // é‡è¦åˆå§‹åŒ–
    vis[end] = true; // é‡è¦åˆå§‹åŒ–
    dfs(start);
    cout << step[start] << " " ;
    if( isLogic ) cout << "Yes";
    else cout << "No";
}

int main() {
    Propositions p;
    p.insertPath();
    p.detect();
    return 0;
}

```

## 7-4 æ£®æ£®æ—…æ¸¸

**çŸ¥è¯†ç‚¹**ï¼šæœ€çŸ­è·¯å¾„ã€é‚»æ¥è¡¨

**æ€è·¯**ï¼šç”¨Dijskraæœ€çŸ­è·¯ç®—æ³•åˆ†åˆ«æ±‚å‡º

1.ä½¿ç”¨ç°é‡‘ä»åŸå¸‚1å‡ºå‘ï¼Œåˆ°è¾¾æ‰€æœ‰åŸå¸‚çš„æœ€å°èŠ±è´¹ï¼ˆå‚¨å­˜åœ¨`oneToOthers`å†…ï¼‰
2.ä½¿ç”¨æ—…æ¸¸é‡‘ä»åŸå¸‚nå‡ºå‘ï¼Œåˆ°è¾¾æ‰€æœ‰åŸå¸‚çš„æœ€å°èŠ±è´¹ï¼ˆå‚¨å­˜åœ¨`othersToN`å†…ï¼‰

åœ¨ç¬¬iä¸ªåŸå¸‚å°†ç°é‡‘æ¢æˆæ—…æ¸¸é‡‘çš„æƒ…å†µä¸‹æ‰€éœ€è¦çš„ç°é‡‘æ€»é¢ä¸º

`all_cash = oneToOthers[i] + othersToN[i]` 

ï¼ˆå³ä»åŸå¸‚1åˆ°è¾¾ç¬¬iä¸ªåŸå¸‚æ‰€éœ€è¦çš„æœ€å°ç°é‡‘æ•° + ä»ç¬¬iä¸ªåŸå¸‚åˆ°åŸå¸‚næ‰€éœ€è¦çš„æœ€å°æ—…æ¸¸é‡‘æ•°æ‰€è½¬æ¢æˆçš„ç°é‡‘æ•°é‡ï¼‰

ç„¶åå†é€šè¿‡æšä¸¾ä¸­è½¬ç‚¹`i`çš„æ–¹å¼ï¼Œå¾—åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚ä¸ºäº†è®©Dijkstraç®—æ³•æ›´æœ‰æ•ˆç‡ï¼Œå¯ä»¥å­˜å‚¨åå‘è·¯å¾„ã€‚

**ç»†èŠ‚**ï¼š

* è·¯å¾„çš„å­˜å‚¨ã€‚
  * ä½¿ç”¨é‚»æ¥è¡¨ï¼Œè€Œä¸æ˜¯é‚»æ¥çŸ©é˜µï¼Œå› ä¸º1w*1wçš„äºŒç»´æ•°ç»„ä¼šè¶…å†…å­˜ã€‚
  * å­˜å‚¨è·¯å¾„çš„æ•°æ®ç»“æ„ä¸ºï¼š`myvector<Mypair> path[100005], rpath[100005]`ï¼Œå…¶ä¸­`myvector`æ˜¯è‡ªå·±å®šä¹‰çš„ç±»ï¼Œå®ç°ç±»ä¼¼vectorçš„åŠŸèƒ½ï¼Œå…¶æœ€å¤§çš„ç‰¹ç‚¹æ˜¯é•¿åº¦å¯å˜ï¼›`Mypair`æ˜¯è‡ªå·±å®šä¹‰çš„ç»“æ„ä½“ï¼Œå®ç°ç±»ä¼¼pairçš„åŠŸèƒ½ã€‚
  * `path`å­˜å‚¨çš„æ˜¯ä¸€ä¸ªåŸå¸‚åˆ°å¦ä¸€ä¸ªåŸå¸‚æ‰€éœ€è¦ç°é‡‘ã€‚`rpath`å­˜å‚¨çš„æ˜¯ç›¸åè·¯å¾„æ‰€éœ€è¦çš„æ—…æ¸¸é‡‘ã€‚
  * ä¸¾ä¸ªä¾‹å­ï¼Œå¯¹äºè¾“å…¥`u v c d`ï¼Œ`path[u].push_back(Mypair(v, c))`ï¼Œ`rpath[v].push_back(Mypair(u,d))`
* Dijkstraæœ‰æšä¸¾å†™æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n*2)ï¼Œnæ˜¯èŠ‚ç‚¹ä¸ªæ•°ã€‚è¿˜æœ‰åŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„å†™æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(ElogV)ã€‚è¿™é‡Œä½¿ç”¨åè€…ã€‚
* æœ¬é¢˜çš„æœ€åä¸€æ­¥æ˜¯æ›´æ–°æ±‡ç‡ï¼Œä¹Ÿæœ‰ä¸¤ç§æ“ä½œï¼š
  * æ¯æ¬¡æ›´æ–°æ±‡ç‡åéƒ½æšä¸¾ä¸€æ¬¡ä¸­è½¬ç‚¹ï¼Œæ‰¾åˆ°æœ€å°‘èŠ±è´¹ï¼Œç„¶åè¾“å‡ºã€‚æ—¶é—´å¤æ‚åº¦é«˜ï¼Œ3ä¸ªç‚¹è¿‡ä¸å»ï¼Œåªèƒ½å¾—21åˆ†ã€‚
  * æšä¸¾ä¸­è½¬ç‚¹ï¼Œç”¨ä¸€ä¸ª`multiset`ï¼ˆå…¶ç‰¹ç‚¹æ˜¯æœ‰åºï¼Œèƒ½å¤Ÿå¿«é€Ÿæ’å…¥å’Œåˆ é™¤ï¼‰ç»´æŠ¤ã€‚æ¯æ¬¡æ›´æ–°æ±‡ç‡éƒ½åˆ é™¤æ—§çš„ï¼Œæ’å…¥æ–°çš„ã€‚æ—¶é—´å¤æ‚åº¦ä½ï¼Œä½†æ˜¯å¾ˆéš¾å®ç°ï¼ˆçº¢é»‘æ ‘ï¼‰ã€‚

**21åˆ†ä»£ç **ï¼ˆä¸‰ä¸ªæµ‹è¯•ç‚¹è¶…æ—¶ï¼‰ï¼š

```c++
#include <iostream>
#define int long long 
const int N = 100005; // æœ€å¤§èŠ‚ç‚¹æ•°
using namespace std;

// å®ç°Mypair
struct Mypair
{
    int first;
    int second;

    // é»˜è®¤æ„é€ å‡½æ•°
    Mypair()
            :first(0),second(0) {}  //ç”¨0,0åˆå§‹åŒ–
    //æ„é€ å‡½æ•°
    Mypair(const int&a,const int&b)
            :first(a),second(b) {}
};
// ä¸ºäº†åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¯¹æ“ä½œç¬¦é‡è½½
bool operator==(const Mypair&s1,const Mypair&s2)
{
    return s1.first==s2.first&&s1.second==s2.second;
}

bool operator>(const Mypair&s1,const Mypair&s2)
{
    return (s1.first>s2.first)||(!(s1.first<s2.first)&&s1.second>s2.second);
}

bool operator<(const Mypair&s1, const Mypair&s2)
{
    return (s1.first<s2.first)||(!(s1.first>s2.first)&&s1.second<s2.second);
}

// å®ç°ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå¤§é¡¶å †ï¼‰
class PriorityQueue
{
private:
    Mypair* pArray;
    int m_length;
public:
    PriorityQueue(int N) {
        // ä¸ºåç»­æ ¹èŠ‚ç‚¹ç›´æ¥ä»1å¼€å§‹ä½œå‡†å¤‡
        pArray = new Mypair[N];
        m_length = 0;
    }
// è¿”å›å †é¡¶
    Mypair Top(){
        return pArray[1];
    }
// åˆ é™¤å †é¡¶
    Mypair delMax() {
        // å¤§æ ¹å †ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæœ€å¤§
        Mypair max = pArray[1];
        // å°†ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢,å¹¶ä½¿é•¿åº¦å‡ä¸€ï¼Œå³åˆ é™¤æœ€å¤§çš„å…ƒç´ 
        swap(pArray[1], pArray[m_length--]);
        // é˜²æ­¢å¯¹è±¡æ¸¸ç¦»
        pArray[m_length + 1] = Mypair();
        // ä¸‹æ²‰æ¢å¤å †çš„æœ‰åºæ€§
        sink(1);
        // è¿”å›æœ€å¤§çš„èŠ‚ç‚¹å€¼
        return max;

    }
// æ’å…¥å…ƒç´ 
    void insert(Mypair v) {
        // å°†å€¼væ’å…¥åˆ°pArray[1]ä½ç½®å¤„ï¼Œæ‰€ä»¥è¿™é‡Œç”¨çš„å‰ç½®++
        pArray[++m_length] = v;
        // æ–°åŠ å…¥çš„å…ƒç´ ä¸Šæµ®
        swim(m_length);
    }

// åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool isEmpty() {
        return m_length == 0;
    }
// é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°
    int size() {
        return m_length;
    }

    // å‘ä¸Šæµ®
    void swim(int k) {
        // åˆ¤æ–­æœ€ä¸‹å±‚çš„å¶å­èŠ‚ç‚¹å€¼å¦‚æœå¤§äºå…¶çˆ¶èŠ‚ç‚¹åˆ™è¿›å…¥å¾ªç¯ä¸Šæµ®
        while (k > 1 && pArray[k] > pArray[k / 2]) {
            // äº¤æ¢çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹
            swap(pArray[k / 2], pArray[k]);
            // kæ•°å€¼å‡å°ç»§ç»­å‘ä¸Šæµ®
            k /= 2;
        }
    }
    // å‘ä¸‹æ²‰
    void sink(int k) {
        while (2 * k <= m_length)
        {
            // ç”±äºå †çš„æ€§è´¨çˆ¶èŠ‚ç‚¹ä¸ºkåˆ™å…¶å·¦å­æ ‘ä¸º2*kå³j
            int j = 2 * k;
            // è¿™é‡Œå…ˆæ¯”è¾ƒå·¦å­æ ‘å’Œå³å­æ ‘çš„å¤§å°ï¼Œå°†æœ€å¤§çš„é‚£ä¸ªé”®è®°å½•ä¸‹æ¥å†å’Œçˆ¶èŠ‚ç‚¹æ¯”è¾ƒ
            if (j < m_length && (pArray[j] < pArray[j + 1])) j++;
            // å’Œçˆ¶èŠ‚ç‚¹æ¯”è¾ƒå¦‚æœçˆ¶èŠ‚ç‚¹æ¯”æœ€å¤§çš„å­èŠ‚ç‚¹è¿˜è¦å¤§ï¼Œåˆ™ç›´æ¥é€€å‡ºå¾ªç¯
            if (pArray[k] > pArray[j]) break;
            // å¦‚æœçˆ¶èŠ‚ç‚¹æ¯”å­èŠ‚ç‚¹å°åˆ™äº¤æ¢
            swap(pArray[k], pArray[j]);
            // kå€¼å˜å¤§ç»§ç»­ä¸‹æ²‰
            k = j;
        }
    }
};


// å®ç°myvector
template<typename T>
class myvector{
public:
    typedef T value_type;
    typedef T* iterator;
private:
    value_type* _data;
    size_t _size;
    size_t _capacity;

public:
    myvector():_data(NULL),_size(0),_capacity(0){}
    ~myvector(){
        delete [] _data;
        _data = NULL;
        _size = 0;
        _capacity = 0;
    }
    myvector(const myvector& vec){
        _size = vec._size;
        _capacity = vec._capacity;
        _data = new value_type[_capacity];
        for(int i=0;i<_size;++i){
            _data[i] = vec._data[i];
        }
    }
    myvector& operator=(const myvector& vec){
        if(this == &vec) return *this;
        value_type* temp = new value_type[vec._capacity];
        for(int i=0;i<vec._size;++i){
            temp[i] = vec._data[i];
        }
        delete [] _data;
        _data = temp;
        _size = vec._size;
        _capacity = vec._capacity;
        return *this;
    }
    void push_back(value_type val){
        if(0 == _capacity){
            _capacity = 1;
            _data = new value_type[1];
        }else if(_size+1 > _capacity){
            _capacity *= 2;
            value_type* temp = new value_type[_capacity];
            for(int i=0;i<_size;++i){
                temp[i] = _data[i];
            }
            delete [] _data;
            _data = temp;
        }
        _data[_size] = val;
        ++_size;
    }

    size_t size()const{ return _size;}
== 0;}
    value_type& operator[](size_t index){
        return _data[index];
    }

    void erase(iterator it){
        size_t index = it - _data;
        for(int i=index;i<_size-1;++i){
            _data[i] = _data[i+1];
        }
        --_size;
    }

    iterator begin(){ return _data; }
    iterator end(){ return _data + _size; }
};


// æ‰¾åˆ°æœ€çŸ­è·¯
void dijkstra( int from, bool vis[], myvector<Mypair> (&path)[N], int dist[], int n ){
    PriorityQueue que(100005); // å¤§é¡¶å †
    Mypair tmp(0, from);
    que.insert(tmp);
    while(!que.isEmpty()){
        int x, w;
        w = que.Top().first; x = que.Top().second;
        que.delMax();
        if( vis[x] ) continue;
        vis[x] = true;
        dist[x] = -w;
        for( int i=0; i<path[x].size(); i++ ){
            int y, w;
            y = path[x][i].first;
            w = path[x][i].second;
            if( vis[y] ) continue;
            que.insert({-dist[x]-w, y});
        }
    }
}
// ç¡®å®šä¸­è½¬ç‚¹iï¼Œæ±‚èŠ±è´¹ã€‚ä¸èƒ½æ•´é™¤çš„è¦+1
int TurnToCash(int othersToN[], int oneToOthers[], int a[], int i){
    int dToC = othersToN[i] % a[i] ? othersToN[i] / a[i] + 1 : othersToN[i] / a[i];
    return oneToOthers[i] + dToC;
}


signed main() {
  // è¾“å…¥è·¯å¾„
    int n, m, q; cin >> n >> m >> q;
    myvector<Mypair> path[N], rpath[N];
    while( m-- ){
        int u, v, c, d; cin >> u >> v >> c >> d;
        Mypair v_c(v, c);
        Mypair u_d(u, d);
        path[u].push_back(v_c);
        rpath[v].push_back(u_d);
    }
  // è¾“å…¥æ±‡ç‡
    int a[N];
    for( int i=1; i<=n; i++ ) cin >> a[i];
    int oneToOthers[N];
    int othersToN[N];
    bool vis[N] = {false};
    bool rvis[N] = {false};
  // æ±‚æœ€çŸ­è·¯ï¼Œå’Œåå‘æœ€çŸ­è·¯
    dijkstra(1, vis, path, oneToOthers, n);
    dijkstra(n, rvis, rpath, othersToN, n);

//    multiset<int> ms;
// æšä¸¾ä¸­è½¬ç‚¹
    while( q-- ){
        int node, d; cin >> node >> d;
        if( vis[node] && rvis[node] ) a[node] = d;
      // ç”¨minå€¼ç»´æŠ¤æœ€å°çš„èŠ±è´¹
        int min = 9223372036854775807;
        for( int i=1; i<=n; i++ ){
            if( vis[i] && rvis[i] ){
                if( min > TurnToCash(othersToN, oneToOthers, a, i))
                    min = TurnToCash(othersToN, oneToOthers, a, i);
            }

        }
        cout << min << endl;
    }
    return 0;
}

```

**æ»¡åˆ†ä½†æ˜¯ç”¨äº†multisetçš„ä»£ç **ï¼š

æŠŠæšä¸¾ä¸­è½¬ç‚¹é‚£ä¸€éƒ¨åˆ†æ”¹æˆï¼š

```c++
#include <set>

multiset<int> ms;
// å…ˆæ’å…¥
for( int i=1; i<=n; i++ ){
  if( vis[i] && rvis[i] ){
    ms.insert(TurnToCash(othersToN, oneToOthers, a, i) );
  }
}
while( q-- ){
  int node, d; cin >> node >> d;
  if( vis[node] && rvis[node] ){
    // æ¯æ¬¡æ›´æ–°æ±‡ç‡ï¼Œå…ˆåˆ é™¤æ—§æ±‡ç‡ï¼Œå†æ’å…¥æ–°çš„
    ms.erase(ms.find(TurnToCash(othersToN, oneToOthers, a, node)) );
    a[node] = d;
    ms.insert( TurnToCash(othersToN, oneToOthers, a, node) );
  }
  // è¿”å›é¡¶éƒ¨å…ƒç´ å°±å¯ä»¥å•¦
  cout << *ms.begin() << endl;
}
```

## 7-5 Hand-made Cream

**çŸ¥è¯†ç‚¹**ï¼šåŠ¨æ€è§„åˆ’

**æ€è·¯**ï¼šè€ƒå¯Ÿä»ç¬¬1ä¸ªé¢åŒ…`bread[1]`ï¼Œé€‰åˆ°ç¬¬iä¸ªé¢åŒ…`bread[i]`å’Œä»`cream[1]`åˆ°`cream[j]`ï¼Œä¹˜ç§¯æœ€å¤§çš„æ­é…`dp[i][j]`ï¼Œæœ‰å¦‚ä¸‹æƒ…å†µï¼š

* å¦‚æœå°†ç¬¬iä¸ªé¢åŒ…å’Œç¬¬jä¸ªé¢åŒ…æ­é…ï¼Œé‚£ä¹ˆ`dp[i][j] = dp[i-1][j-1] + bread[i]*cream[j]`ï¼›
* å¦‚æœä¸æ­é…ï¼Œé‚£ä¹ˆç­‰äºå‰ä¸€ä¸ªé¢åŒ…ï¼Œæˆ–è€…å‰ä¸€ä¸ªå†°æ·‡æ·‹çš„ç»“è®ºï¼Œå³`dp[i][j] = dp[i-1][j]`æˆ–è€…`dp[i][j] = dp[i][j-1]`

å› ä¸ºè¦æ±‚æœ€å¤§çš„å€¼ï¼Œæ‰€ä»¥ç»¼åˆä¸€ä¸‹ï¼š`dp[i][j] = max(dp[i-1][j-1]+bread[i]*cream[j],dp[i-1][j],dp[i][j-1])`

ç”¨ä¸¤ä¸ªå¾ªç¯ï¼ŒåŠ¨æ€æ›´æ–°ä¸€ä¸‹`dp`è¡¨å°±å¯ä»¥å•¦ï¼Œä¸‹é¢æ˜¯é¢˜ç›®æ ·ä¾‹æœ€ç»ˆå¾—åˆ°çš„dpè¡¨ï¼š

| bread\cream | 10   | 8    | 11   | 9    |
| ----------- | ---- | ---- | ---- | ---- |
| -1          | 0    | 0    | 0    | 0    |
| 10          | 100  | 100  | 110  | 110  |
| 8           | 100  | 164  | 188  | 188  |

**ä»£ç **ï¼š

```c++
#include <iostream>
using namespace std;

int max(int a, int b, int c){
    if(a >= b && a >= c) return a;
    else{
        if(b >= c)return b;
        else return c;
    }
}

int max(int a, int b){
    if(a >= b) return a;
    else return b;
}

int main() {
    int N, M; cin >> N >> M;
    int a[1005], b[1005];
    for( int i=0; i<N; i++ ) cin >> a[i+1];
    for( int i=0; i<M; i++ ) cin >> b[i+1];

    int dp[1005][1005], res = 0;
    for( int i=1; i<=N; i++ ){
        for( int j=1; j<=M; j++ ){
            dp[i][j] = max(dp[i-1][j-1]+a[i]*b[j], dp[i-1][j], dp[i][j-1]);
            cout << dp[i][j] << " " ;
            res = max(res, dp[i][j]);
        }
        cout << endl;
    }
    cout << res;
    return 0;
}

```


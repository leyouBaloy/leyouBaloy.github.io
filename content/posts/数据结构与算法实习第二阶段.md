---
title: "æ•°æ®ç»“æ„ä¸ç®—æ³•å®ä¹ ç¬¬äºŒé˜¶æ®µ"
author: å­™ç™¾ä¹
date: 2022-07-02T15:38:13+08:00
draft: false
categories: 
- åˆ·é¢˜
- ç¬”è®°
---



## 7-1 Table Tennis

**çŸ¥è¯†ç‚¹**ï¼šæ¨¡æ‹Ÿï¼Œé˜Ÿåˆ—

**æ€è·¯**ï¼šæŠŠæ‰€æœ‰ç©å®¶æŒ‰åˆ°è¾¾é¡ºåºæ’åºï¼Œé€ä¸ªå¤„ç†ï¼Œåˆ†å¦‚ä¸‹æƒ…å†µï¼š

* æ‰¾åˆ°æ‰€æœ‰æ¡Œå­ä¸­æœ€æ—©ç»“æŸå½“å‰æœåŠ¡çš„æ¡Œå­ã€‚åˆ¤æ–­ï¼šå¦‚æœè¿™ä¸ªæ¡Œå­å½“å‰æœåŠ¡çš„ç»“æŸæ—¶é—´è¶…è¿‡9ç‚¹ï¼Œé‚£å‰©ä¸‹çš„ç©å®¶éƒ½ä¸ç”¨å¤„ç†äº†ï¼Œä¸å¯èƒ½è¢«æœåŠ¡ã€‚å¦åˆ™å†ç»§ç»­ä¸‹é¢çš„è¿‡ç¨‹ã€‚
  * å¦‚æœè¿™ä¸ªæ¡Œå­æ˜¯ä¸ºvipé¢„ç•™çš„ï¼š
    * è¿™ä¸ªäººæ˜¯æ™®é€šäººï¼Œé™¤éä»–åé¢æ²¡æœ‰vipåˆ°æ¥ï¼Œæ¡Œå­æ‰ç»™ä»–ç”¨
    * å¦‚æœè¿™ä¸ªäººæ˜¯vipï¼Œè¿™ä¸ªæ¡Œå­åˆ†é…ç»™ä»–ã€‚ å¤„ç†ä¸‹ä¸€ä¸ªäºº
  * å¦‚æœè¿™ä¸ªæ¡Œå­æ˜¯æ™®é€šæ¡Œå­ï¼š
    * å¦‚æœè¿™ä¸ªäººæ˜¯æ™®é€šäººï¼Œé‚£ä¹ˆè¿™ä¸ªæ¡Œå­åˆ†é…ç»™ä»–ã€‚å¤„ç†ä¸‹ä¸€ä¸ªäºº
    * å¦‚æœè¿™ä¸ªäººæ˜¯vipï¼Œé¦–å…ˆå»çœ‹åœ¨ä»–æ¥ä¹‹å‰æœ‰æ²¡æœ‰ç©ºä¸‹æ¥çš„vipæ¡Œå­ï¼Œå¦‚æœæœ‰ï¼Œå°±è®©ä»–å»é‚£ä¸ªvipæ¡Œå­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±æŠŠè¿™ä¸ªæ™®é€šæ¡Œå­ç»™ä»–ç”¨ã€‚å¤„ç†ä¸‹ä¸€ä¸ªäººã€‚

**ç»†èŠ‚**ï¼š

* æ—¶é—´ä»¥ä»0ç‚¹ç»è¿‡çš„ç§’æ•°å­˜å‚¨
* ç»“æ„ä½“æ•°ç»„`customers[10005]`å‚¨å­˜é¡¾å®¢ï¼Œå­—æ®µæœ‰ï¼šåˆ°è¾¾æ—¶é—´`arriveTime`ï¼Œå¼€å§‹è¢«æœåŠ¡æ—¶é—´ `startTime`ï¼Œç©è€æ—¶é—´ `playTime` ï¼Œæ˜¯å¦VIP`isVip`ï¼Œæ˜¯å¦è¢«æœåŠ¡è¿‡ `isServed`
* ç»“æ„ä½“æ•°ç»„`table[105]`å‚¨å­˜æ¡Œå­ï¼Œå­—æ®µæœ‰ï¼šç»“æŸæœåŠ¡çš„æ—¶é—´`endTime`ï¼ŒæœåŠ¡é¡¾å®¢æ•°`serveCount`ï¼Œæ˜¯å¦VIP`isVip`
* æ’åº â€”> å€Ÿç”¨ç¬¬ä¸€é˜¶æ®µç¬¬äº”é¢˜çš„å †æ’åºï¼Œå°†`cmp`å‡½æ•°ä½œä¸ºå‚æ•°ä¼ è¿›å»

* è¿™é¢˜ç»†èŠ‚å¤ªå¤šäº†ï¼Œçœ‹ä»£ç æ³¨é‡Š

```c++
    #include<iostream>

    const int intMAX = 0x3f3f3f3f;
    using namespace std;

    // ä¿±ä¹éƒ¨å¼€é—¨æ—¶é—´ï¼Œä»¥ s ä¸ºå•ä½
    const int club_open_time = 3600 * 8;
    // ä¿±ä¹éƒ¨å…³é—¨æ—¶é—´ï¼Œä»¥ s ä¸ºå•ä½
    const int club_close_time = 3600 * 21;


    struct Customers {
        int arriveTime, startTime, playTime; // åˆ°è¾¾æ—¶é—´ï¼Œå¼€å§‹æ—¶é—´ï¼Œç©è€æ—¶é—´
        bool isVip, isServed = false; // æ˜¯å¦æ˜¯ vipï¼Œæ˜¯å¦è¢«æœåŠ¡è¿‡äº†
    }customer[10005];

    struct Table {
        // åˆšå¼€å§‹å…¨æ˜¯8:00å¼€å§‹æœåŠ¡
        int endTime = club_open_time, serveCount = 0; // å½“å‰æœåŠ¡ç»“æŸæ—¶é—´ï¼Œå·²æœåŠ¡ç©å®¶ä¸ªæ•°
        bool isVip = false; // æ˜¯å¦æ˜¯ä¸ºvipé¢„ç•™çš„æ¡Œå­
    }table[105];

    // æŒ‰åˆ°è¾¾çš„å…ˆåé¡ºåºæ’é˜Ÿ
    bool cmp_by_arrive(Customers a, Customers b) { return a.arriveTime < b.arriveTime; }
    // è¾“å‡ºæ—¶ï¼ŒæŒ‰è¢«æœåŠ¡æ—¶é—´æ’åº
    bool cmp_by_starttime(Customers a, Customers b) { return a.startTime < b.startTime; }

    void Heapify(Customers arr[], int n, int i, bool (*cmp)(Customers a, Customers b)){
        // arr å­˜å‚¨å †çš„æ•°ç»„ï¼Œn æ•°ç»„é•¿åº¦ï¼Œ i ç»´æŠ¤èŠ‚ç‚¹çš„ä¸‹æ ‡
        int largest = i; // å‡è®¾æœ€å¤§èŠ‚ç‚¹
        int lson = 2 * i + 1;
        int rson = 2 * i + 2;

        if (lson < n && cmp(arr[largest], arr[lson])){
            largest = lson;
        }
        if (rson < n && cmp(arr[largest], arr[rson])){
            largest = rson;
        }
        if(largest != i){
            Customers tmp;
            tmp = arr[largest];
            arr[largest] = arr[i];
            arr[i] = tmp;
            Heapify(arr, n, largest, cmp);
        }
    }

// å †æ’åºå…¥å£
    void HeapSort(Customers arr[], int n, bool (*cmp)(Customers a, Customers b)){
        // å»ºå †ï¼Œä»åº•å¾€ä¸Šæ„å»º
        int i;
        for(i = n / 2 - 1; i >= 0; i--){ // ä»æœ€åä¸€ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹å¼€å§‹
            Heapify(arr, n, i, cmp);
        }
        // æ’åº
        for(i = n - 1; i > 0; i--){
            Customers tmp;
            tmp = arr[i];
            arr[i] = arr[0];
            arr[0] = tmp;
            Heapify(arr, i, 0, cmp);
        }
    }


    // å°†æŸä¸ªæ¡Œå­æä¾›ç»™æŸä¸ªé¡¾å®¢
    void AssignTable( int tab_id, int cus_id ) {
    //    cout << "tab_id " << tab_id << " cus_id " <<  cus_id << endl;
        // ç©å®¶æ¥çš„æ—¶å€™ï¼Œè¿™ä¸ªæ¡Œå­å·²ç©ºé—²ï¼Œç©å®¶å¯ä»¥ç›´æ¥å¼€å§‹ç©
        if (table[tab_id].endTime <= customer[cus_id].arriveTime) {
            customer[cus_id].startTime = customer[cus_id].arriveTime;
        } else {
            // ç©å®¶æ¥çš„æ—¶å€™è¿™ä¸ªæ¡Œå­è¿˜åœ¨æœåŠ¡ä¸Šä¸€ä¸ªäººï¼Œéœ€è¦ç­‰å®ƒå½“å‰æœåŠ¡ç»“æŸ
            // æ‰€ä»¥ç©å®¶å¼€å§‹ç©çš„æ—¶é—´åº”è¯¥æ˜¯è¿™ä¸ªæ¡Œå­å½“å‰æœåŠ¡ç»“æŸçš„æ—¶é—´
            customer[cus_id].startTime = table[tab_id].endTime;
        }
        // å¼€å§‹æ–°çš„æœåŠ¡ï¼Œæ›´æ–°è¿™ä¸ªæ¡Œå­å½“å‰æœåŠ¡çš„ç»“æŸæ—¶é—´
        table[tab_id].endTime = customer[cus_id].startTime + customer[cus_id].playTime;
        // è¿™ä¸ªæ¡Œå­çš„æœåŠ¡äººæ•°å¢åŠ 
        table[tab_id].serveCount++;
    }

    // æ‰¾åˆ°è¿™ä¸ªäººåé¢ç¬¬ä¸€ä¸ªä¼šå‘˜æœªè¢«æœåŠ¡çš„ä¼šå‘˜
    // N,æ€»é¡¾å®¢æ•°
    int FindNextVip(int cus_id, int N) {
        cus_id += 1;
        while ( cus_id < N ) {
            // æ˜¯ä¼šå‘˜ï¼ä¸”æœªè¢«æœåŠ¡ï¼
            if ( customer[cus_id].isVip && !customer[cus_id].isServed )
                return cus_id;
            cus_id++;
        }
        return -1;
    }
     // æ‰¾åˆ°ç¬¬ä¸€ä¸ªç»“æŸæœåŠ¡çš„æ¡Œå­ï¼ŒKä¸ºæ¡Œå­æ•°
    int GetMinEndTable(int cus_id, int K){
        int index = -1, min_end = intMAX;
        for (int i = 1; i <= K; i++) {
            if (customer[cus_id].arriveTime > table[i].endTime ){
                index = i;
                break;
            }
            else if (table[i].endTime < min_end) {
                index = i;
                min_end = table[i].endTime;
            }
        }

        return index;
    }

     // ä¸ºä¼šå‘˜æ‰¾æ¡Œå­ï¼ŒK ä¸ºæ¡Œå­æ€»æ•°
    int FindTableForVIP( int K ){
        // å…ˆçœ‹æ‰€æœ‰ç»™ä¼šå‘˜é¢„ç•™çš„æ¡Œå­æ˜¯å¦æœ‰ç©ºé—²ï¼Œæœ‰å°±ç»™ä»–ï¼Œæ²¡æœ‰å°±æŠŠè¿™ä¸ªæ™®é€šæ¡Œå­ç»™ä»–
        // æ‰¾åˆ°æ‰€æœ‰ä¼šå‘˜æ¡Œä¸­æœ€æ—©ç»“æŸçš„é‚£ä¸ª
        int t_vip = -1, t_vip_min_end = intMAX;
        for (int i = 1; i <= K; ++i) {
            if (table[i].isVip && table[i].endTime < t_vip_min_end) {
                t_vip = i;
                t_vip_min_end = table[i].endTime;
            }
        }
        return t_vip;
    }

		// è‡ªå·±å†™çš„roundï¼Œå››èˆäº”å…¥æ±‚æ•´æ•°
    double round(double x)
    {
        return (int)(x+0.5);
    }

    int main() {
        // è¾“å…¥ç©å®¶
        int N; cin >> N;
        int hh,mm,ss,t,vip;
        int cus_cnt = 0; // åœ¨è¥ä¸šæ—¶é—´å†…çš„é¡¾å®¢æ•°é‡ï¼Œè·Ÿ N ä¸ä¸€æ ·ï¼
        while( N-- ){
            scanf("%d:%d:%d %d %d", &hh, &mm, &ss, &t, &vip);
            int arrive = hh * 3600 + mm * 60 + ss;
            if (arrive >= club_close_time) continue; // ç©å®¶æ¥çš„æ—¶å€™ä¿±ä¹éƒ¨å…³é—¨
            customer[cus_cnt].arriveTime = arrive; // ç©å®¶åˆ°è¾¾æ—¶é—´ï¼Œä»¥ç§’è®°
            t = t * 60;
            if (t > 7200)
                t = 7200;
            customer[cus_cnt].playTime = t; // ä¸€ä¸ªç©å®¶æœ€å¤šç©2å°æ—¶
            customer[cus_cnt].isVip = vip == 1 ? true : false; // æ˜¯å¦æ˜¯vip
            // æŠŠç©å®¶è¢«æœåŠ¡æ—¶é—´åˆå§‹åŒ–ä¸ºä¿±ä¹éƒ¨å…³é—¨æ—¶é—´ï¼Œä¾¿äºæœ€åè¾“å‡ºæ—¶æ·˜æ±°æ‰å“ªäº›æœªè¢«æœåŠ¡çš„ç©å®¶
            customer[cus_cnt].startTime = club_close_time;
            cus_cnt ++ ;
        }

        // è¾“å…¥æ¡Œå­
        int K, M; cin >> K >> M;
        // è¯»å…¥Mä¸ªvipæ¡Œå­åºå·
        int tab_id;
        for ( int i=0; i<M; i++ ) {
            cin >> tab_id;
            table[tab_id].isVip = true;
        }

        // ç©å®¶æŒ‰åˆ°è¾¾æ—¶é—´æ’é˜Ÿ
        HeapSort(customer, cus_cnt, cmp_by_arrive);
        // é€ä¸ªå¤„ç†ç©å®¶
        int i = 0;
        while ( i < cus_cnt ) {
            int index = GetMinEndTable(i, K); // æ‰¾åˆ°ç¬¬ä¸€ä¸ªç»“æŸæœåŠ¡çš„æ¡Œå­ï¼ŒKä¸ºæ¡Œå­æ•°
            // æœ€æ—©ç»“æŸçš„æ¡Œå­ç»“æŸå½“å‰æœåŠ¡éƒ½è¦ç­‰åˆ°ä¿±ä¹éƒ¨å…³é—¨äº†ï¼Œé¡¾å®¢å¯ä»¥å…¨å›å®¶äº†ï¼Œæ²¡æˆäº†
            if (table[index].endTime >= club_close_time) break;
            // å¦‚æœè¿™ä¸ªæ¡Œå­æ˜¯ç»™ä¼šå‘˜ç•™çš„
            if ( table[index].isVip ) {
                // è¿™ä¸ªäººä¹Ÿæ˜¯ä¼šå‘˜
                if ( customer[i].isVip ) {
                    // å¹¶ä¸”æ²¡è¢«æœåŠ¡è¿‡ï¼Œå°±ç›´æ¥åˆ†é…ç»™ä»–ï¼Œ
                    if ( !customer[i].isServed ) {
                        AssignTable(index, i);
                        // æ ‡è®°è¿™ä¸ªä¼šå‘˜è¢«æœåŠ¡
                        customer[i].isServed = true;
                        // ç„¶åå¤„ç†ä¸‹ä¸€ä¸ªäººï¼Œæ‰€ä»¥ i++
                        i++;
                    } else {
                        // æœåŠ¡è¿‡äº†å°±ç›´æ¥ä¸‹ä¸€ä¸ª
                        i++;
                    }
                    // ä»–æ˜¯æ™®é€šäºº
                } else {
                    // æ‰¾åˆ°ä»–åé¢ç¬¬ä¸€ä¸ªvip
                    // å¦‚æœä¸å­˜åœ¨ï¼Œæˆ–è€… å­˜åœ¨ï¼Œä½†æ˜¯å½“å‰æ¡Œå­ç»“æŸæœåŠ¡çš„æ—¶å€™è¿™ä¸ªvipè¿˜æ²¡æ¥ï¼Œ
                    // ä»–æ‰å¯ä»¥ç”¨è¿™ä¸ªæ¡Œå­ï¼Œ
                    int next_vip = FindNextVip(i, cus_cnt);
                    if (next_vip == -1 || customer[next_vip].arriveTime > table[index].endTime) {
                        AssignTable(index, i);
                        // ç„¶åå¤„ç†ä¸‹ä¸€ä¸ªäººï¼Œæ‰€ä»¥ i++
                        i++;
                    } else {
                        // ä»–åé¢æœ‰ä¼šå‘˜ï¼Œè€Œä¸”è¿™ä¸ªä¼šå‘˜çš„åˆ°è¾¾æ—¶é—´åœ¨è¿™ä¸ªæ¡Œå­ç»“æŸæœåŠ¡ä¹‹å‰ï¼Œ
                        // è¿™ä¸ªæ¡Œå­å°±ç»™ä¼šå‘˜ç”¨
                        AssignTable(index, next_vip);
                        // æ ‡è®°è¿™ä¸ªä¼šå‘˜è¢«æœåŠ¡
                        customer[next_vip].isServed = true;
                        // ç›¸å½“äºè¿™ä¸ªäººè¢«æ’é˜Ÿäº†ï¼Œä¸‹ä¸€ä¸ªè¿˜æ˜¯å¤„ç†ä»–ï¼Œæ‰€ä»¥ iä¸å˜
                    }
                }
                // æ™®é€šæ¡Œå­
            } else {
                // è¿™ä¸ªäººæ˜¯æ™®é€šäººå°±åˆ†é…ç»™ä»–ï¼Œ
                if (!customer[i].isVip) {
                    AssignTable(index, i);
                    // è¿™ä¸ªäººæ˜¯ä¼šå‘˜ï¼Œå¹¶ä¸”æ²¡è¢«æœåŠ¡è¿‡ï¼Œ
                } else if (!customer[i].isServed) {
                    int t_vip = FindTableForVIP( K ); // ä¸ºä¼šå‘˜æ‰¾æ¡Œå­ï¼ŒK ä¸ºæ¡Œå­æ€»æ•°
                    // æœ€æ—©ç»“æŸçš„ä¼šå‘˜æ¡Œåœ¨ä»–æ¥ä¹‹å‰æœåŠ¡å®Œäº†ï¼Œè¯´æ˜æœ‰å¯ç”¨çš„ä¼šå‘˜æ¡Œï¼Œåˆ†é…ç»™ä»–ï¼Œå¦åˆ™ï¼Œæ²¡æœ‰å¯ç”¨çš„ä¼šå‘˜æ¡Œï¼ŒæŠŠæ™®é€šæ¡Œå­åˆ†é…ç»™è¿™ä¸ªä¼šå‘˜
                    (t_vip != -1 && table[t_vip].endTime <= customer[i].arriveTime) ? AssignTable(t_vip, i) : AssignTable(index, i);
                    customer[i].isServed = true;
                }
                i++; // ä¸‹ä¸€ä¸ª
            }
        }
        // å¤„ç†å®Œæ‰€æœ‰ç©å®¶ï¼ŒæŒ‰ç…§è¢«æœåŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
        HeapSort(customer, cus_cnt, cmp_by_starttime);
        // è¾“å‡ºç»“æœï¼Œæ— æ³•è¢«æœåŠ¡çš„è‡ªåŠ¨æ’é™¤
        for (int i=0; i<cus_cnt; i++) {
            if (customer[i].startTime >= club_close_time)
                continue;
            // åˆ°è¾¾æ—¶é—´
            printf("%02d:%02d:%02d ", customer[i].arriveTime / 3600,
                   customer[i].arriveTime % 3600 / 60, customer[i].arriveTime % 60);
            // è¢«æœåŠ¡æ—¶é—´
            printf("%02d:%02d:%02d ", customer[i].startTime / 3600,
                   customer[i].startTime % 3600 / 60, customer[i].startTime % 60);
            // ç­‰å¾…æ—¶é—´
            printf("%.0f\n", round((customer[i].startTime - customer[i].arriveTime) / 60.0));
        }
        // æ¯ä¸ªæ¡Œå­æœåŠ¡äº†å‡ ä¸ªäºº
        for (int i = 1; i <= K; i++)
    //        cout << "i" << i << endl;
            if( i==1 ) cout << table[i].serveCount;
            else cout << " " << table[i].serveCount;
        return 0;
    }
```



## 7-2 åˆ†è€Œæ²»ä¹‹

**çŸ¥è¯†ç‚¹**ï¼šå›¾è®º

**æ€è·¯**ï¼š

* æ€è·¯ä¸€ï¼šè®°å½•é‚»æ¥çŸ©é˜µï¼Œè¾“å…¥æ—¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æ•°ã€‚è¢«æ‘§æ¯çš„åŸå¸‚çš„åº¦ç½®ä¸º0ï¼Œå’Œå®ƒç›¸é‚»çš„ç‚¹åº¦ä¹Ÿ-1ã€‚æœ€åæ£€æŸ¥æ˜¯å¦æœ‰åº¦å¤§äº0çš„ç‚¹ï¼Œæœ‰å°±è¯´æ˜æœ‰åŸå¸‚ç›¸è¿é€šï¼Œè¾“å‡ºNOï¼Œå¦åˆ™è¾“å‡ºYESï¼›
* æ€è·¯äºŒï¼šè®°å½•æ‰€æœ‰çš„è¾¹(u, v)ï¼Œå’Œè¢«æ”»é™·åŸæ± `lost[i]`ã€‚éå†è¾¹(u, v)ï¼Œå¦‚æœå­˜åœ¨uæˆ–væ²¡æœ‰è¢«æ”»é™·ï¼ˆå³ä¸åœ¨`lost`é‡Œé¢ï¼‰ï¼Œè¯´æ˜æœ‰åŸå¸‚è¿é€šï¼Œè¾“å‡ºNOï¼Œå¦åˆ™YESï¼›

å› ä¸ºè¿™é¢˜æœ€å¤šæœ‰10005ä¸ªç‚¹ï¼Œä½¿ç”¨é‚»æ¥çŸ©é˜µä¼šè¶…å†…å­˜ï¼Œæ‰€ä»¥é‡‡ç”¨ç¬¬äºŒç§æ€è·¯ï¼›

**ç»†èŠ‚**ï¼š

* è®°å½•è¾¹å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæ•°ç»„`u[10005]`å’Œ`v[10005]`ï¼Œç¬¬`i`æ¡è¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯`u[i]`å’Œ`v[i]`
* åˆ¤æ–­è¾¹ä¸­æ˜¯å¦åŒ…å«æ²¡è¢«æ”»é™·çš„åŸæ± `if( !lost[u[i]] && !lost[v[i]] )`

**ä»£ç **ï¼š

```c++
#include <iostream>;
using namespace std;

class Citys {
public:
    int N, M;
    int u[10005]={0};
    int v[10005]={0}; // ç¬¬ i æ¡è¾¹ä¸º (u[i], v[i])
    void insertPath(); // è¾“å…¥è·¯å¾„
    bool isValid(); // è¾“å…¥ä¸€ä¸ªæ–¹æ¡ˆï¼Œåˆ¤æ–­æ˜¯å¦æœ‰æ•ˆ
    Citys(); // æ„é€ å‡½æ•°ï¼Œè¾“å…¥N, M
};

Citys::Citys() {
    cin >> N >> M;
}

void Citys::insertPath() {
    for(int i=0; i<M; i++){
        cin >> u[i] >> v[i];
    }
}

bool Citys::isValid() {
    // è¾“å…¥æ”»ç ´çš„åŸæ± 
    int Np; cin >> Np;
    int lost[10005] = {0};
    for( int i=0; i<Np; i++ ){
        int city; cin >> city;
        lost[city] = 1;
    }
    // åˆ¤æ–­
    for( int i=0; i<M; i++ ){
        if( !lost[u[i]] && !lost[v[i]] ){ // å¦‚æœéƒ½ä¸æ˜¯è¢«æ”»é™·çš„åŸæ± 
            return false;
        }
    }
    return true;

}
int main() {
    // è¾“å…¥æ•°æ®
    Citys citys = Citys();
    citys.insertPath();
    int K; cin >> K;
    for( int i=0; i<K; i++ ){
        if( citys.isValid() ) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
  
    return 0;
}

```

## 7-3 é‚£å°±åˆ«æ‹…å¿ƒäº†

**çŸ¥è¯†ç‚¹**ï¼šdfsã€æ—¶é—´å¤æ‚åº¦

**æ€è·¯**ï¼šæŠ½è±¡ä¸€ä¸‹ï¼šç»™å®šä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œå¹¶ä¸”ç»™å‡ºèµ·ç‚¹Aå’Œç»ˆç‚¹Bï¼Œé—®ä»Aå‡ºå‘çš„æ‰€æœ‰è·¯å¾„æ˜¯å¦éƒ½èƒ½åˆ°è¾¾Bï¼Œå¹¶ä¸”æ±‚å‡ºä»Aå‡ºå‘åˆ°è¾¾Bçš„ä¸åŒè·¯å¾„æœ‰å¤šå°‘æ¡ã€‚

* ç¬¬ä¸€ä¸ªé—®é¢˜éå¸¸å¥½è§£ï¼Œåªè¦ä»Aå¼€å§‹DFSï¼Œå¦‚æœæœåˆ°æŸä¸ªå‡ºåº¦ä¸º0çš„ç‚¹ï¼Œå¹¶ä¸”è¿™ä¸ªç‚¹ä¸æ˜¯é¢˜é¢ç»™å‡ºçš„Bç‚¹ï¼Œå°±è¯´æ˜å¹¶ä¸æ˜¯æ‰€æœ‰ä»Aå‡ºå‘çš„è·¯å¾„éƒ½èƒ½åˆ°è¾¾Bã€‚
* å¯¹äºç¬¬äºŒä¸ªé—®é¢˜ï¼Œè™½ç„¶è¿™é“é¢˜æ•°æ®æ¯”è¾ƒå°ï¼Œæœ€å¤šåªæœ‰500ä¸ªç‚¹ï¼Œä½†æ˜¯è¿™é¢˜çš„æ—¶é—´é™åˆ¶æ˜¯400msï¼Œå¯¹äºæ±‚è§£ä¸åŒè·¯å¾„çš„é—®é¢˜ï¼Œå¦‚æœæš´åŠ›æœç´¢çš„è¯æ˜¯ä¸€å®šä¼šè¶…æ—¶çš„ã€‚

è€ƒå¯Ÿè¾“å…¥æ ·ä¾‹ï¼ˆè‡ªå·±ç¼–çš„ï¼‰:

```
7 8
7 6
8 5
6 5
5 2
5 3
2 1
3 1
7 1
```



![7-3 é‚£å°±åˆ«æ‹…å¿ƒäº†é¢˜è§£DAG](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg)

å¾ˆæ˜æ˜¾ï¼Œä»7åˆ°1æœ‰å¦‚ä¸‹è·¯å¾„ï¼š

```
7 -> 6 -> 5 â€”> 2 -> 1
7 -> 6 -> 5 -> 3 -> 1
7 -> 8 -> 5 -> 2 -> 1
7 -> 8 -> 5 -> 3 -> 1
```

å‘ç°ï¼Œä»5åˆ°1æœ‰ä¸¤æ¡è·¯å¾„ã€‚åœ¨æœç´¢æ—¶ï¼Œç»è¿‡7ï¼Œ6ï¼Œ5ï¼Œä¼šæŠŠè¿™ä¸¤æ¡è·¯å¾„éƒ½æœç´¢ä¸€éï¼›ç»è¿‡7ï¼Œ8ï¼Œ5ï¼Œåˆä¼šæŠŠè¿™ä¸¤æ¡è·¯å¾„æœç´¢ä¸€éã€‚è¿™æ ·å°±é€ æˆäº†æ—¶é—´çš„æµªè´¹ã€‚æˆ‘ä»¬è€ƒè™‘ï¼Œå¦‚æœåœ¨ç»è¿‡6å·èŠ‚ç‚¹åˆ°è¾¾5å·èŠ‚ç‚¹ï¼Œå†åˆ°è¾¾ç»ˆç‚¹1å·èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„å…¨éƒ¨æœç´¢å®Œæ—¶ï¼Œ5å·èŠ‚ç‚¹èƒ½å¤Ÿå‚¨å­˜ä¸‹â€œç»è¿‡è¯¥èŠ‚ç‚¹æœ‰2æ¡è·¯å¾„åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹â€è¿™ä¸ªä¿¡æ¯ï¼Œè¿™æ ·åœ¨ä»8å·èŠ‚ç‚¹æœç´¢åˆ°5å·æ—¶ï¼Œå°±ä¸éœ€è¦å†é‡å¤åœ°å°†æ¥ä¸‹æ¥çš„è·¯å¾„å…¨éƒ¨æœç´¢ä¸€éäº†ï¼Œç›´æ¥ä»5å·èŠ‚ç‚¹è¯»åˆ°â€œæ¥ä¸‹æ¥æœ‰2æ¡ä¸åŒçš„è·¯å¾„â€è¿™ä¸ªä¿¡æ¯ã€‚æ­£å¥½ï¼ŒDFSçš„â€œèµ°åˆ°åº•å†è¿”å›â€çš„æ€§è´¨å¯ä»¥åšåˆ°ä»å°¾åˆ°å¤´ï¼Œä¹Ÿå°±æ˜¯ä»ç»ˆç‚¹åˆ°èµ·ç‚¹è®°å½•ä¿¡æ¯ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨DFSçš„è¿‡ç¨‹ä¸­è¿›è¡Œè®°å¿†åŒ–æ“ä½œã€‚

æˆ‘ä»¬å®šä¹‰`step[i]`ä¸ºâ€œä»`i`å·èŠ‚ç‚¹åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„æ¡æ•°â€œï¼Œæ±‚è§£çš„ç›®æ ‡æ˜¯`step[A]`ï¼Œå®šä¹‰`step[B] = 1`ï¼Œå¹¶ä¸”æ ‡è®°ğµBèŠ‚ç‚¹å·²ç»è¢«è®¿é—®è¿‡ã€‚åœ¨DFSçš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå°†è¦æœç´¢çš„èŠ‚ç‚¹æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼Œå°±æœç´¢ï¼Œå¹¶è®°å½•ä¸‹è·¯å¾„æ¡æ•°ï¼Œå½“å‰èŠ‚ç‚¹ç›´æ¥åŠ ä¸Šå¾…æœç´¢ï¼ˆå…¶å®è¿™æ—¶å€™å·²ç»æœç´¢å®Œäº†ï¼‰çš„èŠ‚ç‚¹çš„è·¯å¾„æ¡æ•°ã€‚ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼ŒDFSçš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

1. åˆå§‹åŒ–`step[]`æ•°ç»„ä¸º0ï¼Œåˆå§‹åŒ–`vis[]`æ•°ç»„ä¸º**false**ï¼Œèµ‹å€¼`step[1]=1`, `vis[1]=true`;
2. ä»èµ·ç‚¹7å¼€å§‹DFSï¼Œèµ‹å€¼`vis[7]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢6ï¼Œ`vis[6]==false`ï¼Œè¿›å…¥ï¼›
3. ä»6èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[6]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢5ï¼Œ`vis[5]==false`ï¼Œè¿›å…¥ï¼›
4. ä»5èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[5]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢2ï¼Œ`vis[2]==false`ï¼Œè¿›å…¥ï¼›
5. ä»2èŠ‚ç‚¹å¼€å§‹DFSï¼Œèµ‹å€¼`vis[2]=true`ã€‚æ¥ä¸‹æ¥æƒ³æœç´¢1ï¼Œ`vis[1]==true`ï¼Œä¸è¿›å…¥ï¼›ç´¯åŠ è·¯å¾„æ¡æ•°`step[2]=step[2]+step[1]`ï¼Œè¿™æ—¶`step[2]=1`ã€‚2èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›ï¼Œ`step[5]=step[5]+step[2]`,æ­¤æ—¶`step[5]=1`
6. æ¥ä¸‹æ¥æƒ³æœç´¢3ï¼Œèµ‹å€¼`vis[1]==true`ï¼Œä¸è¿›å…¥ï¼›ç´¯åŠ è·¯å¾„æ¡æ•°`step[3]=step[3]+step[1]`ï¼Œè¿™æ—¶`step[3]=1`ã€‚3èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›,`step[5]=step[5]+step[3]`,æ­¤æ—¶`step[5]=2`
7. 5èŠ‚ç‚¹æ²¡æœ‰å…¶ä»–çš„è·¯å¾„ï¼Œè¿”å›ï¼Œ`step[6]=step[6]+step[5]`ï¼Œæ­¤æ—¶`step[6]=2`.
8. 6æ²¡æœ‰å…¶å®ƒèŠ‚ç‚¹äº†ï¼Œè¿”å›7ï¼Œ`step[7]=step[7]+step[6]`ï¼Œæ­¤æ—¶`step[7]=2`ã€‚ç»§ç»­æœç´¢8ã€‚
9. ä»8å¼€å§‹DFSï¼Œèµ‹å€¼`vis[8]=true`ï¼Œæ¥ä¸‹æ¥åˆæƒ³æœç´¢5ï¼Œ`vis[5]=true`ï¼Œä¸è¿›å…¥ï¼Œ`step[8]=step[8]+step[5]`ï¼Œæ­¤æ—¶`step[8]=2`ï¼›
10. æ²¡æœ‰å…¶å®ƒè·¯å¾„äº†ï¼Œè¿”å›7ï¼Œ`step[7]=step[7]+step[8]`ï¼Œæ­¤æ—¶`step[7]=4`ã€‚æ²¡æœ‰å…¶å®ƒèŠ‚ç‚¹äº†ï¼Œé€’å½’ç»“æŸã€‚

**ç»†èŠ‚**ï¼š

* è·¯å¾„ä½¿ç”¨é‚»æ¥çŸ©é˜µå­˜å‚¨ï¼ˆé‚»æ¥è¡¨æ›´èŠ‚çœç©ºé—´ï¼Œä½†å› ä¸ºä¸èƒ½ä½¿ç”¨`vector`ï¼Œæ‰€ä»¥é‚»æ¥è¡¨å®ç°èµ·æ¥ä¼šéº»çƒ¦ä¸€ç‚¹ï¼‰
* åˆ¤æ–­èƒ½å¦â€œé€»è¾‘è‡ªæ´½â€ï¼šå‡ºåº¦ä¸º0ä¸”è¯¥èŠ‚ç‚¹ä¸æ˜¯ç»ˆç‚¹ï¼Œä»¤å…¨å±€å˜é‡`isLogic`

dfsçš„è¿‡ç¨‹ç”¨ä»£ç å®ç°ï¼š

```c++
void Propositions::dfs(int node) {
    vis[node] = true; // æ ‡è®°è®¿é—®
  // å¦‚æœå‡ºåº¦ä¸º0ï¼Œä¸”è¯¥èŠ‚ç‚¹ä¸æ˜¯ç»ˆç‚¹ï¼Œè¯´æ˜ä¸æ˜¯é€»è¾‘è‡ªæ´½çš„
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
  // ç»§ç»­dfsæ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸”è®°å½•step
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}
```

æ‰€æœ‰ä»£ç ï¼š

```c++
#include <iostream>
using namespace std;

class Propositions {
public:
    int N, M;
    int start, end; // èµ·ç‚¹å’Œç»ˆç‚¹
    int isLogic = true; // æ˜¯å¦é€»è¾‘è‡ªæ´½
    int path[505][505]; // é‚»æ¥çŸ©é˜µï¼Œåœ¨æ„å»ºå‡½æ•°ä¸­åˆå§‹åŒ–ä¸º0ï¼›
    long long step[505] = {0}; // step[i] : ç¬¬ i ä¸ªç‚¹åˆ°ç»ˆç‚¹çš„è·¯å¾„çš„ä¸ªæ•°
    bool vis[505] = {0}; // æ˜¯å¦è®¿é—®è¿‡

    Propositions();
    void insertPath(); // è¾“å…¥è·¯å¾„
    int getOutdegree(int node); // è®¡ç®—ä¸€ä¸ªèŠ‚ç‚¹çš„å‡ºåº¦
    void dfs(int node); // æ·±åº¦ä¼˜å…ˆæœç´¢
    void detect(); // å…¥å£ï¼Œåˆå§‹åŒ–ï¼Œdfså’Œè¾“å‡º
};

Propositions::Propositions() {
    for( int i=0; i<N+1; i++ ){
        for( int j=0; j<N+1; j++ ){
            path[i][j] = 0;
        }
    }
}

void Propositions::insertPath() {
    cin >> N >> M;
    for( int i=0; i<M; i++ ){
        int from, to; cin >> from >> to;
        path[from][to] = 1;
    }
}

int Propositions::getOutdegree(int node) {
    int sum = 0;
    for( int i=0; i<N+1; i++ ){
        sum += path[node][i];
    }
    return sum;
}

void Propositions::dfs(int node) {
    vis[node] = true;
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}

void Propositions::detect() {
    cin >> start >> end;
    step[end] = 1; // é‡è¦åˆå§‹åŒ–
    vis[end] = true; // é‡è¦åˆå§‹åŒ–
    dfs(start);
    cout << step[start] << " " ;
    if( isLogic ) cout << "Yes";
    else cout << "No";
}

int main() {
    Propositions p;
    p.insertPath();
    p.detect();
    return 0;
}

```

## 7-4 æ£®æ£®æ—…æ¸¸

**çŸ¥è¯†ç‚¹**ï¼šæœ€çŸ­è·¯å¾„ã€é‚»æ¥è¡¨

**æ€è·¯**ï¼šç”¨Dijskraæœ€çŸ­è·¯ç®—æ³•åˆ†åˆ«æ±‚å‡º

1.ä½¿ç”¨ç°é‡‘ä»åŸå¸‚1å‡ºå‘ï¼Œåˆ°è¾¾æ‰€æœ‰åŸå¸‚çš„æœ€å°èŠ±è´¹ï¼ˆå‚¨å­˜åœ¨`oneToOthers`å†…ï¼‰
2.ä½¿ç”¨æ—…æ¸¸é‡‘ä»åŸå¸‚nå‡ºå‘ï¼Œåˆ°è¾¾æ‰€æœ‰åŸå¸‚çš„æœ€å°èŠ±è´¹ï¼ˆå‚¨å­˜åœ¨`othersToN`å†…ï¼‰

åœ¨ç¬¬iä¸ªåŸå¸‚å°†ç°é‡‘æ¢æˆæ—…æ¸¸é‡‘çš„æƒ…å†µä¸‹æ‰€éœ€è¦çš„ç°é‡‘æ€»é¢ä¸º

`all_cash = oneToOthers[i] + othersToN[i]` 

ï¼ˆå³ä»åŸå¸‚1åˆ°è¾¾ç¬¬iä¸ªåŸå¸‚æ‰€éœ€è¦çš„æœ€å°ç°é‡‘æ•° + ä»ç¬¬iä¸ªåŸå¸‚åˆ°åŸå¸‚næ‰€éœ€è¦çš„æœ€å°æ—…æ¸¸é‡‘æ•°æ‰€è½¬æ¢æˆçš„ç°é‡‘æ•°é‡ï¼‰

ç„¶åå†é€šè¿‡æšä¸¾ä¸­è½¬ç‚¹`i`çš„æ–¹å¼ï¼Œå¾—åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚ä¸ºäº†è®©Dijkstraç®—æ³•æ›´æœ‰æ•ˆç‡ï¼Œå¯ä»¥å­˜å‚¨åå‘è·¯å¾„ã€‚

**ç»†èŠ‚**ï¼š

* è·¯å¾„çš„å­˜å‚¨ã€‚
  * ä½¿ç”¨é‚»æ¥è¡¨ï¼Œè€Œä¸æ˜¯é‚»æ¥çŸ©é˜µï¼Œå› ä¸º1w*1wçš„äºŒç»´æ•°ç»„ä¼šè¶…å†…å­˜ã€‚
  * å­˜å‚¨è·¯å¾„çš„æ•°æ®ç»“æ„ä¸ºï¼š`myvector<Mypair> path[100005], rpath[100005]`ï¼Œå…¶ä¸­`myvector`æ˜¯è‡ªå·±å®šä¹‰çš„ç±»ï¼Œå®ç°ç±»ä¼¼vectorçš„åŠŸèƒ½ï¼Œå…¶æœ€å¤§çš„ç‰¹ç‚¹æ˜¯é•¿åº¦å¯å˜ï¼›`Mypair`æ˜¯è‡ªå·±å®šä¹‰çš„ç»“æ„ä½“ï¼Œå®ç°ç±»ä¼¼pairçš„åŠŸèƒ½ã€‚
  * `path`å­˜å‚¨çš„æ˜¯ä¸€ä¸ªåŸå¸‚åˆ°å¦ä¸€ä¸ªåŸå¸‚æ‰€éœ€è¦ç°é‡‘ã€‚`rpath`å­˜å‚¨çš„æ˜¯ç›¸åè·¯å¾„æ‰€éœ€è¦çš„æ—…æ¸¸é‡‘ã€‚
  * ä¸¾ä¸ªä¾‹å­ï¼Œå¯¹äºè¾“å…¥`u v c d`ï¼Œ`path[u].push_back(Mypair(v, c))`ï¼Œ`rpath[v].push_back(Mypair(u,d))`
* Dijkstraæœ‰æšä¸¾å†™æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n*2)ï¼Œnæ˜¯èŠ‚ç‚¹ä¸ªæ•°ã€‚è¿˜æœ‰åŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„å†™æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(ElogV)ã€‚è¿™é‡Œä½¿ç”¨åè€…ã€‚
* æœ¬é¢˜çš„æœ€åä¸€æ­¥æ˜¯æ›´æ–°æ±‡ç‡ï¼Œä¹Ÿæœ‰ä¸¤ç§æ“ä½œï¼š
  * æ¯æ¬¡æ›´æ–°æ±‡ç‡åéƒ½æšä¸¾ä¸€æ¬¡ä¸­è½¬ç‚¹ï¼Œæ‰¾åˆ°æœ€å°‘èŠ±è´¹ï¼Œç„¶åè¾“å‡ºã€‚æ—¶é—´å¤æ‚åº¦é«˜ï¼Œ3ä¸ªç‚¹è¿‡ä¸å»ï¼Œåªèƒ½å¾—21åˆ†ã€‚
  * æšä¸¾ä¸­è½¬ç‚¹ï¼Œç”¨ä¸€ä¸ª`multiset`ï¼ˆå…¶ç‰¹ç‚¹æ˜¯æœ‰åºï¼Œèƒ½å¤Ÿå¿«é€Ÿæ’å…¥å’Œåˆ é™¤ï¼‰ç»´æŠ¤ã€‚æ¯æ¬¡æ›´æ–°æ±‡ç‡éƒ½åˆ é™¤æ—§çš„ï¼Œæ’å…¥æ–°çš„ã€‚æ—¶é—´å¤æ‚åº¦ä½ï¼Œä½†æ˜¯å¾ˆéš¾å®ç°ï¼ˆçº¢é»‘æ ‘ï¼‰ã€‚

**21åˆ†ä»£ç **ï¼ˆä¸‰ä¸ªæµ‹è¯•ç‚¹è¶…æ—¶ï¼‰ï¼š

```c++
#include <iostream>
#define int long long 
const int N = 100005; // æœ€å¤§èŠ‚ç‚¹æ•°
using namespace std;

// å®ç°Mypair
struct Mypair
{
    int first;
    int second;

    // é»˜è®¤æ„é€ å‡½æ•°
    Mypair()
            :first(0),second(0) {}  //ç”¨0,0åˆå§‹åŒ–
    //æ„é€ å‡½æ•°
    Mypair(const int&a,const int&b)
            :first(a),second(b) {}
};
// ä¸ºäº†åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¯¹æ“ä½œç¬¦é‡è½½
bool operator==(const Mypair&s1,const Mypair&s2)
{
    return s1.first==s2.first&&s1.second==s2.second;
}

bool operator>(const Mypair&s1,const Mypair&s2)
{
    return (s1.first>s2.first)||(!(s1.first<s2.first)&&s1.second>s2.second);
}

bool operator<(const Mypair&s1, const Mypair&s2)
{
    return (s1.first<s2.first)||(!(s1.first>s2.first)&&s1.second<s2.second);
}

// å®ç°ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå¤§é¡¶å †ï¼‰
class PriorityQueue
{
private:
    Mypair* pArray;
    int m_length;
public:
    PriorityQueue(int N) {
        // ä¸ºåç»­æ ¹èŠ‚ç‚¹ç›´æ¥ä»1å¼€å§‹ä½œå‡†å¤‡
        pArray = new Mypair[N];
        m_length = 0;
    }
// è¿”å›å †é¡¶
    Mypair Top(){
        return pArray[1];
    }
// åˆ é™¤å †é¡¶
    Mypair delMax() {
        // å¤§æ ¹å †ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæœ€å¤§
        Mypair max = pArray[1];
        // å°†ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢,å¹¶ä½¿é•¿åº¦å‡ä¸€ï¼Œå³åˆ é™¤æœ€å¤§çš„å…ƒç´ 
        swap(pArray[1], pArray[m_length--]);
        // é˜²æ­¢å¯¹è±¡æ¸¸ç¦»
        pArray[m_length + 1] = Mypair();
        // ä¸‹æ²‰æ¢å¤å †çš„æœ‰åºæ€§
        sink(1);
        // è¿”å›æœ€å¤§çš„èŠ‚ç‚¹å€¼
        return max;

    }
// æ’å…¥å…ƒç´ 
    void insert(Mypair v) {
        // å°†å€¼væ’å…¥åˆ°pArray[1]ä½ç½®å¤„ï¼Œæ‰€ä»¥è¿™é‡Œç”¨çš„å‰ç½®++
        pArray[++m_length] = v;
        // æ–°åŠ å…¥çš„å…ƒç´ ä¸Šæµ®
        swim(m_length);
    }

// åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool isEmpty() {
        return m_length == 0;
    }
// é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°
    int size() {
        return m_length;
    }

    // å‘ä¸Šæµ®
    void swim(int k) {
        // åˆ¤æ–­æœ€ä¸‹å±‚çš„å¶å­èŠ‚ç‚¹å€¼å¦‚æœå¤§äºå…¶çˆ¶èŠ‚ç‚¹åˆ™è¿›å…¥å¾ªç¯ä¸Šæµ®
        while (k > 1 && pArray[k] > pArray[k / 2]) {
            // äº¤æ¢çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹
            swap(pArray[k / 2], pArray[k]);
            // kæ•°å€¼å‡å°ç»§ç»­å‘ä¸Šæµ®
            k /= 2;
        }
    }
    // å‘ä¸‹æ²‰
    void sink(int k) {
        while (2 * k <= m_length)
        {
            // ç”±äºå †çš„æ€§è´¨çˆ¶èŠ‚ç‚¹ä¸ºkåˆ™å…¶å·¦å­æ ‘ä¸º2*kå³j
            int j = 2 * k;
            // è¿™é‡Œå…ˆæ¯”è¾ƒå·¦å­æ ‘å’Œå³å­æ ‘çš„å¤§å°ï¼Œå°†æœ€å¤§çš„é‚£ä¸ªé”®è®°å½•ä¸‹æ¥å†å’Œçˆ¶èŠ‚ç‚¹æ¯”è¾ƒ
            if (j < m_length && (pArray[j] < pArray[j + 1])) j++;
            // å’Œçˆ¶èŠ‚ç‚¹æ¯”è¾ƒå¦‚æœçˆ¶èŠ‚ç‚¹æ¯”æœ€å¤§çš„å­èŠ‚ç‚¹è¿˜è¦å¤§ï¼Œåˆ™ç›´æ¥é€€å‡ºå¾ªç¯
            if (pArray[k] > pArray[j]) break;
            // å¦‚æœçˆ¶èŠ‚ç‚¹æ¯”å­èŠ‚ç‚¹å°åˆ™äº¤æ¢
            swap(pArray[k], pArray[j]);
            // kå€¼å˜å¤§ç»§ç»­ä¸‹æ²‰
            k = j;
        }
    }
};


// å®ç°myvector
template<typename T>
class myvector{
public:
    typedef T value_type;
    typedef T* iterator;
private:
    value_type* _data;
    size_t _size;
    size_t _capacity;

public:
    myvector():_data(NULL),_size(0),_capacity(0){}
    ~myvector(){
        delete [] _data;
        _data = NULL;
        _size = 0;
        _capacity = 0;
    }
    myvector(const myvector& vec){
        _size = vec._size;
        _capacity = vec._capacity;
        _data = new value_type[_capacity];
        for(int i=0;i<_size;++i){
            _data[i] = vec._data[i];
        }
    }
    myvector& operator=(const myvector& vec){
        if(this == &vec) return *this;
        value_type* temp = new value_type[vec._capacity];
        for(int i=0;i<vec._size;++i){
            temp[i] = vec._data[i];
        }
        delete [] _data;
        _data = temp;
        _size = vec._size;
        _capacity = vec._capacity;
        return *this;
    }
    void push_back(value_type val){
        if(0 == _capacity){
            _capacity = 1;
            _data = new value_type[1];
        }else if(_size+1 > _capacity){
            _capacity *= 2;
            value_type* temp = new value_type[_capacity];
            for(int i=0;i<_size;++i){
                temp[i] = _data[i];
            }
            delete [] _data;
            _data = temp;
        }
        _data[_size] = val;
        ++_size;
    }

    size_t size()const{ return _size;}
== 0;}
    value_type& operator[](size_t index){
        return _data[index];
    }

    void erase(iterator it){
        size_t index = it - _data;
        for(int i=index;i<_size-1;++i){
            _data[i] = _data[i+1];
        }
        --_size;
    }

    iterator begin(){ return _data; }
    iterator end(){ return _data + _size; }
};


// æ‰¾åˆ°æœ€çŸ­è·¯
void dijkstra( int from, bool vis[], myvector<Mypair> (&path)[N], int dist[], int n ){
    PriorityQueue que(100005); // å¤§é¡¶å †
    Mypair tmp(0, from);
    que.insert(tmp);
    while(!que.isEmpty()){
        int x, w;
        w = que.Top().first; x = que.Top().second;
        que.delMax();
        if( vis[x] ) continue;
        vis[x] = true;
        dist[x] = -w;
        for( int i=0; i<path[x].size(); i++ ){
            int y, w;
            y = path[x][i].first;
            w = path[x][i].second;
            if( vis[y] ) continue;
            que.insert({-dist[x]-w, y});
        }
    }
}
// ç¡®å®šä¸­è½¬ç‚¹iï¼Œæ±‚èŠ±è´¹ã€‚ä¸èƒ½æ•´é™¤çš„è¦+1
int TurnToCash(int othersToN[], int oneToOthers[], int a[], int i){
    int dToC = othersToN[i] % a[i] ? othersToN[i] / a[i] + 1 : othersToN[i] / a[i];
    return oneToOthers[i] + dToC;
}


signed main() {
  // è¾“å…¥è·¯å¾„
    int n, m, q; cin >> n >> m >> q;
    myvector<Mypair> path[N], rpath[N];
    while( m-- ){
        int u, v, c, d; cin >> u >> v >> c >> d;
        Mypair v_c(v, c);
        Mypair u_d(u, d);
        path[u].push_back(v_c);
        rpath[v].push_back(u_d);
    }
  // è¾“å…¥æ±‡ç‡
    int a[N];
    for( int i=1; i<=n; i++ ) cin >> a[i];
    int oneToOthers[N];
    int othersToN[N];
    bool vis[N] = {false};
    bool rvis[N] = {false};
  // æ±‚æœ€çŸ­è·¯ï¼Œå’Œåå‘æœ€çŸ­è·¯
    dijkstra(1, vis, path, oneToOthers, n);
    dijkstra(n, rvis, rpath, othersToN, n);

//    multiset<int> ms;
// æšä¸¾ä¸­è½¬ç‚¹
    while( q-- ){
        int node, d; cin >> node >> d;
        if( vis[node] && rvis[node] ) a[node] = d;
      // ç”¨minå€¼ç»´æŠ¤æœ€å°çš„èŠ±è´¹
        int min = 9223372036854775807;
        for( int i=1; i<=n; i++ ){
            if( vis[i] && rvis[i] ){
                if( min > TurnToCash(othersToN, oneToOthers, a, i))
                    min = TurnToCash(othersToN, oneToOthers, a, i);
            }

        }
        cout << min << endl;
    }
    return 0;
}

```

**æ»¡åˆ†ä½†æ˜¯ç”¨äº†multisetçš„ä»£ç **ï¼š

æŠŠæšä¸¾ä¸­è½¬ç‚¹é‚£ä¸€éƒ¨åˆ†æ”¹æˆï¼š

```c++
#include <set>

multiset<int> ms;
// å…ˆæ’å…¥
for( int i=1; i<=n; i++ ){
  if( vis[i] && rvis[i] ){
    ms.insert(TurnToCash(othersToN, oneToOthers, a, i) );
  }
}
while( q-- ){
  int node, d; cin >> node >> d;
  if( vis[node] && rvis[node] ){
    // æ¯æ¬¡æ›´æ–°æ±‡ç‡ï¼Œå…ˆåˆ é™¤æ—§æ±‡ç‡ï¼Œå†æ’å…¥æ–°çš„
    ms.erase(ms.find(TurnToCash(othersToN, oneToOthers, a, node)) );
    a[node] = d;
    ms.insert( TurnToCash(othersToN, oneToOthers, a, node) );
  }
  // è¿”å›é¡¶éƒ¨å…ƒç´ å°±å¯ä»¥å•¦
  cout << *ms.begin() << endl;
}
```

**ç®€å•æè¿°Dijkstraç®—æ³•**ï¼š

`dist[i]`è¡¨ç¤ºä»åˆå§‹èŠ‚ç‚¹åˆ°ç¬¬iä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œåˆå§‹ä¸ºæ— ç©·å¤§ï¼Œæ¯æ¬¡ä»`dist[]`é‡Œé€‰å–æœªæœç´¢è¿‡çš„æœ€å°çš„èŠ‚ç‚¹ï¼Œç”¨å®ƒç»§ç»­æ›´æ–°`dist[]`ã€‚å¯ä»¥ç”¨`vis[]`è®°å½•å·²æœç´¢èŠ‚ç‚¹ï¼Œç”¨`pre[]`è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å‰é¢èŠ‚ç‚¹ï¼Œç”¨priority_queueä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ã€‚

## 7-5 Hand-made Cream

**çŸ¥è¯†ç‚¹**ï¼šåŠ¨æ€è§„åˆ’

**æ€è·¯**ï¼šè€ƒå¯Ÿä»ç¬¬1ä¸ªé¢åŒ…`bread[1]`ï¼Œé€‰åˆ°ç¬¬iä¸ªé¢åŒ…`bread[i]`å’Œä»`cream[1]`åˆ°`cream[j]`ï¼Œä¹˜ç§¯æœ€å¤§çš„æ­é…`dp[i][j]`ï¼Œæœ‰å¦‚ä¸‹æƒ…å†µï¼š

* å¦‚æœå°†ç¬¬iä¸ªé¢åŒ…å’Œç¬¬jä¸ªé¢åŒ…æ­é…ï¼Œé‚£ä¹ˆ`dp[i][j] = dp[i-1][j-1] + bread[i]*cream[j]`ï¼›
* å¦‚æœä¸æ­é…ï¼Œé‚£ä¹ˆç­‰äºå‰ä¸€ä¸ªé¢åŒ…ï¼Œæˆ–è€…å‰ä¸€ä¸ªå†°æ·‡æ·‹çš„ç»“è®ºï¼Œå³`dp[i][j] = dp[i-1][j]`æˆ–è€…`dp[i][j] = dp[i][j-1]`

å› ä¸ºè¦æ±‚æœ€å¤§çš„å€¼ï¼Œæ‰€ä»¥ç»¼åˆä¸€ä¸‹ï¼š`dp[i][j] = max(dp[i-1][j-1]+bread[i]*cream[j],dp[i-1][j],dp[i][j-1])`

åˆå§‹åŒ–`dp[0][0]=0`,`dp[1][0]=0`,`dp[0][1]=0`ï¼Œç”¨ä¸¤ä¸ªå¾ªç¯ï¼ŒåŠ¨æ€æ›´æ–°ä¸€ä¸‹`dp`è¡¨å°±å¯ä»¥å•¦ï¼Œä¸‹é¢æ˜¯é¢˜ç›®æ ·ä¾‹æœ€ç»ˆå¾—åˆ°çš„dpè¡¨ï¼š

| bread\cream | 10   | 8    | 11   | 9    |
| ----------- | ---- | ---- | ---- | ---- |
| -1          | 0    | 0    | 0    | 0    |
| 10          | 100  | 100  | 110  | 110  |
| 8           | 100  | 164  | 188  | 188  |

**ä»£ç **ï¼š

```c++
#include <iostream>
using namespace std;

int max(int a, int b, int c){
    if(a >= b && a >= c) return a;
    else{
        if(b >= c)return b;
        else return c;
    }
}

int max(int a, int b){
    if(a >= b) return a;
    else return b;
}

int main() {
    int N, M; cin >> N >> M;
    int a[1005], b[1005];
    for( int i=0; i<N; i++ ) cin >> a[i+1];
    for( int i=0; i<M; i++ ) cin >> b[i+1];

    int dp[1005][1005], res = 0;
    for( int i=1; i<=N; i++ ){
        for( int j=1; j<=M; j++ ){
            dp[i][j] = max(dp[i-1][j-1]+a[i]*b[j], dp[i-1][j], dp[i][j-1]);
            cout << dp[i][j] << " " ;
            res = max(res, dp[i][j]);
        }
        cout << endl;
    }
    cout << res;
    return 0;
}

```

## *å·¥æ¬²å–„å…¶äº‹ å¿…å…ˆåˆ©å…¶å™¨*

*æœ‰ä¸€è¯´ä¸€ï¼ŒClionçœŸçš„å¾ˆå¥½ç”¨ï¼Œéå¸¸æ™ºèƒ½çš„ä»£ç æç¤ºå’Œä»£ç è¡¥å…¨æ˜¯åº”ä»˜è¯­æ³•å¤æ‚çš„c++è¯­è¨€çš„æœ‰åŠ›å·¥å…·ã€‚*

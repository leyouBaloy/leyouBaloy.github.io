<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>数据结构与算法实习第二阶段 - 百乐的编程学习</title><meta name="Description" content=""><meta property="og:title" content="数据结构与算法实习第二阶段" />
<meta property="og:description" content="7-1 Table Tennis 知识点：模拟，队列 思路：把所有玩家按到达顺序排序，逐个处理，分如下情况： 找到所有桌子中最早结束当前服务的桌子。判断：如果这个桌子当前服" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.leyoubaloy.xyz/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-02T15:38:13+08:00" />
<meta property="article:modified_time" content="2022-07-02T15:38:13+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构与算法实习第二阶段"/>
<meta name="twitter:description" content="7-1 Table Tennis 知识点：模拟，队列 思路：把所有玩家按到达顺序排序，逐个处理，分如下情况： 找到所有桌子中最早结束当前服务的桌子。判断：如果这个桌子当前服"/>
<meta name="application-name" content="百乐的编程学习">
<meta name="apple-mobile-web-app-title" content="百乐的编程学习"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/qq%E5%A4%B4%E5%83%8F.jpg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.leyoubaloy.xyz/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/" /><link rel="prev" href="https://www.leyoubaloy.xyz/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "数据结构与算法实习第二阶段",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.leyoubaloy.xyz\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5\/"
        },"genre": "posts","wordcount":  7276 ,
        "url": "https:\/\/www.leyoubaloy.xyz\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5\/","datePublished": "2022-07-02T15:38:13+08:00","dateModified": "2022-07-02T15:38:13+08:00","publisher": {
            "@type": "Organization",
            "name": "孙百乐"},"author": {
                "@type": "Person",
                "name": "孙百乐"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="百乐的编程学习">百乐的编程学习</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> 首页 </a><a class="menu-item" href="/categories/%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB"><i class='fas fa-desktop'></i> 技能分享 </a><a class="menu-item" href="/bookshelf"><i class='fas fa-book'></i> 书影记录 </a><a class="menu-item" href="/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0"><i class='fas fa-pen-nib'></i> 随笔杂记 </a><a class="menu-item" href="/categories/"><i class='fas fa-archive'></i> 文章分类 </a><a class="menu-item" href="https://www.yuque.com/leyoubaloy/ev6tnq" rel="noopener noreffer" target="_blank"> Vis </a><a class="menu-item" href="/about/"> 关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="百乐的编程学习">百乐的编程学习</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/" title="">首页</a><a class="menu-item" href="/categories/%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB" title=""><i class='fas fa-desktop'></i>技能分享</a><a class="menu-item" href="/bookshelf" title=""><i class='fas fa-book'></i>书影记录</a><a class="menu-item" href="/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0" title=""><i class='fas fa-pen-nib'></i>随笔杂记</a><a class="menu-item" href="/categories/" title=""><i class='fas fa-archive'></i>文章分类</a><a class="menu-item" href="https://www.yuque.com/leyoubaloy/ev6tnq" title="" rel="noopener noreffer" target="_blank">Vis</a><a class="menu-item" href="/about/" title="">关于我</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">数据结构与算法实习第二阶段</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>孙百乐</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E5%88%B7%E9%A2%98/"><i class="far fa-folder fa-fw"></i>刷题</a>&nbsp;<a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-07-02">2022-07-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7276 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;<span id="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/" class="leancloud_visitors" data-flag-title="数据结构与算法实习第二阶段">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#7-1-table-tennis">7-1 Table Tennis</a></li>
    <li><a href="#7-2-分而治之">7-2 分而治之</a></li>
    <li><a href="#7-3-那就别担心了">7-3 那就别担心了</a></li>
    <li><a href="#7-4-森森旅游">7-4 森森旅游</a></li>
    <li><a href="#7-5-hand-made-cream">7-5 Hand-made Cream</a></li>
    <li><a href="#工欲善其事-必先利其器"><em>工欲善其事 必先利其器</em></a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="7-1-table-tennis">7-1 Table Tennis</h2>
<p><strong>知识点</strong>：模拟，队列</p>
<p><strong>思路</strong>：把所有玩家按到达顺序排序，逐个处理，分如下情况：</p>
<ul>
<li>找到所有桌子中最早结束当前服务的桌子。判断：如果这个桌子当前服务的结束时间超过9点，那剩下的玩家都不用处理了，不可能被服务。否则再继续下面的过程。
<ul>
<li>如果这个桌子是为vip预留的：
<ul>
<li>这个人是普通人，除非他后面没有vip到来，桌子才给他用</li>
<li>如果这个人是vip，这个桌子分配给他。 处理下一个人</li>
</ul>
</li>
<li>如果这个桌子是普通桌子：
<ul>
<li>如果这个人是普通人，那么这个桌子分配给他。处理下一个人</li>
<li>如果这个人是vip，首先去看在他来之前有没有空下来的vip桌子，如果有，就让他去那个vip桌子，如果没有，就把这个普通桌子给他用。处理下一个人。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>细节</strong>：</p>
<ul>
<li>
<p>时间以从0点经过的秒数存储</p>
</li>
<li>
<p>结构体数组<code>customers[10005]</code>储存顾客，字段有：到达时间<code>arriveTime</code>，开始被服务时间 <code>startTime</code>，玩耍时间 <code>playTime</code> ，是否VIP<code>isVip</code>，是否被服务过 <code>isServed</code></p>
</li>
<li>
<p>结构体数组<code>table[105]</code>储存桌子，字段有：结束服务的时间<code>endTime</code>，服务顾客数<code>serveCount</code>，是否VIP<code>isVip</code></p>
</li>
<li>
<p>排序 —&gt; 借用第一阶段第五题的堆排序，将<code>cmp</code>函数作为参数传进去</p>
</li>
<li>
<p>这题细节太多了，看代码注释</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++">    <span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">intMAX</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

    <span class="c1">// 俱乐部开门时间，以 s 为单位
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">club_open_time</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">// 俱乐部关门时间，以 s 为单位
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">club_close_time</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">21</span><span class="p">;</span>


    <span class="k">struct</span> <span class="nc">Customers</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">arriveTime</span><span class="p">,</span> <span class="n">startTime</span><span class="p">,</span> <span class="n">playTime</span><span class="p">;</span> <span class="c1">// 到达时间，开始时间，玩耍时间
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">isVip</span><span class="p">,</span> <span class="n">isServed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 是否是 vip，是否被服务过了
</span><span class="c1"></span>    <span class="p">}</span><span class="n">customer</span><span class="p">[</span><span class="mi">10005</span><span class="p">];</span>

    <span class="k">struct</span> <span class="nc">Table</span> <span class="p">{</span>
        <span class="c1">// 刚开始全是8:00开始服务
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">club_open_time</span><span class="p">,</span> <span class="n">serveCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 当前服务结束时间，已服务玩家个数
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">isVip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 是否是为vip预留的桌子
</span><span class="c1"></span>    <span class="p">}</span><span class="n">table</span><span class="p">[</span><span class="mi">105</span><span class="p">];</span>

    <span class="c1">// 按到达的先后顺序排队
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">cmp_by_arrive</span><span class="p">(</span><span class="n">Customers</span> <span class="n">a</span><span class="p">,</span> <span class="n">Customers</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">arriveTime</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">arriveTime</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 输出时，按被服务时间排序
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">cmp_by_starttime</span><span class="p">(</span><span class="n">Customers</span> <span class="n">a</span><span class="p">,</span> <span class="n">Customers</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">startTime</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">startTime</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Heapify</span><span class="p">(</span><span class="n">Customers</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">cmp</span><span class="p">)(</span><span class="n">Customers</span> <span class="n">a</span><span class="p">,</span> <span class="n">Customers</span> <span class="n">b</span><span class="p">)){</span>
        <span class="c1">// arr 存储堆的数组，n 数组长度， i 维护节点的下标
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 假设最大节点
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">lson</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rson</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lson</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">cmp</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">lson</span><span class="p">])){</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">lson</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rson</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">cmp</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">rson</span><span class="p">])){</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">rson</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">){</span>
            <span class="n">Customers</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">Heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="c1">// 堆排序入口
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">Customers</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">cmp</span><span class="p">)(</span><span class="n">Customers</span> <span class="n">a</span><span class="p">,</span> <span class="n">Customers</span> <span class="n">b</span><span class="p">)){</span>
        <span class="c1">// 建堆，从底往上构建
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 从最后一个元素的父节点开始
</span><span class="c1"></span>            <span class="n">Heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 排序
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="n">Customers</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">Heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// 将某个桌子提供给某个顾客
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">AssignTable</span><span class="p">(</span> <span class="kt">int</span> <span class="n">tab_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cus_id</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//    cout &lt;&lt; &#34;tab_id &#34; &lt;&lt; tab_id &lt;&lt; &#34; cus_id &#34; &lt;&lt;  cus_id &lt;&lt; endl;
</span><span class="c1"></span>        <span class="c1">// 玩家来的时候，这个桌子已空闲，玩家可以直接开始玩
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">tab_id</span><span class="p">].</span><span class="n">endTime</span> <span class="o">&lt;=</span> <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">arriveTime</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">arriveTime</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 玩家来的时候这个桌子还在服务上一个人，需要等它当前服务结束
</span><span class="c1"></span>            <span class="c1">// 所以玩家开始玩的时间应该是这个桌子当前服务结束的时间
</span><span class="c1"></span>            <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">tab_id</span><span class="p">].</span><span class="n">endTime</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 开始新的服务，更新这个桌子当前服务的结束时间
</span><span class="c1"></span>        <span class="n">table</span><span class="p">[</span><span class="n">tab_id</span><span class="p">].</span><span class="n">endTime</span> <span class="o">=</span> <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">startTime</span> <span class="o">+</span> <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">playTime</span><span class="p">;</span>
        <span class="c1">// 这个桌子的服务人数增加
</span><span class="c1"></span>        <span class="n">table</span><span class="p">[</span><span class="n">tab_id</span><span class="p">].</span><span class="n">serveCount</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 找到这个人后面第一个会员未被服务的会员
</span><span class="c1"></span>    <span class="c1">// N,总顾客数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">FindNextVip</span><span class="p">(</span><span class="kt">int</span> <span class="n">cus_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cus_id</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">cus_id</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 是会员！且未被服务！
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span> <span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">isVip</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">isServed</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">cus_id</span><span class="p">;</span>
            <span class="n">cus_id</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
     <span class="c1">// 找到第一个结束服务的桌子，K为桌子数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">GetMinEndTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">cus_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_end</span> <span class="o">=</span> <span class="n">intMAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">customer</span><span class="p">[</span><span class="n">cus_id</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endTime</span> <span class="p">){</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endTime</span> <span class="o">&lt;</span> <span class="n">min_end</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">min_end</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endTime</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

     <span class="c1">// 为会员找桌子，K 为桌子总数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">FindTableForVIP</span><span class="p">(</span> <span class="kt">int</span> <span class="n">K</span> <span class="p">){</span>
        <span class="c1">// 先看所有给会员预留的桌子是否有空闲，有就给他，没有就把这个普通桌子给他
</span><span class="c1"></span>        <span class="c1">// 找到所有会员桌中最早结束的那个
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">t_vip</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_vip_min_end</span> <span class="o">=</span> <span class="n">intMAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isVip</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endTime</span> <span class="o">&lt;</span> <span class="n">t_vip_min_end</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">t_vip</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">t_vip_min_end</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endTime</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">t_vip</span><span class="p">;</span>
    <span class="p">}</span>

		<span class="c1">// 自己写的round，四舍五入求整数
</span><span class="c1"></span>    <span class="kt">double</span> <span class="nf">round</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 输入玩家
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">N</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">hh</span><span class="p">,</span><span class="n">mm</span><span class="p">,</span><span class="n">ss</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">vip</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cus_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 在营业时间内的顾客数量，跟 N 不一样！
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span> <span class="n">N</span><span class="o">--</span> <span class="p">){</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d:%d:%d %d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vip</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">arrive</span> <span class="o">=</span> <span class="n">hh</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">+</span> <span class="n">mm</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">ss</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arrive</span> <span class="o">&gt;=</span> <span class="n">club_close_time</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 玩家来的时候俱乐部关门
</span><span class="c1"></span>            <span class="n">customer</span><span class="p">[</span><span class="n">cus_cnt</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">=</span> <span class="n">arrive</span><span class="p">;</span> <span class="c1">// 玩家到达时间，以秒记
</span><span class="c1"></span>            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">7200</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="mi">7200</span><span class="p">;</span>
            <span class="n">customer</span><span class="p">[</span><span class="n">cus_cnt</span><span class="p">].</span><span class="n">playTime</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// 一个玩家最多玩2小时
</span><span class="c1"></span>            <span class="n">customer</span><span class="p">[</span><span class="n">cus_cnt</span><span class="p">].</span><span class="n">isVip</span> <span class="o">=</span> <span class="n">vip</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 是否是vip
</span><span class="c1"></span>            <span class="c1">// 把玩家被服务时间初始化为俱乐部关门时间，便于最后输出时淘汰掉哪些未被服务的玩家
</span><span class="c1"></span>            <span class="n">customer</span><span class="p">[</span><span class="n">cus_cnt</span><span class="p">].</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">club_close_time</span><span class="p">;</span>
            <span class="n">cus_cnt</span> <span class="o">++</span> <span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 输入桌子
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>
        <span class="c1">// 读入M个vip桌子序号
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tab_id</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tab_id</span><span class="p">;</span>
            <span class="n">table</span><span class="p">[</span><span class="n">tab_id</span><span class="p">].</span><span class="n">isVip</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 玩家按到达时间排队
</span><span class="c1"></span>        <span class="n">HeapSort</span><span class="p">(</span><span class="n">customer</span><span class="p">,</span> <span class="n">cus_cnt</span><span class="p">,</span> <span class="n">cmp_by_arrive</span><span class="p">);</span>
        <span class="c1">// 逐个处理玩家
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cus_cnt</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">GetMinEndTable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="c1">// 找到第一个结束服务的桌子，K为桌子数
</span><span class="c1"></span>            <span class="c1">// 最早结束的桌子结束当前服务都要等到俱乐部关门了，顾客可以全回家了，没戏了
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">endTime</span> <span class="o">&gt;=</span> <span class="n">club_close_time</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="c1">// 如果这个桌子是给会员留的
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span> <span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">isVip</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 这个人也是会员
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isVip</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 并且没被服务过，就直接分配给他，
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isServed</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">AssignTable</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                        <span class="c1">// 标记这个会员被服务
</span><span class="c1"></span>                        <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isServed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="c1">// 然后处理下一个人，所以 i++
</span><span class="c1"></span>                        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// 服务过了就直接下一个
</span><span class="c1"></span>                        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">// 他是普通人
</span><span class="c1"></span>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 找到他后面第一个vip
</span><span class="c1"></span>                    <span class="c1">// 如果不存在，或者 存在，但是当前桌子结束服务的时候这个vip还没来，
</span><span class="c1"></span>                    <span class="c1">// 他才可以用这个桌子，
</span><span class="c1"></span>                    <span class="kt">int</span> <span class="n">next_vip</span> <span class="o">=</span> <span class="n">FindNextVip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cus_cnt</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">next_vip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">customer</span><span class="p">[</span><span class="n">next_vip</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">endTime</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">AssignTable</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                        <span class="c1">// 然后处理下一个人，所以 i++
</span><span class="c1"></span>                        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// 他后面有会员，而且这个会员的到达时间在这个桌子结束服务之前，
</span><span class="c1"></span>                        <span class="c1">// 这个桌子就给会员用
</span><span class="c1"></span>                        <span class="n">AssignTable</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">next_vip</span><span class="p">);</span>
                        <span class="c1">// 标记这个会员被服务
</span><span class="c1"></span>                        <span class="n">customer</span><span class="p">[</span><span class="n">next_vip</span><span class="p">].</span><span class="n">isServed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="c1">// 相当于这个人被插队了，下一个还是处理他，所以 i不变
</span><span class="c1"></span>                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1">// 普通桌子
</span><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 这个人是普通人就分配给他，
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isVip</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">AssignTable</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                    <span class="c1">// 这个人是会员，并且没被服务过，
</span><span class="c1"></span>                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isServed</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">t_vip</span> <span class="o">=</span> <span class="n">FindTableForVIP</span><span class="p">(</span> <span class="n">K</span> <span class="p">);</span> <span class="c1">// 为会员找桌子，K 为桌子总数
</span><span class="c1"></span>                    <span class="c1">// 最早结束的会员桌在他来之前服务完了，说明有可用的会员桌，分配给他，否则，没有可用的会员桌，把普通桌子分配给这个会员
</span><span class="c1"></span>                    <span class="p">(</span><span class="n">t_vip</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="p">[</span><span class="n">t_vip</span><span class="p">].</span><span class="n">endTime</span> <span class="o">&lt;=</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arriveTime</span><span class="p">)</span> <span class="o">?</span> <span class="n">AssignTable</span><span class="p">(</span><span class="n">t_vip</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">AssignTable</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                    <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isServed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 下一个
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 处理完所有玩家，按照被服务的开始时间排序
</span><span class="c1"></span>        <span class="n">HeapSort</span><span class="p">(</span><span class="n">customer</span><span class="p">,</span> <span class="n">cus_cnt</span><span class="p">,</span> <span class="n">cmp_by_starttime</span><span class="p">);</span>
        <span class="c1">// 输出结果，无法被服务的自动排除
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cus_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">startTime</span> <span class="o">&gt;=</span> <span class="n">club_close_time</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="c1">// 到达时间
</span><span class="c1"></span>            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%02d:%02d:%02d &#34;</span><span class="p">,</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span>
                   <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">%</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arriveTime</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
            <span class="c1">// 被服务时间
</span><span class="c1"></span>            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%02d:%02d:%02d &#34;</span><span class="p">,</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">startTime</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span>
                   <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">startTime</span> <span class="o">%</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">startTime</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
            <span class="c1">// 等待时间
</span><span class="c1"></span>            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%.0f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">round</span><span class="p">((</span><span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">startTime</span> <span class="o">-</span> <span class="n">customer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arriveTime</span><span class="p">)</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="c1">// 每个桌子服务了几个人
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="c1">//        cout &lt;&lt; &#34;i&#34; &lt;&lt; i &lt;&lt; endl;
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span> <span class="n">i</span><span class="o">==</span><span class="mi">1</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">serveCount</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">serveCount</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><h2 id="7-2-分而治之">7-2 分而治之</h2>
<p><strong>知识点</strong>：图论</p>
<p><strong>思路</strong>：</p>
<ul>
<li>思路一：记录邻接矩阵，输入时记录每个节点的度数。被摧毁的城市的度置为0，和它相邻的点度也-1。最后检查是否有度大于0的点，有就说明有城市相连通，输出NO，否则输出YES；</li>
<li>思路二：记录所有的边(u, v)，和被攻陷城池<code>lost[i]</code>。遍历边(u, v)，如果存在u或v没有被攻陷（即不在<code>lost</code>里面），说明有城市连通，输出NO，否则YES；</li>
</ul>
<p>因为这题最多有10005个点，使用邻接矩阵会超内存，所以采用第二种思路；</p>
<p><strong>细节</strong>：</p>
<ul>
<li>记录边可以使用两个数组<code>u[10005]</code>和<code>v[10005]</code>，第<code>i</code>条边的两个节点是<code>u[i]</code>和<code>v[i]</code></li>
<li>判断边中是否包含没被攻陷的城池<code>if( !lost[u[i]] &amp;&amp; !lost[v[i]] )</code></li>
</ul>
<p><strong>代码</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Citys</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">[</span><span class="mi">10005</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="mi">10005</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// 第 i 条边为 (u[i], v[i])
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">insertPath</span><span class="p">();</span> <span class="c1">// 输入路径
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">();</span> <span class="c1">// 输入一个方案，判断是否有效
</span><span class="c1"></span>    <span class="n">Citys</span><span class="p">();</span> <span class="c1">// 构造函数，输入N, M
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Citys</span><span class="o">::</span><span class="n">Citys</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Citys</span><span class="o">::</span><span class="n">insertPath</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Citys</span><span class="o">::</span><span class="n">isValid</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 输入攻破的城池
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">Np</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">Np</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lost</span><span class="p">[</span><span class="mi">10005</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Np</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="kt">int</span> <span class="n">city</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">city</span><span class="p">;</span>
        <span class="n">lost</span><span class="p">[</span><span class="n">city</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 判断
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">lost</span><span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lost</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">){</span> <span class="c1">// 如果都不是被攻陷的城池
</span><span class="c1"></span>            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 输入数据
</span><span class="c1"></span>    <span class="n">Citys</span> <span class="n">citys</span> <span class="o">=</span> <span class="n">Citys</span><span class="p">();</span>
    <span class="n">citys</span><span class="p">.</span><span class="n">insertPath</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">K</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">citys</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;YES&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;NO&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="7-3-那就别担心了">7-3 那就别担心了</h2>
<p><strong>知识点</strong>：dfs、时间复杂度</p>
<p><strong>思路</strong>：抽象一下：给定一个有向无环图（DAG），并且给出起点A和终点B，问从A出发的所有路径是否都能到达B，并且求出从A出发到达B的不同路径有多少条。</p>
<ul>
<li>第一个问题非常好解，只要从A开始DFS，如果搜到某个出度为0的点，并且这个点不是题面给出的B点，就说明并不是所有从A出发的路径都能到达B。</li>
<li>对于第二个问题，虽然这道题数据比较小，最多只有500个点，但是这题的时间限制是400ms，对于求解不同路径的问题，如果暴力搜索的话是一定会超时的。</li>
</ul>
<p>考察输入样例（自己编的）:</p>
<pre tabindex="0"><code>7 8
7 6
8 5
6 5
5 2
5 3
2 1
3 1
7 1
</code></pre><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg"
        data-srcset="https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg, https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg 1.5x, https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg 2x"
        data-sizes="auto"
        alt="https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg"
        title="7-3 那就别担心了题解DAG" /></p>
<p>很明显，从7到1有如下路径：</p>
<pre tabindex="0"><code>7 -&gt; 6 -&gt; 5 —&gt; 2 -&gt; 1
7 -&gt; 6 -&gt; 5 -&gt; 3 -&gt; 1
7 -&gt; 8 -&gt; 5 -&gt; 2 -&gt; 1
7 -&gt; 8 -&gt; 5 -&gt; 3 -&gt; 1
</code></pre><p>发现，从5到1有两条路径。在搜索时，经过7，6，5，会把这两条路径都搜索一遍；经过7，8，5，又会把这两条路径搜索一遍。这样就造成了时间的浪费。我们考虑，如果在经过6号节点到达5号节点，再到达终点1号节点的所有路径全部搜索完时，5号节点能够储存下“经过该节点有2条路径到达目标节点”这个信息，这样在从8号节点搜索到5号时，就不需要再重复地将接下来的路径全部搜索一遍了，直接从5号节点读到“接下来有2条不同的路径”这个信息。正好，DFS的“走到底再返回”的性质可以做到从尾到头，也就是从终点到起点记录信息，因此我们可以在DFS的过程中进行记忆化操作。</p>
<p>我们定义<code>step[i]</code>为“从<code>i</code>号节点到达目标节点的路径条数“，求解的目标是<code>step[A]</code>，定义<code>step[B] = 1</code>，并且标记𝐵B节点已经被访问过。在DFS的过程中，如果将要搜索的节点没有被访问过，就搜索，并记录下路径条数，当前节点直接加上待搜索（其实这时候已经搜索完了）的节点的路径条数。以上图为例，DFS的过程如下：</p>
<ol>
<li>初始化<code>step[]</code>数组为0，初始化<code>vis[]</code>数组为<strong>false</strong>，赋值<code>step[1]=1</code>, <code>vis[1]=true</code>;</li>
<li>从起点7开始DFS，赋值<code>vis[7]=true</code>。接下来想搜索6，<code>vis[6]==false</code>，进入；</li>
<li>从6节点开始DFS，赋值<code>vis[6]=true</code>。接下来想搜索5，<code>vis[5]==false</code>，进入；</li>
<li>从5节点开始DFS，赋值<code>vis[5]=true</code>。接下来想搜索2，<code>vis[2]==false</code>，进入；</li>
<li>从2节点开始DFS，赋值<code>vis[2]=true</code>。接下来想搜索1，<code>vis[1]==true</code>，不进入；累加路径条数<code>step[2]=step[2]+step[1]</code>，这时<code>step[2]=1</code>。2节点没有其他的路径，返回，<code>step[5]=step[5]+step[2]</code>,此时<code>step[5]=1</code></li>
<li>接下来想搜索3，赋值<code>vis[1]==true</code>，不进入；累加路径条数<code>step[3]=step[3]+step[1]</code>，这时<code>step[3]=1</code>。3节点没有其他的路径，返回,<code>step[5]=step[5]+step[3]</code>,此时<code>step[5]=2</code></li>
<li>5节点没有其他的路径，返回，<code>step[6]=step[6]+step[5]</code>，此时<code>step[6]=2</code>.</li>
<li>6没有其它节点了，返回7，<code>step[7]=step[7]+step[6]</code>，此时<code>step[7]=2</code>。继续搜索8。</li>
<li>从8开始DFS，赋值<code>vis[8]=true</code>，接下来又想搜索5，<code>vis[5]=true</code>，不进入，<code>step[8]=step[8]+step[5]</code>，此时<code>step[8]=2</code>；</li>
<li>没有其它路径了，返回7，<code>step[7]=step[7]+step[8]</code>，此时<code>step[7]=4</code>。没有其它节点了，递归结束。</li>
</ol>
<p><strong>细节</strong>：</p>
<ul>
<li>路径使用邻接矩阵存储（邻接表更节省空间，但因为不能使用<code>vector</code>，所以邻接表实现起来会麻烦一点）</li>
<li>判断能否“逻辑自洽”：出度为0且该节点不是终点，令全局变量<code>isLogic</code></li>
</ul>
<p>dfs的过程用代码实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">Propositions</span><span class="o">::</span><span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记访问
</span><span class="c1"></span>  <span class="c1">// 如果出度为0，且该节点不是终点，说明不是逻辑自洽的
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span> <span class="n">getOutdegree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">end</span> <span class="p">){</span>
        <span class="n">isLogic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="c1">// 继续dfs没有被访问过的节点，并且记录step
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">){</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">step</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>所有代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Propositions</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span> <span class="c1">// 起点和终点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">isLogic</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 是否逻辑自洽
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">path</span><span class="p">[</span><span class="mi">505</span><span class="p">][</span><span class="mi">505</span><span class="p">];</span> <span class="c1">// 邻接矩阵，在构建函数中初始化为0；
</span><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">step</span><span class="p">[</span><span class="mi">505</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// step[i] : 第 i 个点到终点的路径的个数
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="mi">505</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// 是否访问过
</span><span class="c1"></span>
    <span class="n">Propositions</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">insertPath</span><span class="p">();</span> <span class="c1">// 输入路径
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">getOutdegree</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">);</span> <span class="c1">// 计算一个节点的出度
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">);</span> <span class="c1">// 深度优先搜索
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">detect</span><span class="p">();</span> <span class="c1">// 入口，初始化，dfs和输出
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Propositions</span><span class="o">::</span><span class="n">Propositions</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">){</span>
            <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Propositions</span><span class="o">::</span><span class="n">insertPath</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">to</span><span class="p">;</span>
        <span class="n">path</span><span class="p">[</span><span class="n">from</span><span class="p">][</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Propositions</span><span class="o">::</span><span class="n">getOutdegree</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Propositions</span><span class="o">::</span><span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">getOutdegree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">end</span> <span class="p">){</span>
        <span class="n">isLogic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">){</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">step</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Propositions</span><span class="o">::</span><span class="n">detect</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">step</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 重要初始化
</span><span class="c1"></span>    <span class="n">vis</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 重要初始化
</span><span class="c1"></span>    <span class="n">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">step</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">isLogic</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Yes&#34;</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;No&#34;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Propositions</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">insertPath</span><span class="p">();</span>
    <span class="n">p</span><span class="p">.</span><span class="n">detect</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="7-4-森森旅游">7-4 森森旅游</h2>
<p><strong>知识点</strong>：最短路径、邻接表</p>
<p><strong>思路</strong>：用Dijskra最短路算法分别求出</p>
<p>1.使用现金从城市1出发，到达所有城市的最小花费（储存在<code>oneToOthers</code>内）
2.使用旅游金从城市n出发，到达所有城市的最小花费（储存在<code>othersToN</code>内）</p>
<p>在第i个城市将现金换成旅游金的情况下所需要的现金总额为</p>
<p><code>all_cash = oneToOthers[i] + othersToN[i]/a[i]</code>（a[i]是汇率，注意除不尽要+1）</p>
<p>（即从城市1到达第i个城市所需要的最小现金数 + 从第i个城市到城市n所需要的最小旅游金数所转换成的现金数量）</p>
<p>然后再通过枚举中转点<code>i</code>的方式，得到全局最优解。为了让Dijkstra算法更有效率，可以存储反向路径。</p>
<p><strong>细节</strong>：</p>
<ul>
<li>路径的存储。
<ul>
<li>使用邻接表，而不是邻接矩阵，因为1w*1w的二维数组会超内存。</li>
<li>存储路径的数据结构为：<code>myvector&lt;Mypair&gt; path[100005], rpath[100005]</code>，其中<code>myvector</code>是自己定义的类，实现类似vector的功能，其最大的特点是长度可变；<code>Mypair</code>是自己定义的结构体，实现类似pair的功能。</li>
<li><code>path</code>存储的是一个城市到另一个城市所需要现金。<code>rpath</code>存储的是相反路径所需要的旅游金。</li>
<li>举个例子，对于输入<code>u v c d</code>，<code>path[u].push_back(Mypair(v, c))</code>，<code>rpath[v].push_back(Mypair(u,d))</code></li>
</ul>
</li>
<li>Dijkstra有枚举写法，时间复杂度为O(n*2)，n是节点个数。还有基于优先队列的写法，时间复杂度为O(ElogV)。这里使用后者。</li>
<li>本题的最后一步是更新汇率，也有两种操作：
<ul>
<li>每次更新汇率后都枚举一次中转点，找到最少花费，然后输出。时间复杂度高，3个点过不去，只能得21分。</li>
<li>枚举中转点，用一个<code>multiset</code>（其特点是有序，能够快速插入和删除）维护。每次更新汇率都删除旧的，插入新的。时间复杂度低，但是很难实现（红黑树）。</li>
</ul>
</li>
</ul>
<p><strong>21分代码</strong>（三个测试点超时）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#define int long long 
</span><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100005</span><span class="p">;</span> <span class="c1">// 最大节点数
</span><span class="c1"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 实现Mypair
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mypair</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>

    <span class="c1">// 默认构造函数
</span><span class="c1"></span>    <span class="n">Mypair</span><span class="p">()</span>
            <span class="o">:</span><span class="n">first</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">second</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">//用0,0初始化
</span><span class="c1"></span>    <span class="c1">//构造函数
</span><span class="c1"></span>    <span class="n">Mypair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
            <span class="o">:</span><span class="n">first</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">second</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="c1">// 为了加入优先队列，对操作符重载
</span><span class="c1"></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">first</span><span class="o">==</span><span class="n">s2</span><span class="p">.</span><span class="n">first</span><span class="o">&amp;&amp;</span><span class="n">s1</span><span class="p">.</span><span class="n">second</span><span class="o">==</span><span class="n">s2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">first</span><span class="o">&gt;</span><span class="n">s2</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">s1</span><span class="p">.</span><span class="n">second</span><span class="o">&gt;</span><span class="n">s2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mypair</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">first</span><span class="o">&gt;</span><span class="n">s2</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">s1</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 实现优先队列（大顶堆）
</span><span class="c1"></span><span class="k">class</span> <span class="nc">PriorityQueue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Mypair</span><span class="o">*</span> <span class="n">pArray</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_length</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">PriorityQueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 为后续根节点直接从1开始作准备
</span><span class="c1"></span>        <span class="n">pArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Mypair</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
        <span class="n">m_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// 返回堆顶
</span><span class="c1"></span>    <span class="n">Mypair</span> <span class="nf">Top</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">pArray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="c1">// 删除堆顶
</span><span class="c1"></span>    <span class="n">Mypair</span> <span class="nf">delMax</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 大根堆第一个元素为最大
</span><span class="c1"></span>        <span class="n">Mypair</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pArray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 将第一个元素和最后一个元素交换,并使长度减一，即删除最大的元素
</span><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span><span class="n">pArray</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pArray</span><span class="p">[</span><span class="n">m_length</span><span class="o">--</span><span class="p">]);</span>
        <span class="c1">// 防止对象游离
</span><span class="c1"></span>        <span class="n">pArray</span><span class="p">[</span><span class="n">m_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mypair</span><span class="p">();</span>
        <span class="c1">// 下沉恢复堆的有序性
</span><span class="c1"></span>        <span class="n">sink</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 返回最大的节点值
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">max</span><span class="p">;</span>

    <span class="p">}</span>
<span class="c1">// 插入元素
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Mypair</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 将值v插入到pArray[1]位置处，所以这里用的前置++
</span><span class="c1"></span>        <span class="n">pArray</span><span class="p">[</span><span class="o">++</span><span class="n">m_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="c1">// 新加入的元素上浮
</span><span class="c1"></span>        <span class="n">swim</span><span class="p">(</span><span class="n">m_length</span><span class="p">);</span>
    <span class="p">}</span>

<span class="c1">// 判断是否为空
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// 队列元素个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_length</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 向上浮
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">swim</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断最下层的叶子节点值如果大于其父节点则进入循环上浮
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pArray</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pArray</span><span class="p">[</span><span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// 交换父节点和子节点
</span><span class="c1"></span>            <span class="n">swap</span><span class="p">(</span><span class="n">pArray</span><span class="p">[</span><span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="n">pArray</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
            <span class="c1">// k数值减小继续向上浮
</span><span class="c1"></span>            <span class="n">k</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 向下沉
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">sink</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">m_length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 由于堆的性质父节点为k则其左子树为2*k即j
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
            <span class="c1">// 这里先比较左子树和右子树的大小，将最大的那个键记录下来再和父节点比较
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">m_length</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pArray</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pArray</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="c1">// 和父节点比较如果父节点比最大的子节点还要大，则直接退出循环
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">pArray</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pArray</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
            <span class="c1">// 如果父节点比子节点小则交换
</span><span class="c1"></span>            <span class="n">swap</span><span class="p">(</span><span class="n">pArray</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">pArray</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="c1">// k值变大继续下沉
</span><span class="c1"></span>            <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// 实现myvector
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">myvector</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">iterator</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">value_type</span><span class="o">*</span> <span class="n">_data</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">_size</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">_capacity</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">myvector</span><span class="p">()</span><span class="o">:</span><span class="n">_data</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="n">_size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">_capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>
    <span class="o">~</span><span class="n">myvector</span><span class="p">(){</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">_data</span><span class="p">;</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">_capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myvector</span><span class="p">(</span><span class="k">const</span> <span class="n">myvector</span><span class="o">&amp;</span> <span class="n">vec</span><span class="p">){</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>
        <span class="n">_capacity</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">value_type</span><span class="p">[</span><span class="n">_capacity</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">myvector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">myvector</span><span class="o">&amp;</span> <span class="n">vec</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">value_type</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">value_type</span><span class="p">[</span><span class="n">vec</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vec</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">_data</span><span class="p">;</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>
        <span class="n">_capacity</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">value_type</span> <span class="n">val</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">_capacity</span><span class="p">){</span>
            <span class="n">_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">value_type</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">_size</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">_capacity</span><span class="p">){</span>
            <span class="n">_capacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">value_type</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">value_type</span><span class="p">[</span><span class="n">_capacity</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">delete</span> <span class="p">[]</span> <span class="n">_data</span><span class="p">;</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_data</span><span class="p">[</span><span class="n">_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="o">++</span><span class="n">_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span><span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;}</span>
<span class="o">==</span> <span class="mi">0</span><span class="p">;}</span>
    <span class="n">value_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">it</span><span class="p">){</span>
        <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">_data</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">index</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">_size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">(){</span> <span class="k">return</span> <span class="n">_data</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">(){</span> <span class="k">return</span> <span class="n">_data</span> <span class="o">+</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// 找到最短路
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vis</span><span class="p">[],</span> <span class="n">myvector</span><span class="o">&lt;</span><span class="n">Mypair</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">dist</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">){</span>
    <span class="n">PriorityQueue</span> <span class="n">que</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span> <span class="c1">// 大顶堆
</span><span class="c1"></span>    <span class="n">Mypair</span> <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
    <span class="n">que</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">Top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">Top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">que</span><span class="p">.</span><span class="n">delMax</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">w</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">path</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
            <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">que</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="o">-</span><span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 确定中转点i，求花费。不能整除的要+1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">TurnToCash</span><span class="p">(</span><span class="kt">int</span> <span class="n">othersToN</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">oneToOthers</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">dToC</span> <span class="o">=</span> <span class="n">othersToN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">othersToN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">othersToN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">oneToOthers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dToC</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 输入路径
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">myvector</span><span class="o">&lt;</span><span class="n">Mypair</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">rpath</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">m</span><span class="o">--</span> <span class="p">){</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">Mypair</span> <span class="n">v_c</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="n">Mypair</span> <span class="n">u_d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">path</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v_c</span><span class="p">);</span>
        <span class="n">rpath</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u_d</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="c1">// 输入汇率
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">oneToOthers</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">othersToN</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="kt">bool</span> <span class="n">rvis</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
  <span class="c1">// 求最短路，和反向最短路
</span><span class="c1"></span>    <span class="n">dijkstra</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">dijkstra</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">rvis</span><span class="p">,</span> <span class="n">rpath</span><span class="p">,</span> <span class="n">othersToN</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">//    multiset&lt;int&gt; ms;
</span><span class="c1">// 枚举中转点
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span> <span class="n">q</span><span class="o">--</span> <span class="p">){</span>
        <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">node</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rvis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="c1">// 用min值维护最小的花费
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">9223372036854775807</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rvis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">){</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">TurnToCash</span><span class="p">(</span><span class="n">othersToN</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">TurnToCash</span><span class="p">(</span><span class="n">othersToN</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>

        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">min</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p><strong>满分但是用了multiset的代码</strong>：</p>
<p>把枚举中转点那一部分改成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ms</span><span class="p">;</span>
<span class="c1">// 先插入
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rvis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">){</span>
    <span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TurnToCash</span><span class="p">(</span><span class="n">othersToN</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">while</span><span class="p">(</span> <span class="n">q</span><span class="o">--</span> <span class="p">){</span>
  <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">node</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">vis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rvis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="p">){</span>
    <span class="c1">// 每次更新汇率，先删除旧汇率，再插入新的
</span><span class="c1"></span>    <span class="n">ms</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">TurnToCash</span><span class="p">(</span><span class="n">othersToN</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">);</span>
    <span class="n">a</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">ms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">TurnToCash</span><span class="p">(</span><span class="n">othersToN</span><span class="p">,</span> <span class="n">oneToOthers</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 返回顶部元素就可以啦
</span><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ms</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><strong>简单描述Dijkstra算法</strong>：</p>
<p><code>dist[i]</code>表示从初始节点到第i个节点的最短路径，初始为无穷大，每次从<code>dist[]</code>里选取未搜索过的最小的节点，用它继续更新<code>dist[]</code>。可以用<code>vis[]</code>记录已搜索节点，用<code>pre[]</code>记录每个节点的前面节点，用priority_queue优化时间复杂度。</p>
<h2 id="7-5-hand-made-cream">7-5 Hand-made Cream</h2>
<p><strong>知识点</strong>：动态规划</p>
<p><strong>思路</strong>：考察从第1个面包<code>bread[1]</code>，选到第i个面包<code>bread[i]</code>和从<code>cream[1]</code>到<code>cream[j]</code>，乘积最大的搭配<code>dp[i][j]</code>，有如下情况：</p>
<ul>
<li>如果将第i个面包和第j个面包搭配，那么<code>dp[i][j] = dp[i-1][j-1] + bread[i]*cream[j]</code>；</li>
<li>如果不搭配，那么等于前一个面包，或者前一个冰淇淋的结论，即<code>dp[i][j] = dp[i-1][j]</code>或者<code>dp[i][j] = dp[i][j-1]</code></li>
</ul>
<p>因为要求最大的值，所以综合一下：<code>dp[i][j] = max(dp[i-1][j-1]+bread[i]*cream[j],dp[i-1][j],dp[i][j-1])</code></p>
<p>初始化<code>dp[0][0]=0</code>,<code>dp[1][0]=0</code>,<code>dp[0][1]=0</code>，用两个循环，动态更新一下<code>dp</code>表就可以啦，下面是题目样例最终得到的dp表：</p>
<table>
<thead>
<tr>
<th>bread\cream</th>
<th>10</th>
<th>8</th>
<th>11</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>10</td>
<td>100</td>
<td>100</td>
<td>110</td>
<td>110</td>
</tr>
<tr>
<td>8</td>
<td>100</td>
<td>164</td>
<td>188</td>
<td>188</td>
</tr>
</tbody>
</table>
<p><strong>代码</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">)</span><span class="k">return</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1005</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1005</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1005</span><span class="p">][</span><span class="mi">1005</span><span class="p">],</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">M</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="p">;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="工欲善其事-必先利其器"><em>工欲善其事 必先利其器</em></h2>
<p><em>有一说一，Clion真的很好用，非常智能的代码提示和代码补全是应付语法复杂的c++语言的有力工具。</em></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-07-02</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="prev" rel="prev" title="《乡土中国》读书笔记"><i class="fas fa-angle-left fa-fw"></i>《乡土中国》读书笔记</a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><a href="https://travellings.link/" target="_blank" rel="noopener" title="开往-友链接力">
    <img src="https://travellings.link/assets/logo.gif" alt="开往-友链接力" width="120">
</a>  <a href="https://www.foreverblog.cn/go.html" target="_blank"> <img src="https://img.foreverblog.cn/wormhole_4_tp.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a></div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">鲁ICP备2020039365号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/valine/Valine.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"valine":{"appId":"7d4uuBoHJjcoTArKAPbPhRVC-gzGzoHsz","appKey":"6KLJGiDyLqts0JE077ta5vKm","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"visitor":true}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-FWJQFY04TK', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-FWJQFY04TK" async></script></body>
</html>
